<!DOCTYPE html>
<html>
<head>
  <title>Player Tracking</title>
  <link rel="icon" type="image/png" href="https://merkur.js.org/img/favicon.ico">
  <base target="_top">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    /* === ALL YOUR EXISTING CSS STYLES === */
    :root {
      --primary: #4361ee;
      --primary-dark: #3a56d4;
      --secondary: #7209b7;
      --success: #06d6a0;
      --warning: #ffd166;
      --danger: #ef476f;
      --info: #118ab2;
      --dark: #2b2d42;
      --light: #f8f9fa;
      --gray: #6c757d;
      --border: #e9ecef;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      
      /* Theme variables */
      --bg-primary: #ffffff;
      --bg-secondary: #f8f9fa;
      --bg-card: #ffffff;
      --text-primary: #2b2d42;
      --text-secondary: #6c757d;
      --border-color: #e9ecef;
      --shadow-color: rgba(0, 0, 0, 0.1);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg-primary: #1a1b23;
        --bg-secondary: #2d2e3a;
        --bg-card: #2d2e3a;
        --text-primary: #ffffff;
        --text-secondary: #a0a0a0;
        --border-color: #3a3b4a;
        --shadow-color: rgba(0, 0, 0, 0.3);
      }
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.6;
      transition: all 0.3s ease;
    }

    /* ==================== */
    /* PIN SCREEN STYLES */
    /* ==================== */
    #pinScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      z-index: 9999;
    }

    .pin-container {
      background: var(--bg-card);
      border-radius: 20px;
      padding: 3rem;
      box-shadow: var(--shadow-lg);
      text-align: center;
      max-width: 400px;
      width: 100%;
      border: 1px solid var(--border-color);
      animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .pin-logo {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .pin-subtitle {
      color: var(--text-secondary);
      font-size: 1rem;
      margin-bottom: 2rem;
      font-weight: 400;
    }

    .pin-input-container {
      position: relative;
      margin-bottom: 1.5rem;
    }

    .pin-input {
      width: 100%;
      padding: 1.2rem 1.5rem;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      font-size: 1.5rem;
      text-align: center;
      letter-spacing: 0.5rem;
      background: var(--bg-card);
      color: var(--text-primary);
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .pin-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
    }

    .pin-input.error {
      border-color: var(--danger);
      animation: shake 0.5s ease;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }

    .pin-input.locked {
      background: var(--bg-secondary);
      border-color: var(--border-color);
      color: var(--text-secondary);
      cursor: not-allowed;
    }

    .pin-status {
      margin-top: 0.75rem;
      min-height: 1.5rem;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .pin-status.error {
      color: var(--danger);
    }

    .pin-status.warning {
      color: var(--warning);
    }

    .pin-status.success {
      color: var(--success);
    }

    .pin-status.info {
      color: var(--info);
    }

    .pin-attempts {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .pin-lockout {
      margin-top: 1rem;
      padding: 1rem;
      background: rgba(239, 71, 111, 0.1);
      border-radius: 10px;
      border: 1px solid var(--danger);
    }

    .lockout-timer {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--danger);
      margin: 0.5rem 0;
    }

    .lockout-message {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .pin-btn {
      width: 100%;
      padding: 1rem;
      border: none;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .pin-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }

    .pin-btn:hover::before {
      left: 100%;
    }

    .pin-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .pin-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      pointer-events: none;
    }

    .pin-btn:disabled:hover::before {
      left: -100%;
    }

    .pin-footer {
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border-color);
      font-size: 0.85rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    /* Landing Page */
    #landing {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 2rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .landing-container {
      background: var(--bg-card);
      border-radius: 20px;
      padding: 3rem;
      box-shadow: var(--shadow-lg);
      text-align: center;
      max-width: 600px;
      width: 100%;
      border: 1px solid var(--border-color);
    }

    .logo {
      font-size: 3rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 1rem;
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 1.1rem;
      margin-bottom: 2rem;
      font-weight: 400;
    }

    #logoutBtnLanding {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
      border: 2px solid var(--danger);
      transition: all 0.3s ease;
      width: auto !important;
      padding: 0.75rem 1.5rem !important;
      margin-top: 2.5rem; /* Increased margin */
    }

    #logoutBtnLanding:hover:not(:disabled) {
      background: var(--danger);
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
    }

    #logoutBtnLanding:active:not(:disabled) {
      transform: translateY(0);
    }

    #logoutBtnLanding:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      pointer-events: none;
    }

    .search-section {
      margin-bottom: 2rem;
      text-align: left;
    }

    .section-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .search-container {
      position: relative;
      margin-bottom: 1rem;
    }

    .search-input {
      width: 100%;
      padding: 1rem 1.5rem;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      font-size: 1rem;
      transition: all 0.3s ease;
      background: var(--bg-card);
      color: var(--text-primary);
    }

    .search-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
    }

    .search-icon {
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-secondary);
    }

    #pageSuggestions,
    #playerSuggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: var(--shadow-lg);
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      margin-top: 0.5rem;
    }

    .suggestion-item {
      padding: 1rem 1.5rem;
      cursor: pointer;
      border-bottom: 1px solid var(--border-color);
      transition: background-color 0.2s ease;
      color: var(--text-primary);
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
    }

    .suggestion-item:hover {
      background-color: var(--bg-secondary);
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .page-emoji {
      font-size: 1.2rem;
      width: 24px;
      text-align: center;
    }

    .player-pages {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      margin-top: 0.25rem;
    }

    .page-indicator {
      background: var(--primary);
      color: white;
      padding: 0.2rem 0.5rem;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 500;
      white-space: nowrap;
    }

    .btn {
      padding: 1rem 2rem;
      border: none;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }

    .btn:hover::before {
      left: 100%;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      box-shadow: var(--shadow);
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-3px);
      box-shadow: var(--shadow-lg);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      pointer-events: none;
    }

    .btn:disabled:hover::before {
      left: -100%;
    }

    .btn-primary:disabled {
      background: #94a3b8;
      color: #cbd5e1;
    }

    .btn-secondary:disabled {
      background: var(--bg-secondary);
      color: var(--text-secondary);
      border-color: var(--border-color);
    }

    .btn-success:disabled {
      background: #a7f3d0;
      color: #065f46;
    }

    .btn-warning:disabled {
      background: #fef3c7;
      color: #92400e;
    }

    .btn-danger:disabled {
      background: #fecaca;
      color: #991b1b;
    }

    .btn-secondary {
      background: var(--bg-card);
      color: var(--text-secondary);
      border: 2px solid var(--border-color);
      box-shadow: var(--shadow);
    }

    .btn-secondary:hover:not(:disabled) {
      border-color: var(--primary);
      color: var(--primary);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .btn-success {
      background: var(--success);
      color: white;
      box-shadow: var(--shadow);
    }

    .btn-success:hover:not(:disabled) {
      background: #05b58c;
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .btn-warning {
      background: var(--warning);
      color: var(--dark);
      box-shadow: var(--shadow);
    }

    .btn-warning:hover:not(:disabled) {
      background: #fbbf24;
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .btn-danger {
      background: var(--danger);
      color: white;
      box-shadow: var(--shadow);
    }

    .btn-danger:hover:not(:disabled) {
      background: #e53e3e;
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    /* Dashboard */
    #dashboard {
      display: none;
      min-height: 100vh;
      background: var(--bg-secondary);
    }

    .dashboard-header {
      background: var(--bg-card);
      box-shadow: var(--shadow);
      padding: 1.5rem 2rem;
      position: sticky;
      top: 0;
      z-index: 100;
      border-bottom: 1px solid var(--border-color);
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1400px;
      margin: 0 auto;
    }

    .page-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .control-buttons {
      display: flex;
      gap: 1rem;
    }

    .dashboard-content {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
    }

    /* Stats Grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .stats-grid-row-2 {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .stats-grid-row-3 {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .stat-card {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 2rem;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      cursor: pointer;
      border-left: 4px solid var(--primary);
      border: 1px solid var(--border-color);
      text-align: center;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .stat-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      transform: scaleX(0);
      transform-origin: left;
      transition: transform 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: var(--shadow-lg);
    }

    .stat-card:hover::before {
      transform: scaleX(1);
    }

    .stat-card.total { border-left-color: var(--primary); }
    .stat-card.active { border-left-color: var(--success); }
    .stat-card.inactive { border-left-color: var(--danger); }
    .stat-card.recent-active { border-left-color: var(--info); }
    .stat-card.recent-inactive { border-left-color: var(--warning); }
    .stat-card.high-risk { border-left-color: var(--danger); }
    .stat-card.history { border-left-color: var(--secondary); }
    .stat-card.deposits { border-left-color: #f59e0b; }
    .stat-card.recovery { border-left-color: #06d6a0; }

    .stat-value {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
      color: var(--text-primary);
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .stat-label {
      color: var(--text-secondary);
      font-weight: 500;
      text-align: center;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      justify-content: center;
    }

    .stat-icon {
      font-size: 2rem;
      margin-bottom: 1rem;
      opacity: 0.8;
      text-align: center;
    }

    /* CLIENT RECOVERY BUTTON STYLES */
    .recovery-btn {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      white-space: nowrap;
    }

    .recovery-btn.mark {
      background: var(--primary);
      color: white;
    }

    .recovery-btn.mark:hover:not(:disabled) {
      background: var(--primary-dark);
      transform: translateY(-1px);
    }

    .recovery-btn.recovered {
      background: #e5e7eb;
      color: #6b7280;
      border: 1px solid #d1d5db;
      cursor: not-allowed;
    }

    .recovery-btn:disabled {
      opacity: 0.7;
      cursor: not-allowed;
      transform: none !important;
    }

    /* RECOVERY MODAL STYLES */
    .recovery-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2001;
      backdrop-filter: blur(4px);
    }

    .recovery-modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-card);
      border-radius: 16px;
      padding: 2rem;
      box-shadow: var(--shadow-lg);
      max-width: 500px;
      width: 90%;
      border: 1px solid var(--border-color);
    }

    .recovery-modal-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 1.5rem;
      text-align: center;
      color: var(--text-primary);
    }

    .recovery-method-selector {
      display: flex;
      gap: 1rem;
      margin-bottom: 1.5rem;
      justify-content: center;
    }

    .recovery-method-btn {
      padding: 1rem 1.5rem;
      border: 2px solid var(--border-color);
      border-radius: 10px;
      background: var(--bg-card);
      color: var(--text-primary);
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
      text-align: center;
    }

    .recovery-method-btn:hover {
      border-color: var(--primary);
      background: var(--bg-secondary);
    }

    .recovery-method-btn.active {
      border-color: var(--primary);
      background: rgba(67, 97, 238, 0.1);
    }

    .recovery-method-icon {
      font-size: 1.5rem;
    }

    .recovery-notes-input {
      width: 100%;
      padding: 1rem;
      border: 2px solid var(--border-color);
      border-radius: 10px;
      font-size: 0.95rem;
      background: var(--bg-card);
      color: var(--text-primary);
      resize: vertical;
      min-height: 80px;
      font-family: inherit;
      margin-bottom: 1.5rem;
    }

    .recovery-notes-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    /* REMOVAL MODAL STYLES - UPDATED */
    .removal-reason-selector {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      margin: 1.5rem 0;
    }

    .removal-pin-input {
      width: 100%;
      padding: 1rem;
      border: 2px solid var(--border-color);
      border-radius: 10px;
      font-size: 1.2rem;
      text-align: center;
      letter-spacing: 0.3rem;
      background: var(--bg-card);
      color: var(--text-primary);
      margin: 1.5rem 0;
    }

    .removal-pin-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    /* RECOVERY DASHBOARD STYLES - FIXED */
    .recovery-dashboard {
      background: var(--bg-card);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    /* ENHANCED: Recovery tabs visibility */
    .recovery-tabs {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-primary);
      padding: 0;
    }

    .recovery-tab {
      padding: 1rem 2rem;
      background: var(--bg-secondary);
      border: none;
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      flex: 1;
      text-align: center;
      border-right: 1px solid var(--border-color);
    }

    .recovery-tab:last-child {
      border-right: none;
    }

    .recovery-tab:hover {
      color: var(--text-primary);
      background: var(--bg-card);
    }

    .recovery-tab.active {
      color: var(--primary);
      background: var(--bg-card);
      border-bottom: 3px solid var(--primary);
    }

    .recovery-content {
      padding: 0;
    }

    /* ENHANCED: Recovery search visibility */
    .recovery-search-container {
      padding: 1.5rem;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-secondary);
    }

    .recovery-search-container .search-input {
      width: 100%;
      font-size: 1rem;
      padding: 0.875rem 1.25rem;
      border: 2px solid var(--primary);
      background: var(--bg-card);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* FIXED: Recovery stats layout */
    .recovery-stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1.5rem;
      padding: 1.5rem;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
    }

    .recovery-stat {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      background: var(--bg-card);
      border-radius: 12px;
      border: 1px solid var(--border-color);
      text-align: center;
      box-shadow: var(--shadow);
    }

    .recovery-stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-primary);
      line-height: 1;
    }

    .recovery-stat-label {
      font-size: 0.875rem;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .recovery-table-container {
      overflow-x: auto;
    }

    /* FIXED: Recovery table alignment - UPDATED */
    .recovery-table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
      font-size: 0.85rem;
    }

    .recovery-table th {
      background: var(--bg-secondary);
      padding: 0.875rem 0.75rem;
      text-align: left;
      font-weight: 600;
      color: var(--text-secondary);
      border-bottom: 2px solid var(--border-color);
      white-space: nowrap;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .recovery-table td {
      padding: 0.875rem 0.75rem;
      border-bottom: 1px solid var(--border-color);
      color: var(--text-primary);
      vertical-align: middle;
      word-wrap: break-word;
    }

    .recovery-table tr:hover {
      background: var(--bg-secondary);
    }

    .recovery-table .status-active {
      color: var(--success);
      font-weight: 600;
      background: rgba(6, 214, 160, 0.1);
      padding: 0.25rem 0.5rem;
      border-radius: 12px;
      font-size: 0.75rem;
    }

    .recovery-table .status-inactive {
      color: var(--danger);
      font-weight: 600;
      background: rgba(239, 71, 111, 0.1);
      padding: 0.25rem 0.5rem;
      border-radius: 12px;
      font-size: 0.75rem;
    }

    /* Method styles - TEXT instead of emoji */
    .method-chat {
      color: var(--info);
      font-weight: 500;
      background: rgba(6, 214, 160, 0.1);
      padding: 0.25rem 0.5rem;
      border-radius: 8px;
      text-align: center;
    }

    .method-offer {
      color: #f59e0b;
      font-weight: 500;
      background: rgba(245, 158, 11, 0.1);
      padding: 0.25rem 0.5rem;
      border-radius: 8px;
      text-align: center;
    }

    .view-notes-btn {
      padding: 0.4rem 0.8rem;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-primary);
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .view-notes-btn:hover {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .removal-btn {
      padding: 0.5rem 1rem;
      border: 1px solid var(--danger);
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .removal-btn:hover {
      background: var(--danger);
      color: white;
    }

    .removal-btn:disabled,
    .removal-btn.disabled {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }

    /* NOTES MODAL STYLES */
    .notes-modal-content {
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .notes-display {
      background: var(--bg-secondary);
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      margin-top: 1rem;
      white-space: pre-wrap;
      word-wrap: break-word;
      line-height: 1.5;
      max-height: 300px;
      overflow-y: auto;
    }

    /* ANALYTICS PANEL - UPDATED LAYOUT */
    .analytics-panel {
      padding: 2rem;
    }

    .analytics-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .analytics-stats-row2 {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .analytic-card {
      background: var(--bg-secondary);
      padding: 1.5rem;
      border-radius: 12px;
      text-align: center;
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow);
    }

    .analytic-value {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
      color: var(--text-primary);
    }

    .analytic-label {
      color: var(--text-secondary);
      font-size: 0.9rem;
      font-weight: 500;
    }

    /* Tables */
    .table-container {
      background: var(--bg-card);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    .table-header {
      padding: 1.5rem 2rem;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .table-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .pagination-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .pagination-info {
      color: var(--text-secondary);
      font-size: 0.875rem;
    }

    .pagination-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .pagination-btn {
      padding: 0.5rem 1rem;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .pagination-btn:hover:not(:disabled) {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .pagination-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pagination-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th {
      background: var(--bg-secondary);
      padding: 1rem 1.5rem;
      text-align: left;
      font-weight: 600;
      color: var(--text-secondary);
      border-bottom: 1px solid var(--border-color);
    }

    td {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border-color);
      color: var(--text-primary);
    }

    tr:last-child td {
      border-bottom: none;
    }

    tr:hover {
      background: var(--bg-secondary);
    }

    .status-badge {
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .status-active {
      background: #d1fae5;
      color: #065f46;
    }

    .status-inactive {
      background: #fee2e2;
      color: #991b1b;
    }

    /* Notes Button */
    .notes-btn {
      padding: 0.5rem 1rem;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.875rem;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .notes-btn:hover {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .notes-btn.has-notes {
      background: var(--warning);
      color: var(--dark);
      border-color: var(--warning);
    }

    .notes-btn.has-notes:hover {
      background: #f59e0b;
      border-color: #f59e0b;
    }

    /* Player History */
    .player-history {
      background: var(--bg-card);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 2rem;
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    /* FIXED: Player Status Container - UPDATED */
    .player-status-container {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
      text-align: center;
    }

    .player-status-container.active {
      border-left: 4px solid var(--success);
      background: rgba(6, 214, 160, 0.1);
    }

    .player-status-container.inactive {
      border-left: 4px solid var(--danger);
      background: rgba(239, 71, 111, 0.1);
    }

    .player-status-icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .player-status-text {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    /* Enhanced Player History Table */
    .enhanced-history-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }

    .enhanced-history-table th {
      background: var(--bg-secondary);
      padding: 1rem;
      text-align: left;
      font-weight: 600;
      color: var(--text-secondary);
      border-bottom: 2px solid var(--border-color);
    }

    .enhanced-history-table td {
      padding: 1rem;
      border-bottom: 1px solid var(--border-color);
    }

    /* Daily Deposits Table */
    .daily-deposits-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
      font-size: 0.9rem;
    }

    .daily-deposits-table th {
      background: var(--bg-secondary);
      padding: 0.75rem 1rem;
      font-weight: 600;
      color: var(--text-secondary);
      border-bottom: 2px solid var(--border-color);
      white-space: nowrap;
    }

    .daily-deposits-table td {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border-color);
      white-space: nowrap;
    }

    .amount-cell {
      text-align: right !important;
      font-weight: 600;
    }

    .amount-cell.positive {
      color: var(--success);
    }

    .amount-cell.zero {
      color: var(--text-secondary);
    }

    /* FIXED: Page Deposits Layout */
    .page-deposits-view {
      background: var(--bg-card);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 2rem;
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
      position: relative;
    }

    .deposits-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--border-color);
    }

    .deposits-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .close-deposits-btn {
      background: none;
      border: none;
      font-size: 1.5rem;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 8px;
      transition: all 0.2s ease;
    }

    .close-deposits-btn:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .monthly-comparison {
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1.5rem;
      text-align: center;
      font-weight: 500;
      border: 1px solid var(--border-color);
    }

    .monthly-comparison.up {
      background: rgba(6, 214, 160, 0.1);
      color: var(--success);
      border-color: var(--success);
    }

    .monthly-comparison.down {
      background: rgba(239, 71, 111, 0.1);
      color: var(--danger);
      border-color: var(--danger);
    }

    .monthly-comparison.same {
      background: var(--bg-secondary);
      color: var(--text-secondary);
    }

    /* FIXED: Monthly Summary Cards */
    .monthly-summary {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .summary-card {
      background: var(--bg-secondary);
      padding: 1.5rem;
      border-radius: 12px;
      text-align: center;
      border: 1px solid var(--border-color);
    }

    .summary-value {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
      color: var(--text-primary);
    }

    .summary-label {
      color: var(--text-secondary);
      font-size: 0.875rem;
      font-weight: 500;
    }

    /* Trend styles */
    .trend-up {
      color: var(--success);
    }

    .trend-down {
      color: var(--danger);
    }

    .trend-same {
      color: var(--text-secondary);
    }

    .trend-cell {
      text-align: center;
    }

    .count-cell {
      text-align: center;
    }

    /* Enhanced Loader Styles */
    #loader {
      display: none;
      text-align: center;
      padding: 4rem 2rem;
    }

    .loading-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 50vh;
      padding: 2rem;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid var(--border-color);
      border-left: 4px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-progress {
      margin-top: 1rem;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      backdrop-filter: blur(4px);
    }

    .modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-card);
      border-radius: 20px;
      padding: 2rem;
      box-shadow: var(--shadow-lg);
      max-width: 800px;
      width: 90%;
      border: 1px solid var(--border-color);
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 1rem;
      text-align: center;
      color: var(--text-primary);
    }

    .modal-input {
      width: 100%;
      padding: 1rem;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      font-size: 1rem;
      text-align: center;
      letter-spacing: 0.5rem;
      margin-bottom: 1.5rem;
      background: var(--bg-card);
      color: var(--text-primary);
    }

    .modal-textarea {
      width: 100%;
      padding: 1rem;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      font-size: 1rem;
      background: var(--bg-card);
      color: var(--text-primary);
      resize: vertical;
      min-height: 120px;
      font-family: inherit;
    }

    .modal-textarea:focus {
      outline: none;
      border-color: var(--primary);
    }

    .modal-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .modal-buttons {
      display: flex;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .modal-buttons .btn {
      flex: 1;
      justify-content: center;
    }

    /* Notes History */
    .notes-history {
      margin-top: 1.5rem;
      max-height: 300px;
      overflow-y: auto;
    }

    .notes-history-title {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: var(--text-primary);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.5rem;
    }

    .note-item {
      padding: 1rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin-bottom: 0.75rem;
      background: var(--bg-secondary);
    }

    .note-timestamp {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }

    .note-text {
      color: var(--text-primary);
      line-height: 1.4;
    }

    .no-notes {
      text-align: center;
      color: var(--text-secondary);
      font-style: italic;
      padding: 1rem;
    }

    /* Notifications */
    .notification {
      position: fixed;
      top: 2rem;
      right: 2rem;
      padding: 1rem 1.5rem;
      border-radius: 12px;
      color: white;
      font-weight: 500;
      box-shadow: var(--shadow-lg);
      z-index: 3000;
      animation: slideIn 0.3s ease;
    }

    .notification.success { background: var(--success); }
    .notification.error { background: var(--danger); }
    .notification.warning { background: var(--warning); color: var(--dark); }

    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    /* FIXED: High Risk Table Styles - UPDATED */
    .high-risk-table {
      font-size: 0.8rem !important; /* Smaller font for high risk table */
    }

    .high-risk-table th {
      padding: 0.75rem 0.5rem !important;
      font-size: 0.75rem !important;
    }

    .high-risk-table td {
      padding: 0.75rem 0.5rem !important;
      font-size: 0.75rem !important;
    }

    .high-risk-table .recovery-btn {
      font-size: 0.7rem !important;
      padding: 0.3rem 0.6rem !important;
    }

    .high-risk-table .notes-btn {
      font-size: 0.7rem !important;
      padding: 0.3rem 0.6rem !important;
    }

    /* NEW: Risk Level Color Classes */
    .risk-very-high {
      color: #ef4444 !important;
      font-weight: 600 !important;
      background: rgba(239, 68, 68, 0.1);
      padding: 0.25rem 0.5rem;
      border-radius: 8px;
      text-align: center;
    }

    .risk-high {
      color: #f97316 !important;
      font-weight: 600 !important;
      background: rgba(249, 115, 22, 0.1);
      padding: 0.25rem 0.5rem;
      border-radius: 8px;
      text-align: center;
    }

    .risk-medium {
      color: #f59e0b !important;
      font-weight: 600 !important;
      background: rgba(245, 158, 11, 0.1);
      padding: 0.25rem 0.5rem;
      border-radius: 8px;
      text-align: center;
    }

    .risk-low {
      color: #10b981 !important;
      font-weight: 600 !important;
      background: rgba(16, 185, 129, 0.1);
      padding: 0.25rem 0.5rem;
      border-radius: 8px;
      text-align: center;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .stats-grid,
      .stats-grid-row-2,
      .stats-grid-row-3 {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .pin-container {
        padding: 2rem;
        max-width: 380px;
      }
      
      .recovery-stats {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .monthly-summary {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .analytics-stats,
      .analytics-stats-row2 {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 768px) {
      .pin-container {
        padding: 1.5rem;
        max-width: 350px;
      }
      
      .pin-logo {
        font-size: 2rem;
      }
      
      .pin-input {
        font-size: 1.2rem;
        padding: 1rem;
      }
      
      .landing-container {
        padding: 2rem 1.5rem;
      }
      
      .dashboard-content {
        padding: 1rem;
      }
      
      .stats-grid,
      .stats-grid-row-2,
      .stats-grid-row-3 {
        grid-template-columns: 1fr;
      }
      
      .header-content {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
      }
      
      .control-buttons {
        flex-wrap: wrap;
        justify-content: center;
      }
      
      .table-header {
        flex-direction: column;
        gap: 1rem;
        align-items: flex-start;
      }
      
      .pagination-controls {
        width: 100%;
        justify-content: space-between;
      }
      
      table {
        font-size: 0.875rem;
      }
      
      th, td {
        padding: 0.75rem 1rem;
      }
      
      .modal-content {
        padding: 1.5rem;
        max-width: 95%;
      }

      .daily-deposits-table {
        font-size: 0.8rem;
      }
      
      .daily-deposits-table th,
      .daily-deposits-table td {
        padding: 0.5rem 0.5rem;
      }

      .recovery-method-selector {
        flex-direction: column;
      }
      
      .recovery-stats {
        grid-template-columns: 1fr;
      }
      
      .monthly-summary {
        grid-template-columns: 1fr;
      }
      
      .recovery-table {
        font-size: 0.7rem;
      }
      
      .recovery-table th,
      .recovery-table td {
        padding: 0.5rem;
      }
      
      .analytics-stats,
      .analytics-stats-row2 {
        grid-template-columns: 1fr;
      }
      
      .recovery-tab {
        padding: 0.75rem 1rem;
        font-size: 0.9rem;
      }
    }
    
    @media (max-width: 480px) {
      .pin-container {
        padding: 1.5rem;
        max-width: 320px;
      }
      
      .pin-logo {
        font-size: 1.75rem;
      }
      
      .pin-subtitle {
        font-size: 0.9rem;
      }
      
      .recovery-tab {
        padding: 0.5rem 0.75rem;
        font-size: 0.8rem;
      }
    }
  </style>
</head>

<body>
  <!-- PIN SCREEN -->
  <div id="pinScreen">
    <div class="pin-container">
      <div class="pin-logo">
        <i class="fas fa-chart-line"></i> Tech Pulse
      </div>
      <p class="pin-subtitle">Marketing Analytics Portal</p>
      
      <div class="pin-input-container">
        <input 
          type="password" 
          id="pinInput" 
          class="pin-input" 
          placeholder="Enter PIN" 
          maxlength="5"
          inputmode="numeric"
          pattern="[0-9]*"
        />
        <div id="pinStatus" class="pin-status"></div>
        <div id="pinAttempts" class="pin-attempts"></div>
        <div id="pinLockout" class="pin-lockout" style="display: none;">
          <div class="lockout-timer" id="lockoutTimer">10:00</div>
          <div class="lockout-message">Account locked. Please try again later.</div>
        </div>
      </div>
      
      <button id="pinSubmit" class="pin-btn">
        <i class="fas fa-lock"></i> Access Dashboard
      </button>
      
      <div class="pin-footer">
        <i class="fas fa-shield-alt"></i> Secure Access Required
      </div>
    </div>
  </div>

  <!-- RECOVERY MODAL -->
  <div id="recoveryModal" class="recovery-modal">
    <div class="recovery-modal-content">
      <h3 class="recovery-modal-title" id="recoveryModalTitle">Mark Player as Recovered</h3>
      
      <div class="recovery-method-selector">
        <button class="recovery-method-btn" data-method="chat" onclick="selectRecoveryMethod('chat')">
          <i class="fas fa-comment-dots recovery-method-icon"></i>
          <span>Chat</span>
        </button>
        <button class="recovery-method-btn" data-method="offer" onclick="selectRecoveryMethod('offer')">
          <i class="fas fa-gift recovery-method-icon"></i>
          <span>Offer</span>
        </button>
      </div>
      
      <input type="hidden" id="recoveryPlayerName">
      <input type="hidden" id="recoveryPlayerPage">
      
      <div>
        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-primary); font-weight: 500;">
          Recovery Notes (Optional):
        </label>
        <textarea 
          id="recoveryNotesInput" 
          class="recovery-notes-input" 
          placeholder="Enter recovery notes... (e.g., WhatsApp, 20% bonus)"
        ></textarea>
      </div>
      
      <div class="modal-buttons">
        <button class="btn btn-secondary" onclick="hideRecoveryModal()">
          <i class="fas fa-times"></i> Cancel
        </button>
        <button class="btn btn-success" onclick="confirmRecovery()" id="confirmRecoveryBtn">
          <i class="fas fa-check"></i> Mark as Recovered
        </button>
      </div>
    </div>
  </div>

  <!-- REMOVAL MODAL - UPDATED -->
  <div id="removalModal" class="recovery-modal">
    <div class="recovery-modal-content">
      <h3 class="recovery-modal-title">Remove from Recovery List</h3>
      
      <div style="margin-bottom: 1.5rem;">
        <p style="color: var(--text-primary); margin-bottom: 0.5rem;">
          Player: <strong id="removalPlayerName"></strong>
        </p>
        <p style="color: var(--text-secondary); font-size: 0.9rem;">
          Recovered: <span id="removalRecoveredDate"></span> via <span id="removalMethod"></span>
        </p>
      </div>
      
      <div>
        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-primary); font-weight: 500;">
          Reason for Removal:
        </label>
        <textarea 
          id="removalNotesInput" 
          class="recovery-notes-input" 
          placeholder="Enter reason for removal..."
          rows="3"
        ></textarea>
      </div>
      
      <div style="margin-top: 1.5rem;">
        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-primary); font-weight: 500;">
          Enter PIN to Confirm:
        </label>
        <input 
          type="password" 
          id="removalPinInput" 
          class="removal-pin-input" 
          placeholder="••••" 
          maxlength="4"
          inputmode="numeric"
        />
      </div>
      
      <input type="hidden" id="removalRecordId">
      
      <div class="modal-buttons">
        <button class="btn btn-secondary" onclick="hideRemovalModal()">
          <i class="fas fa-times"></i> Cancel
        </button>
        <button class="btn btn-danger" onclick="confirmRemoval()" id="confirmRemovalBtn">
          <i class="fas fa-trash"></i> Confirm Removal
        </button>
      </div>
    </div>
  </div>

  <!-- NOTES VIEW MODAL -->
  <div id="notesViewModal" class="modal">
    <div class="modal-content notes-modal-content">
      <h3 class="modal-title" id="notesViewModalTitle">Recovery Notes</h3>
      
      <div id="notesViewContent" class="notes-display">
        Loading notes...
      </div>
      
      <div class="modal-buttons">
        <button class="btn btn-secondary" onclick="hideNotesViewModal()">
          <i class="fas fa-times"></i> Close
        </button>
      </div>
    </div>
  </div>

  <!-- Landing Page -->
  <div id="landing">
    <div class="landing-container">
      <div class="logo">
        <i class="fas fa-chart-line"></i> Tech Pulse
      </div>
      <p class="subtitle">Marketing Department Analytics Dashboard</p>
      
      <!-- Page Search Section -->
      <div class="search-section">
        <div class="section-title">
          <i class="fas fa-search"></i> Search for a Page
        </div>
        <div class="search-container">
          <input 
            type="text" 
            id="pageSelectSearch" 
            class="search-input" 
            placeholder="Search for a page..."
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
          >
          <i class="fas fa-search search-icon"></i>
          <div id="pageSuggestions"></div>
        </div>
      </div>
      
      <!-- Player Search Section -->
      <div class="search-section">
        <div class="section-title">
          <i class="fas fa-user"></i> Search for a Player (All Pages)
        </div>
        <div class="search-container">
          <input 
            type="text" 
            id="playerSearchInput" 
            class="search-input" 
            placeholder="Search for a player across all pages..."
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
          >
          <i class="fas fa-search search-icon"></i>
          <div id="playerSuggestions"></div>
        </div>
      </div>
      
      <button id="findBtn" class="btn btn-primary" onclick="findData()">
        <i class="fas fa-arrow-right"></i> Access Dashboard
      </button>
      
      <!-- Logout Button on Landing Page - UPDATED: Removed secure session text and added more spacing -->
      <div id="landingLogoutSection" style="margin-top: 2.5rem; padding-top: 1.5rem; border-top: 1px solid var(--border-color); text-align: center; display: none;">
        <button id="logoutBtnLanding" class="btn btn-secondary" style="width: auto; padding: 0.75rem 1.5rem;">
          <i class="fas fa-sign-out-alt"></i> Logout
        </button>
        <!-- Removed Secure Session Active text -->
      </div>
    </div>
  </div>

  <!-- Dashboard -->
  <div id="dashboard">
    <header class="dashboard-header">
      <div class="header-content">
        <h1 class="page-title" id="pageTitle"></h1>
        <div class="control-buttons">
          <button id="changePageBtn" class="btn btn-secondary" onclick="backToLanding()">
            <i class="fas fa-exchange-alt"></i> Change Page
          </button>
          <button id="refreshDataBtn" class="btn btn-success" onclick="showRefreshModal()">
            <i class="fas fa-sync-alt"></i> Refresh Data
          </button>
          <button id="forceCleanupBtn" class="btn btn-warning" onclick="showCleanupModal()">
            <i class="fas fa-broom"></i> Force Cleanup
          </button>
          <button id="logoutBtnDashboard" class="btn btn-secondary" style="display: none;">
            <i class="fas fa-sign-out-alt"></i> Logout
          </button>
        </div>
      </div>
    </header>

    <div class="dashboard-content">
      <div id="loader">
        <div class="loading-screen">
          <div class="spinner"></div>
          <p>Loading dashboard data...</p>
          <div id="loadingProgress" class="loading-progress"></div>
        </div>
      </div>

      <!-- Dashboard Stats Boxes -->
      <div id="dashboardBoxes">
        <!-- First Row: Total, Active, Inactive -->
        <div class="stats-grid" id="statsRow1"></div>
        <!-- Second Row: Recent Active, Recent Inactive, High Risk -->
        <div class="stats-grid-row-2" id="statsRow2"></div>
        <!-- Third Row: Player History, Page Deposits, and Recovered Clients -->
        <div class="stats-grid-row-3" id="statsRow3"></div>
      </div>

      <!-- Client Recovery Dashboard -->
      <div id="clientRecoveryDashboard" style="display: none;"></div>

      <!-- Page Deposits View -->
      <div id="pageDepositsView" style="display: none;"></div>

      <!-- Player History Section for Dashboard -->
      <div id="playerHistorySection" style="display: none;">
        <div class="player-history">
          <h3>Player History Search - Current Page Only</h3>
          <div style="display: flex; gap: 1rem; margin: 1.5rem 0;">
            <input 
              type="text" 
              id="playerSearch" 
              class="search-input" 
              placeholder="Enter player name for current page..."
              autocomplete="off"
              autocorrect="off"
              autocapitalize="off"
              spellcheck="false"
            >
            <button class="btn btn-primary" onclick="findPlayerForCurrentPage()">
              <i class="fas fa-search"></i> Search
            </button>
          </div>
          <div id="playerHistoryContainer"></div>
        </div>
      </div>

      <!-- Global Player History Section -->
      <div id="globalPlayerHistorySection" style="display: none;">
        <div class="player-history">
          <h3>Player History - All Pages</h3>
          <div id="globalPlayerHistoryContainer"></div>
        </div>
      </div>

      <div id="tableContainer"></div>
      <div id="backContainer"></div>
    </div>
  </div>

  <!-- Existing Modals -->
  <div id="refreshModal" class="modal">
    <div class="modal-content">
      <h3 class="modal-title">Authorization Required</h3>
      <p style="text-align: center; color: var(--text-secondary); margin-bottom: 1.5rem;">
        Enter PIN to refresh data
      </p>
      <input type="password" id="refreshPinInput" class="modal-input" placeholder="****" maxlength="4">
      <div class="modal-buttons">
        <button class="btn btn-secondary" onclick="hideRefreshModal()">
          <i class="fas fa-times"></i> Cancel
        </button>
        <button class="btn btn-success" onclick="confirmRefresh()">
          <i class="fas fa-check"></i> Confirm
        </button>
      </div>
    </div>
  </div>

  <div id="cleanupModal" class="modal">
    <div class="modal-content">
      <h3 class="modal-title">Authorization Required</h3>
      <p style="text-align: center; color: var(--text-secondary); margin-bottom: 1.5rem;">
        Enter PIN to perform force cleanup
      </p>
      <input type="password" id="cleanupPinInput" class="modal-input" placeholder="****" maxlength="4">
      <div class="modal-buttons">
        <button class="btn btn-secondary" onclick="hideCleanupModal()">
          <i class="fas fa-times"></i> Cancel
        </button>
        <button class="btn btn-warning" onclick="confirmForceCleanup()">
          <i class="fas fa-check"></i> Confirm
        </button>
      </div>
    </div>
  </div>

  <div id="notesModal" class="modal">
    <div class="modal-content">
      <h3 class="modal-title" id="notesModalTitle">Add Note for Player</h3>
      
      <div>
        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-primary); font-weight: 500;">
          New Note:
        </label>
        <textarea id="noteTextInput" class="modal-textarea" placeholder="Enter your note here..."></textarea>
      </div>
      
      <div class="notes-history" id="notesHistoryContainer">
        <div class="notes-history-title">Previous Notes</div>
        <div id="notesList" class="no-notes">No notes yet for this player.</div>
      </div>
      
      <div class="modal-buttons">
        <button class="btn btn-secondary" onclick="hideNotesModal()">
          <i class="fas fa-times"></i> Cancel
        </button>
        <button id="saveNoteBtn" class="btn btn-success" onclick="savePlayerNote()">
          <i class="fas fa-save"></i> Save Note
        </button>
      </div>
    </div>
  </div>

  <script>
    // =============================================
    // PIN AUTHENTICATION SYSTEM
    // =============================================
    
    const PIN_CONFIG = {
      ADMIN_HASH: "8f9c8b7a6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b9c8d7e6f5a4b3c2d1e0f9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b9c8d7e6f5a4b3c2d1e0f9a8b7c6d5e4f3a2b1",
      VIEWER_HASH: "1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7",
      
      MAX_ATTEMPTS: 3,
      LOCKOUT_MINUTES: 10,
      
      ROLES: {
        ADMIN: 'admin',
        VIEWER: 'viewer',
        NONE: 'none'
      }
    };
    
    // Recovery PIN
    const RECOVERY_REMOVAL_PIN = "8152";
    
    // Session state
    let userRole = PIN_CONFIG.ROLES.NONE;
    let failedAttempts = 0;
    let lockoutUntil = null;
    let lockoutInterval = null;
    
    // DOM Elements for PIN system
    const pinScreen = document.getElementById('pinScreen');
    const pinInput = document.getElementById('pinInput');
    const pinSubmit = document.getElementById('pinSubmit');
    const pinStatus = document.getElementById('pinStatus');
    const pinAttempts = document.getElementById('pinAttempts');
    const pinLockout = document.getElementById('pinLockout');
    const lockoutTimer = document.getElementById('lockoutTimer');
    
    // Store original button states for UI reset
    let originalButtonStates = {};
    
    // Simple hash function
    function simpleHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return hash.toString(16);
    }
    
    // Initialize PIN system
    function initPinSystem() {
      loadSecurityState();
      
      const isAuthenticated = sessionStorage.getItem('pinAuthenticated') === 'true';
      const savedRole = sessionStorage.getItem('userRole');
      
      if (isAuthenticated && savedRole) {
        userRole = savedRole;
        showApplication();
        return;
      }
      
      checkLockoutStatus();
      
      pinInput.addEventListener('keypress', handlePinKeyPress);
      pinSubmit.addEventListener('click', verifyPin);
      pinInput.addEventListener('input', clearPinError);
      
      storeOriginalButtonStates();
      
      setTimeout(() => {
        if (pinInput && !pinInput.disabled) {
          pinInput.focus();
        }
      }, 100);
    }
    
    // Store original button states for UI reset
    function storeOriginalButtonStates() {
      const adminButtons = document.querySelectorAll('#refreshDataBtn, #forceCleanupBtn, #changePageBtn');
      adminButtons.forEach(btn => {
        const id = btn.id;
        originalButtonStates[id] = {
          className: btn.className,
          innerHTML: btn.innerHTML,
          disabled: btn.disabled
        };
      });
    }
    
    // Reset UI to default state
    function resetUI() {
      Object.keys(originalButtonStates).forEach(id => {
        const btn = document.getElementById(id);
        if (btn && originalButtonStates[id]) {
          const original = originalButtonStates[id];
          btn.className = original.className;
          btn.innerHTML = original.innerHTML;
          btn.disabled = original.disabled;
        }
      });
      
      const pageTitle = document.getElementById('pageTitle');
      if (pageTitle && pageTitle.textContent.includes('View Only')) {
        pageTitle.textContent = pageTitle.textContent.replace(' <span style="font-size: 0.8rem; background: var(--info); color: white; padding: 0.2rem 0.5rem; border-radius: 12px;">View Only</span>', '');
      }
    }
    
    // Load security state from localStorage
    function loadSecurityState() {
      try {
        const savedAttempts = localStorage.getItem('failedAttempts');
        const savedLockout = localStorage.getItem('lockoutUntil');
        
        if (savedAttempts) {
          failedAttempts = parseInt(savedAttempts, 10);
        }
        
        if (savedLockout) {
          lockoutUntil = new Date(savedLockout);
          if (lockoutUntil < new Date()) {
            resetSecurityState();
          } else {
            setTimeout(() => {
              if (lockoutUntil && lockoutUntil > new Date()) {
                disablePinInput();
                pinLockout.style.display = 'block';
                updateLockoutTimer();
                startLockoutTimer();
              }
            }, 100);
          }
        }
        
        updateAttemptsDisplay();
      } catch (error) {
        console.error('Error loading security state:', error);
        resetSecurityState();
      }
    }
    
    // Save security state to localStorage
    function saveSecurityState() {
      try {
        localStorage.setItem('failedAttempts', failedAttempts.toString());
        if (lockoutUntil) {
          localStorage.setItem('lockoutUntil', lockoutUntil.toISOString());
        } else {
          localStorage.removeItem('lockoutUntil');
        }
      } catch (error) {
        console.error('Error saving security state:', error);
      }
    }
    
    // Reset security state
    function resetSecurityState() {
      failedAttempts = 0;
      lockoutUntil = null;
      if (lockoutInterval) {
        clearInterval(lockoutInterval);
        lockoutInterval = null;
      }
      saveSecurityState();
      updateAttemptsDisplay();
    }
    
    // Check lockout status
    function checkLockoutStatus() {
      if (!lockoutUntil) return false;
      
      const now = new Date();
      if (lockoutUntil > now) {
        startLockoutTimer();
        disablePinInput();
        return true;
      } else {
        resetSecurityState();
        enablePinInput();
        return false;
      }
    }
    
    // Start lockout timer
    function startLockoutTimer() {
      if (!lockoutUntil || lockoutUntil <= new Date()) {
        if (lockoutInterval) {
          clearInterval(lockoutInterval);
          lockoutInterval = null;
        }
        resetSecurityState();
        enablePinInput();
        pinLockout.style.display = 'none';
        return;
      }
      
      pinLockout.style.display = 'block';
      updateLockoutTimer();
      
      if (lockoutInterval) {
        clearInterval(lockoutInterval);
      }
      
      lockoutInterval = setInterval(() => {
        if (!updateLockoutTimer()) {
          clearInterval(lockoutInterval);
          lockoutInterval = null;
          resetSecurityState();
          enablePinInput();
          pinLockout.style.display = 'none';
          showPinStatus('Lockout expired. You may try again.', 'info');
        }
      }, 1000);
    }
    
    // Update lockout timer display
    function updateLockoutTimer() {
      if (!lockoutUntil) return false;
      
      const now = new Date();
      const diff = lockoutUntil - now;
      
      if (diff <= 0) {
        lockoutTimer.textContent = '00:00';
        return false;
      }
      
      const minutes = Math.floor(diff / 60000);
      const seconds = Math.floor((diff % 60000) / 1000);
      lockoutTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      return true;
    }
    
    // Disable PIN input
    function disablePinInput() {
      pinInput.disabled = true;
      pinInput.classList.add('locked');
      pinInput.placeholder = 'Account Locked';
      pinSubmit.disabled = true;
    }
    
    // Enable PIN input
    function enablePinInput() {
      pinInput.disabled = false;
      pinInput.classList.remove('locked');
      pinInput.placeholder = 'Enter PIN';
      pinSubmit.disabled = false;
      pinInput.focus();
    }
    
    // Handle PIN key press
    function handlePinKeyPress(event) {
      if (event.key === 'Enter') {
        verifyPin();
      }
      
      if (!/^\d$/.test(event.key) && event.key !== 'Backspace' && event.key !== 'Delete' && event.key !== 'Tab') {
        event.preventDefault();
      }
    }
    
    // Clear PIN error
    function clearPinError() {
      pinInput.classList.remove('error');
      pinStatus.textContent = '';
      pinStatus.className = 'pin-status';
    }
    
    // Show PIN status
    function showPinStatus(message, type = 'error') {
      pinStatus.textContent = message;
      pinStatus.className = `pin-status ${type}`;
    }
    
    // Update attempts display
    function updateAttemptsDisplay() {
      const attemptsLeft = PIN_CONFIG.MAX_ATTEMPTS - failedAttempts;
      
      if (failedAttempts > 0 && attemptsLeft > 0) {
        pinAttempts.textContent = `${attemptsLeft} attempt${attemptsLeft > 1 ? 's' : ''} remaining`;
        pinAttempts.style.display = 'block';
      } else {
        pinAttempts.style.display = 'none';
      }
    }
    
    // Verify PIN
    function verifyPin() {
      const enteredPin = pinInput.value.trim();
      
      if (enteredPin.length !== 5) {
        showPinStatus('PIN must be 5 digits', 'error');
        pinInput.classList.add('error');
        return;
      }
      
      if (checkLockoutStatus()) {
        showPinStatus('Account is locked. Please wait.', 'error');
        return;
      }
      
      pinSubmit.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Verifying...';
      pinSubmit.disabled = true;
      
      setTimeout(() => {
        const pinHash = simpleHash(enteredPin);
        let role = PIN_CONFIG.ROLES.NONE;
        
        if (enteredPin === '37071') {
          role = PIN_CONFIG.ROLES.ADMIN;
        } else if (enteredPin === '81522') {
          role = PIN_CONFIG.ROLES.VIEWER;
        }
        
        if (role !== PIN_CONFIG.ROLES.NONE) {
          userRole = role;
          resetSecurityState();
          sessionStorage.setItem('pinAuthenticated', 'true');
          sessionStorage.setItem('userRole', userRole);
          sessionStorage.setItem('loginTime', new Date().toISOString());
          
          showPinStatus('Access granted!', 'success');
          pinInput.classList.remove('error');
          
          pinInput.value = '';
          
          setTimeout(() => {
            showApplication();
          }, 500);
          
        } else {
          failedAttempts++;
          saveSecurityState();
          
          if (failedAttempts >= PIN_CONFIG.MAX_ATTEMPTS) {
            lockoutUntil = new Date(Date.now() + (PIN_CONFIG.LOCKOUT_MINUTES * 60 * 1000));
            saveSecurityState();
            disablePinInput();
            pinLockout.style.display = 'block';
            updateLockoutTimer();
            showPinStatus(`Too many failed attempts. Account locked for ${PIN_CONFIG.LOCKOUT_MINUTES} minutes.`, 'error');
            
            setTimeout(() => {
              startLockoutTimer();
            }, 100);
          } else {
            const attemptsLeft = PIN_CONFIG.MAX_ATTEMPTS - failedAttempts;
            showPinStatus(`Incorrect PIN. ${attemptsLeft} attempt${attemptsLeft > 1 ? 's' : ''} remaining.`, 'error');
            pinInput.classList.add('error');
            pinInput.value = '';
            pinInput.focus();
            updateAttemptsDisplay();
          }
        }
        
        pinSubmit.innerHTML = '<i class="fas fa-lock"></i> Access Dashboard';
        pinSubmit.disabled = false;
        
      }, 800);
    }
    
    // Setup logout button
    function setupLogoutButton() {
      const logoutBtnLanding = document.getElementById('logoutBtnLanding');
      const logoutBtnDashboard = document.getElementById('logoutBtnDashboard');
      
      if (logoutBtnLanding) {
        logoutBtnLanding.onclick = logout;
      }
      
      if (logoutBtnDashboard) {
        logoutBtnDashboard.onclick = logout;
      }
    }
    
    // Show application
    function showApplication() {
      pinScreen.style.display = 'none';
      
      const savedPage = sessionStorage.getItem('currentPage');
      if (savedPage) {
        const pageObj = PAGES.find(p => p.name === savedPage);
        if (pageObj) {
          currentPageObj = pageObj;
          navigationContext = 'dashboard';
          loadDashboard(pageObj);
        } else {
          showLandingPage();
        }
      } else {
        showLandingPage();
      }
      
      applyRolePermissions();
      setupLogoutButton();
    }
    
    // Apply role-based permissions - FIXED VERSION
    function applyRolePermissions() {
      resetUI();
      
      // Always show logout button
      if (logoutBtnDashboard) {
        logoutBtnDashboard.style.display = 'inline-flex';
      }
      
      if (userRole === PIN_CONFIG.ROLES.VIEWER) {
        // Hide refresh and cleanup buttons for viewer
        const refreshBtn = document.getElementById('refreshDataBtn');
        const cleanupBtn = document.getElementById('forceCleanupBtn');
        const changePageBtn = document.getElementById('changePageBtn');
        
        if (refreshBtn) refreshBtn.style.display = 'none';
        if (cleanupBtn) cleanupBtn.style.display = 'none';
        
        // Change page button should be visible but disabled
        if (changePageBtn) {
          changePageBtn.disabled = false;
          changePageBtn.style.display = 'inline-flex';
        }
        
        // Disable all mark buttons in the current view
        disableAllMarkButtons();
        
        // Add event listener to disable mark buttons when tables are rendered
        document.addEventListener('DOMContentLoaded', function() {
          disableAllMarkButtons();
        });
        
        // Update page title to show view only
        const pageTitle = document.getElementById('pageTitle');
        if (pageTitle) {
          if (!pageTitle.textContent.includes('View Only')) {
            pageTitle.innerHTML += ' <span style="font-size: 0.8rem; background: var(--info); color: white; padding: 0.2rem 0.5rem; border-radius: 12px;">View Only</span>';
          }
        }
      } else if (userRole === PIN_CONFIG.ROLES.ADMIN) {
        // Show all buttons for admin
        const refreshBtn = document.getElementById('refreshDataBtn');
        const cleanupBtn = document.getElementById('forceCleanupBtn');
        const changePageBtn = document.getElementById('changePageBtn');
        
        if (refreshBtn) refreshBtn.style.display = 'inline-flex';
        if (cleanupBtn) cleanupBtn.style.display = 'inline-flex';
        if (changePageBtn) changePageBtn.style.display = 'inline-flex';
      }
    }
    
    // Disable all mark buttons for viewer role
    function disableAllMarkButtons() {
      if (userRole !== PIN_CONFIG.ROLES.VIEWER) return;
      
      // Find all mark buttons and disable them
      const markButtons = document.querySelectorAll('.recovery-btn.mark');
      markButtons.forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0.5';
        btn.style.cursor = 'not-allowed';
        btn.title = 'Viewer cannot mark recoveries';
      });
      
      // Also disable any mark buttons in recovery dashboard
      const removalButtons = document.querySelectorAll('.removal-btn:not(.disabled)');
      removalButtons.forEach(btn => {
        btn.disabled = true;
        btn.classList.add('disabled');
        btn.title = 'Viewer cannot remove recovered clients';
      });
    }
    
    // Logout function
    function logout() {
      sessionStorage.removeItem('pinAuthenticated');
      sessionStorage.removeItem('userRole');
      sessionStorage.removeItem('loginTime');
      sessionStorage.removeItem('currentPage');
      sessionStorage.removeItem('currentView');
      sessionStorage.removeItem('searchPlayerName');
      sessionStorage.removeItem('searchPlayerPage');
      sessionStorage.removeItem('searchPlayerPages');
      sessionStorage.removeItem('currentSearchedPlayer');
      
      userRole = PIN_CONFIG.ROLES.NONE;
      
      pinScreen.style.display = 'flex';
      document.getElementById('landing').style.display = 'none';
      document.getElementById('dashboard').style.display = 'none';
      
      pinInput.value = '';
      pinInput.focus();
      clearPinError();
      
      resetUI();
      
      checkLockoutStatus();
      
      showNotification('Successfully logged out', 'success');
    }
    
    // =============================================
    // SUPABASE CONFIGURATION
    // =============================================
    const SUPABASE_URL = "https://cqjeoslchevewbufpyzv.supabase.co";
    const SUPABASE_KEY = "sb_publishable_PhMKOO9MpDZQIf5c624tiQ_AJPguAHp";
    
    // Initialize Supabase client
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
  },
  global: {
    headers: {
      'Access-Control-Allow-Origin': '*',
    }
  }
});
    // =============================================
    // CONSTANTS AND CONFIGURATION
    // =============================================
    const DAYS_ACTIVE = 2.99;
    const INACTIVE_THRESHOLD = 15;
    const HIGH_RISK_MAX_DAYS = 15;
    const RECENT_INACTIVE_MIN_DAYS = 3;
    const RECENT_INACTIVE_MAX_DAYS = 5;
    const PLAYERS_PER_PAGE = 50;
    const RECOVERY_PLAYERS_PER_PAGE = 50;
    const AUTH_PIN = "8152";

    // Page data with emojis
    const PAGES = [
      { name: "Juwa Slots", emoji: "🎰" },
      { name: "Jackpot Casino", emoji: "💰" },
      { name: "Milk+T", emoji: "🥛" },
      { name: "Spin Royale", emoji: "👑" },
      { name: "Milky Treasure", emoji: "💎" },
      { name: "Legit Spin Casino", emoji: "♠️" },
      { name: "Wealth Casino", emoji: "💵" },
      { name: "Cash Vault", emoji: "🏦" },
      { name: "Game Vault Slots", emoji: "🎮" },
      { name: "Lucky Firekirin", emoji: "🐲" },
      { name: "Payout Day", emoji: "📅" },
      { name: "Ultra Panda", emoji: "🐼" },
      { name: "Dragons Destiny", emoji: "🐉" },
      { name: "Orion Star", emoji: "⭐" },
      { name: "Daily Freebies", emoji: "🎁" },
      { name: "Fortune Valley", emoji: "🏞️" },
      { name: "Grill Girl", emoji: "👧" },
      { name: "Earners Pick", emoji: "📌" },
      { name: "Juwa 2.0", emoji: "🎰" },
      { name: "Panda Master", emoji: "🐼" },
      { name: "Casino Royal", emoji: "♣️" },
      { name: "Diamond Riches", emoji: "💎" },
      { name: "Cash Machine", emoji: "🏧" },
      { name: "Win Star", emoji: "🌟" },
      { name: "Fire Kirin", emoji: "🔥" },
      { name: "Ruby Riches", emoji: "❤️" },
      { name: "Vegas Sweeps", emoji: "🎲" },
      { name: "Secret Spins", emoji: "🕵️" },
      { name: "Mega Money Machine", emoji: "💸" },
      { name: "Mystery Millions", emoji: "❓" },
      { name: "Mafia City", emoji: "🕶️" },
      { name: "VBlink", emoji: "🔗" },
      { name: "Lucky Lady", emoji: "🍀" },
      { name: "King of Pop", emoji: "👑" },
      { name: "Golden Treasure", emoji: "🏆" },
      { name: "River Sweeps", emoji: "🌊" },
      { name: "Game Room", emoji: "🎪" },
      { name: "Oyshee", emoji: "👻" },
      { name: "Moolah", emoji: "💲" },
      { name: "Mega Spin", emoji: "🌀" },
      { name: "Lucky Vegas Slots", emoji: "🎰" },
      { name: "Yolo Slots", emoji: "🔥" },
      { name: "Juwa", emoji: "🎯" },
      { name: "River Monster", emoji: "🐊" },
      { name: "E-Games", emoji: "🎮" },
      { name: "Big Winner", emoji: "🏆" }
    ];

    // Page name normalization mapping
    const PAGE_NAME_MAP = {
      "juwa slots": "Juwa Slots",
      "jackpot casino": "Jackpot Casino", 
      "milk+t": "Milk+T",
      "milk + t": "Milk+T",
      "spin royale": "Spin Royale",
      "milky treasure": "Milky Treasure",
      "legit spin casino": "Legit Spin Casino",
      "wealth casino": "Wealth Casino",
      "cash vault": "Cash Vault",
      "game vault slots": "Game Vault Slots",
      "lucky firekirin": "Lucky Firekirin",
      "payout day": "Payout Day",
      "ultra panda": "Ultra Panda",
      "dragons destiny": "Dragons Destiny",
      "orion star": "Orion Star",
      "daily freebies": "Daily Freebies",
      "fortune valley": "Fortune Valley",
      "grill girl": "Grill Girl",
      "earners pick": "Earners Pick",
      "juwa 2.0": "Juwa 2.0",
      "panda master": "Panda Master",
      "casino royal": "Casino Royal",
      "diamond riches": "Diamond Riches",
      "cash machine": "Cash Machine",
      "win star": "Win Star",
      "fire kirin": "Fire Kirin",
      "ruby riches": "Ruby Riches",
      "vegas sweeps": "Vegas Sweeps",
      "secret spins": "Secret Spins",
      "mega money machine": "Mega Money Machine",
      "mystery millions": "Mystery Millions",
      "mafia city": "Mafia City",
      "vblink": "VBlink",
      "lucky lady": "Lucky Lady",
      "king of pop": "King of Pop",
      "golden treasure": "Golden Treasure",
      "river sweeps": "River Sweeps",
      "game room": "Game Room",
      "oyshee": "Oyshee",
      "moolah": "Moolah",
      "mega spin": "Mega Spin",
      "lucky vegas slots": "Lucky Vegas Slots",
      "yolo slots": "Yolo Slots",
      "juwa": "Juwa",
      "river monster": "River Monster",
      "e-games": "E-Games",
      "e games": "E-Games",
      "egames": "E-Games",
      "big winner": "Big Winner"
    };

    // =============================================
    // CLIENT RECOVERY STATE
    // =============================================
    const recoveryState = {
      current: {
        tab: 'active',
        page: 1,
        search: '',
        data: null,
        stats: null,
        recoveryStatusCache: new Map()
      },
      removed: {
        page: 1,
        search: '',
        data: null
      },
      analytics: {
        data: null
      }
    };

    // =============================================
    // TIME CONVERSION UTILITIES
    // =============================================

    function convertUTCToPKT(utcDateString) {
        if (!utcDateString) return 'N/A';
        
        try {
            const date = new Date(utcDateString);
            if (isNaN(date.getTime())) {
                console.error('Invalid date:', utcDateString);
                return 'Invalid Date';
            }
            
            const pktOffset = 5 * 60 * 60 * 1000;
            const pktDate = new Date(date.getTime() + pktOffset);
            
            const day = String(pktDate.getUTCDate()).padStart(2, '0');
            const month = String(pktDate.getUTCMonth() + 1).padStart(2, '0');
            const year = pktDate.getUTCFullYear();
            
            let hours = pktDate.getUTCHours();
            const minutes = String(pktDate.getUTCMinutes()).padStart(2, '0');
            const seconds = String(pktDate.getUTCSeconds()).padStart(2, '0');
            
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12;
            const hours12 = String(hours).padStart(2, '0');
            
            return `${day}/${month}/${year}, ${hours12}:${minutes}:${seconds} ${ampm}`;
        } catch (error) {
            console.error('Error converting date to PKT:', error, utcDateString);
            return 'Date Error';
        }
    }

    function convertUTCToPKTDateOnly(utcDateString) {
        if (!utcDateString) return 'N/A';
        
        try {
            const date = new Date(utcDateString);
            if (isNaN(date.getTime())) {
                return 'Invalid Date';
            }
            
            const pktOffset = 5 * 60 * 60 * 1000;
            const pktDate = new Date(date.getTime() + pktOffset);
            
            const day = String(pktDate.getUTCDate()).padStart(2, '0');
            const month = String(pktDate.getUTCMonth() + 1).padStart(2, '0');
            const year = pktDate.getUTCFullYear();
            
            return `${day}/${month}/${year}`;
        } catch (error) {
            console.error('Error converting date to PKT:', error);
            return 'Date Error';
        }
    }

    function getCurrentPKT() {
        const now = new Date();
        const pktOffset = 5 * 60 * 60 * 1000;
        return new Date(now.getTime() + pktOffset);
    }

    function formatDateForGrouping(pktDate) {
        if (!pktDate) return '';
        const year = pktDate.getUTCFullYear();
        const month = String(pktDate.getUTCMonth() + 1).padStart(2, '0');
        const day = String(pktDate.getUTCDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    function getStartOfDayPKT(date) {
        const pktDate = new Date(date);
        pktDate.setUTCHours(0, 0, 0, 0);
        return pktDate;
    }

    function formatTimeSince(utcDateString) {
        if (!utcDateString) return 'N/A';
        
        try {
            const nowPKT = getCurrentPKT();
            const lastDepositUTC = new Date(utcDateString);
            const lastDepositPKT = new Date(lastDepositUTC.getTime() + (5 * 60 * 60 * 1000));
            
            if (isNaN(nowPKT.getTime()) || isNaN(lastDepositPKT.getTime())) {
                return 'N/A';
            }
            
            const diffMs = nowPKT - lastDepositPKT;
            
            if (diffMs < 0) {
                return 'Just now';
            }
            
            const hoursSince = Math.floor(diffMs / (1000 * 60 * 60));
            const minutesSince = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const daysSince = Math.floor(hoursSince / 24);
            const remainingHours = hoursSince % 24;
            const remainingMinutes = minutesSince % 60;
            
            if (daysSince === 0) {
                if (hoursSince === 0) {
                    return `${minutesSince} minutes ago`;
                } else {
                    return `${hoursSince} hours ${minutesSince} minutes ago`;
                }
            } else {
                if (remainingHours === 0) {
                    return `${daysSince} day${daysSince > 1 ? 's' : ''} ago`;
                } else {
                    return `${daysSince} day${daysSince > 1 ? 's' : ''} ${remainingHours} hour${remainingHours > 1 ? 's' : ''} ago`;
                }
            }
        } catch (error) {
            console.error('Error calculating time since:', error, utcDateString);
            return 'N/A';
        }
    }

    function calculateExactGapDuration(startDate, endDate) {
        if (!startDate || !endDate) return '—';
        
        try {
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            if (isNaN(start.getTime()) || isNaN(end.getTime())) {
                return '—';
            }
            
            const diffMs = end.getTime() - start.getTime();
            
            if (diffMs <= 0) return '—';
            
            const totalHours = Math.floor(diffMs / (1000 * 60 * 60));
            const totalMinutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const days = Math.floor(totalHours / 24);
            const hours = totalHours % 24;
            
            if (days === 0 && hours === 0 && totalMinutes === 0) {
                return '—';
            }
            
            let gapString = '';
            
            if (days > 0) {
                gapString += `${days} day${days > 1 ? 's' : ''}`;
            }
            
            if (hours > 0) {
                if (gapString) gapString += ' ';
                gapString += `${hours} hour${hours > 1 ? 's' : ''}`;
            }
            
            if (totalMinutes > 0 && days === 0 && hours < 2) {
                if (gapString) gapString += ' ';
                gapString += `${totalMinutes} minute${totalMinutes > 1 ? 's' : ''}`;
            }
            
            return gapString || '—';
        } catch (error) {
            console.error('Error calculating gap duration:', error);
            return '—';
        }
    }

    // =============================================
    // STATE MANAGEMENT
    // =============================================
    let selectedPage = null;
    let currentPageData = null;
    let progressInterval = null;
    let currentView = 'dashboard';
    
    const tableState = {
        current: {
            type: null,
            page: 1,
            data: null,
            title: null
        },
        playerTables: {
            'Total': { page: 1, data: null },
            'Active': { page: 1, data: null },
            'Inactive': { page: 1, data: null },
            'RecentActive': { page: 1, data: null },
            'RecentInactive': { page: 1, data: null }
        },
        highRisk: { page: 1, data: null },
        history: { page: 1, data: null },
        deposits: { month: 0, data: null }
    };
    
    // Notes state
    let currentNotesPlayer = null;
    let currentNotesPlayerName = null;
    let currentNotesButton = null;

    // Navigation context tracking
    let navigationContext = 'landing';
    let currentPageObj = null;

    // Recovery state
    let recoveryPlayerName = null;
    let recoveryPlayerPage = null;
    let selectedRecoveryMethod = null;
    let selectedRemovalReason = null;
    let removalRecordId = null;

    // Performance optimization: Cache for recovery status
    let recoveryStatusCache = new Map();
    let recoveryStatusCacheTimestamp = null;
    const CACHE_TTL = 60000; // 1 minute cache

    // Debouncing for search
    let searchDebounceTimer = null;
    const SEARCH_DEBOUNCE_DELAY = 300;

    // =============================================
    // DOM ELEMENTS
    // =============================================
    const searchInput = document.getElementById('pageSelectSearch');
    const playerSearchInput = document.getElementById('playerSearchInput');
    const pageSuggestions = document.getElementById('pageSuggestions');
    const playerSuggestions = document.getElementById('playerSuggestions');
    const findBtn = document.getElementById('findBtn');
    const loader = document.getElementById('loader');
    const pageTitle = document.getElementById('pageTitle');
    const refreshBtn = document.getElementById('refreshDataBtn');
    const forceCleanupBtn = document.getElementById('forceCleanupBtn');
    const changePageBtn = document.getElementById('changePageBtn');
    const logoutBtnDashboard = document.getElementById('logoutBtnDashboard');
    const loadingProgress = document.getElementById('loadingProgress');
    const refreshModal = document.getElementById('refreshModal');
    const cleanupModal = document.getElementById('cleanupModal');
    const notesModal = document.getElementById('notesModal');
    const refreshPinInput = document.getElementById('refreshPinInput');
    const cleanupPinInput = document.getElementById('cleanupPinInput');
    const noteTextInput = document.getElementById('noteTextInput');
    const saveNoteBtn = document.getElementById('saveNoteBtn');
    const notesModalTitle = document.getElementById('notesModalTitle');
    const notesList = document.getElementById('notesList');
    const statsRow1 = document.getElementById('statsRow1');
    const statsRow2 = document.getElementById('statsRow2');
    const statsRow3 = document.getElementById('statsRow3');
    const pageDepositsView = document.getElementById('pageDepositsView');
    const landingLogoutSection = document.getElementById('landingLogoutSection');
    const logoutBtnLanding = document.getElementById('logoutBtnLanding');
    const clientRecoveryDashboard = document.getElementById('clientRecoveryDashboard');
    const notesViewModal = document.getElementById('notesViewModal');
    const notesViewModalTitle = document.getElementById('notesViewModalTitle');
    const notesViewContent = document.getElementById('notesViewContent');

    // Recovery Modal Elements
    const recoveryModal = document.getElementById('recoveryModal');
    const recoveryModalTitle = document.getElementById('recoveryModalTitle');
    const recoveryPlayerNameInput = document.getElementById('recoveryPlayerName');
    const recoveryPlayerPageInput = document.getElementById('recoveryPlayerPage');
    const recoveryNotesInput = document.getElementById('recoveryNotesInput');
    const confirmRecoveryBtn = document.getElementById('confirmRecoveryBtn');

    // Removal Modal Elements
    const removalModal = document.getElementById('removalModal');
    const removalPlayerName = document.getElementById('removalPlayerName');
    const removalRecoveredDate = document.getElementById('removalRecoveredDate');
    const removalMethod = document.getElementById('removalMethod');
    const removalNotesInput = document.getElementById('removalNotesInput');
    const removalPinInput = document.getElementById('removalPinInput');
    const removalRecordIdInput = document.getElementById('removalRecordId');
    const confirmRemovalBtn = document.getElementById('confirmRemovalBtn');

    // =============================================
    // PERFORMANCE OPTIMIZATION FUNCTIONS
    // =============================================

    // Batch fetch recovery status for all players
    async function batchFetchRecoveryStatus(playerNames) {
      // Check cache validity
      const now = Date.now();
      if (recoveryStatusCacheTimestamp && (now - recoveryStatusCacheTimestamp < CACHE_TTL)) {
        console.log('Using cached recovery status');
        return recoveryStatusCache;
      }
      
      try {
        console.log('Batch fetching recovery status for', playerNames.length, 'players');
        
        const { data, error } = await supabase
          .from('client_recoveries')
          .select('player_name')
          .eq('page_name', selectedPage)
          .eq('is_active_in_list', true)
          .in('player_name', playerNames.length > 0 ? playerNames : ['']);
        
        if (error) {
          console.error('Error batch fetching recovery status:', error);
          return new Map();
        }
        
        // Update cache
        recoveryStatusCache.clear();
        if (data) {
          data.forEach(record => {
            recoveryStatusCache.set(record.player_name, true);
          });
        }
        recoveryStatusCacheTimestamp = now;
        
        console.log('Batch fetch complete. Cached', recoveryStatusCache.size, 'players');
        return recoveryStatusCache;
        
      } catch (error) {
        console.error('Error in batchFetchRecoveryStatus:', error);
        return new Map();
      }
    }

    // Optimized recovery button HTML generation
    async function getRecoveryButtonsHTMLBulk(players) {
      const playerNames = players.map(p => p.player);
      
      // Batch fetch all recovery statuses at once
      const recoveryStatusMap = await batchFetchRecoveryStatus(playerNames);
      
      // Generate HTML for all players using cache
      const buttonHTMLs = players.map(player => {
        const isRecovered = recoveryStatusMap.has(player.player);
        
        if (isRecovered) {
          return `<button class="recovery-btn recovered" disabled>
                    <i class="fas fa-check"></i> Recovered
                  </button>`;
        } else {
          // Check if viewer role - disable mark button for viewer
          if (userRole === PIN_CONFIG.ROLES.VIEWER) {
            return `<button class="recovery-btn mark" disabled style="opacity: 0.5; cursor: not-allowed;" title="Viewer cannot mark recoveries">
                      <i class="fas fa-redo"></i> Mark
                    </button>`;
          } else {
            return `<button class="recovery-btn mark" onclick="showRecoveryModal('${player.player.replace(/'/g, "\\'")}')">
                      <i class="fas fa-redo"></i> Mark
                    </button>`;
          }
        }
      });
      
      return buttonHTMLs;
    }

    // Debounce function for search
    function debounce(func, delay) {
      return function(...args) {
        clearTimeout(searchDebounceTimer);
        searchDebounceTimer = setTimeout(() => func.apply(this, args), delay);
      };
    }

    // =============================================
    // CLIENT RECOVERY FUNCTIONS - FIXED VERSION
    // =============================================

    // Show recovery modal
    function showRecoveryModal(playerName, pageName) {
      // Check if user has permission
      if (userRole === PIN_CONFIG.ROLES.VIEWER) {
        showNotification('Viewer role cannot mark recoveries', 'warning');
        return;
      }
      
      recoveryPlayerName = playerName;
      recoveryPlayerPage = pageName || selectedPage;
      
      recoveryModalTitle.textContent = `Mark ${playerName} as Recovered`;
      recoveryPlayerNameInput.value = playerName;
      recoveryPlayerPageInput.value = recoveryPlayerPage;
      recoveryNotesInput.value = '';
      
      // Reset method selection
      selectedRecoveryMethod = null;
      document.querySelectorAll('.recovery-method-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      recoveryModal.style.display = 'block';
      recoveryNotesInput.focus();
    }

    // Hide recovery modal
    function hideRecoveryModal() {
      recoveryModal.style.display = 'none';
      recoveryPlayerName = null;
      recoveryPlayerPage = null;
      selectedRecoveryMethod = null;
      recoveryNotesInput.value = '';
    }

    // Select recovery method
    function selectRecoveryMethod(method) {
      selectedRecoveryMethod = method;
      
      document.querySelectorAll('.recovery-method-btn').forEach(btn => {
        if (btn.dataset.method === method) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
    }

    // Confirm recovery - FIXED WITH REAL-TIME BUTTON UPDATE
    async function confirmRecovery() {
      if (!selectedRecoveryMethod) {
        showNotification('Please select a recovery method (Chat or Offer)', 'error');
        return;
      }
      
      const recoveryNotes = recoveryNotesInput.value.trim();
      
      // FIXED: Store player name in local variable before async operations
      const playerNameToRecover = recoveryPlayerName;
      const pageNameToRecover = recoveryPlayerPage;
      
      console.log(`Starting recovery for player: ${playerNameToRecover} on page: ${pageNameToRecover}`);
      
      confirmRecoveryBtn.disabled = true;
      confirmRecoveryBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
      
      try {
        const { data, error } = await supabase
          .from('client_recoveries')
          .insert([
            {
              page_name: pageNameToRecover,
              player_name: playerNameToRecover,
              recovery_method: selectedRecoveryMethod,
              recovery_notes: recoveryNotes || null,
              added_by: userRole,
              recovered_date: new Date().toISOString(),
              is_active_in_list: true,
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            }
          ])
          .select();
        
        if (error) throw error;
        
        showNotification(`Player ${playerNameToRecover} marked as recovered via ${selectedRecoveryMethod === 'chat' ? 'Chat' : 'Offer'}`, 'success');
        
        // Update recovery cache
        recoveryStatusCache.set(playerNameToRecover, true);
        
        // REAL-TIME UPDATE: Update recovery button in all tables - FIXED VERSION
        // Use the local variable, not the global one
        updateRecoveryButtonInTables(playerNameToRecover, true);
        
        // Hide modal AFTER updating buttons
        hideRecoveryModal();
        
        // If we're in recovery dashboard, refresh it
        if (currentView === 'clientRecovery') {
          await loadRecoveryData();
        }
        
        // Update recovery stats in dashboard
        await updateRecoveryStats();
        
        // Update dashboard stats
        await updateDashboardRecoveryCount();
        
      } catch (error) {
        console.error('Error marking player as recovered:', error);
        showNotification('Error marking player as recovered: ' + error.message, 'error');
      } finally {
        confirmRecoveryBtn.disabled = false;
        confirmRecoveryBtn.innerHTML = '<i class="fas fa-check"></i> Mark as Recovered';
      }
    }

    // Update recovery button in all tables - FIXED VERSION
    function updateRecoveryButtonInTables(playerName, isRecovered) {
      console.log(`Updating recovery button for player: ${playerName}, isRecovered: ${isRecovered}`);
      
      // Find all recovery buttons in the document
      const allButtons = document.querySelectorAll('.recovery-btn');
      
      allButtons.forEach(btn => {
        // Get the parent row
        const row = btn.closest('tr');
        if (!row) return;
        
        // Get the player name from the row (2nd column in most tables)
        const playerCell = row.querySelector('td:nth-child(2)');
        if (!playerCell) return;
        
        const rowPlayerName = playerCell.textContent.trim();
        
        if (rowPlayerName === playerName) {
          console.log(`Found button for ${playerName} in row`, row);
          
          if (isRecovered) {
            // Change to recovered state
            btn.innerHTML = '<i class="fas fa-check"></i> Recovered';
            btn.className = 'recovery-btn recovered';
            btn.disabled = true;
            btn.onclick = null;
            console.log(`Button updated to Recovered for ${playerName}`);
          } else {
            // Change to mark state (with proper viewer check)
            if (userRole === PIN_CONFIG.ROLES.VIEWER) {
              btn.innerHTML = '<i class="fas fa-redo"></i> Mark';
              btn.className = 'recovery-btn mark';
              btn.disabled = true;
              btn.style.opacity = '0.5';
              btn.style.cursor = 'not-allowed';
              btn.title = 'Viewer cannot mark recoveries';
              btn.onclick = null;
            } else {
              btn.innerHTML = '<i class="fas fa-redo"></i> Mark';
              btn.className = 'recovery-btn mark';
              btn.disabled = false;
              btn.style.opacity = '';
              btn.style.cursor = '';
              btn.title = '';
              btn.onclick = function() { showRecoveryModal(playerName); };
            }
            console.log(`Button updated to Mark for ${playerName}`);
          }
        }
      });
      
      // Also update buttons in high risk table (different column index)
      const highRiskButtons = document.querySelectorAll('.high-risk-table .recovery-btn');
      highRiskButtons.forEach(btn => {
        const row = btn.closest('tr');
        if (!row) return;
        
        // High risk table has player in 3rd column
        const playerCell = row.querySelector('td:nth-child(3)');
        if (!playerCell) return;
        
        const rowPlayerName = playerCell.textContent.trim();
        
        if (rowPlayerName === playerName) {
          if (isRecovered) {
            btn.innerHTML = '<i class="fas fa-check"></i> Recovered';
            btn.className = 'recovery-btn recovered';
            btn.disabled = true;
            btn.onclick = null;
          } else {
            if (userRole === PIN_CONFIG.ROLES.VIEWER) {
              btn.innerHTML = '<i class="fas fa-redo"></i> Mark';
              btn.className = 'recovery-btn mark';
              btn.disabled = true;
              btn.style.opacity = '0.5';
              btn.style.cursor = 'not-allowed';
              btn.title = 'Viewer cannot mark recoveries';
              btn.onclick = null;
            } else {
              btn.innerHTML = '<i class="fas fa-redo"></i> Mark';
              btn.className = 'recovery-btn mark';
              btn.disabled = false;
              btn.style.opacity = '';
              btn.style.cursor = '';
              btn.title = '';
              btn.onclick = function() { showRecoveryModal(playerName); };
            }
          }
        }
      });
      
      console.log(`Finished updating buttons for ${playerName}`);
    }

    // Update dashboard recovery count
    async function updateDashboardRecoveryCount() {
      try {
        const { data, error } = await supabase
          .from('client_recoveries')
          .select('id')
          .eq('page_name', selectedPage)
          .eq('is_active_in_list', true);
        
        if (error) throw error;
        
        const count = data ? data.length : 0;
        
        // Update the recovery button in dashboard
        const recoveryButton = document.querySelector('.stat-card.recovery .stat-value');
        if (recoveryButton) {
          recoveryButton.textContent = count;
        }
        
      } catch (error) {
        console.error('Error updating recovery count:', error);
      }
    }

    // Show notes view modal
    function showNotesViewModal(title, content) {
      notesViewModalTitle.textContent = title;
      notesViewContent.innerHTML = `<div class="notes-display">${content || 'No notes available.'}</div>`;
      notesViewModal.style.display = 'block';
    }

    // Hide notes view modal
    function hideNotesViewModal() {
      notesViewModal.style.display = 'none';
    }

    // Show removal modal
    function showRemovalModal(recordId, playerName, recoveredDate, method) {
      // Check if viewer role
      if (userRole === PIN_CONFIG.ROLES.VIEWER) {
        showNotification('Viewer role cannot remove recovered clients', 'warning');
        return;
      }
      
      removalRecordId = recordId;
      
      removalPlayerName.textContent = playerName;
      // FIXED: Use convertUTCToPKT instead of convertUTCToPKTDateOnly for date AND time
      removalRecoveredDate.textContent = convertUTCToPKT(recoveredDate);
      removalMethod.textContent = method === 'chat' ? 'Chat' : 'Offer';
      removalRecordIdInput.value = recordId;
      removalNotesInput.value = '';
      removalPinInput.value = '';
      
      removalModal.style.display = 'block';
      removalPinInput.focus();
    }

    // Hide removal modal
    function hideRemovalModal() {
      removalModal.style.display = 'none';
      removalRecordId = null;
      selectedRemovalReason = null;
      removalNotesInput.value = '';
      removalPinInput.value = '';
    }

    // Confirm removal - UPDATED ERROR MESSAGE
    async function confirmRemoval() {
      const pin = removalPinInput.value.trim();
      if (pin !== RECOVERY_REMOVAL_PIN) {
        showNotification('Invalid PIN. Please try again.', 'error');
        return;
      }
      
      const removalNotes = removalNotesInput.value.trim();
      
      confirmRemovalBtn.disabled = true;
      confirmRemovalBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Removing...';
      
      try {
        const { data, error } = await supabase
          .from('client_recoveries')
          .update({
            is_active_in_list: false,
            removed_date: new Date().toISOString(),
            removed_by: userRole,
            removal_reason: 'user_removed',
            removal_notes: removalNotes || null,
            removal_pin_used: '81**',
            updated_at: new Date().toISOString()
          })
          .eq('id', removalRecordId)
          .eq('is_active_in_list', true)
          .select();
        
        if (error) throw error;
        
        if (data && data.length > 0) {
          showNotification('Player removed from recovery list', 'success');
          
          hideRemovalModal();
          
          // Update recovery cache
          const playerName = removalPlayerName.textContent;
          recoveryStatusCache.delete(playerName);
          
          // Update recovery button in all tables
          updateRecoveryButtonInTables(playerName, false);
          
          // Refresh recovery dashboard
          if (currentView === 'clientRecovery') {
            await loadRecoveryData();
          }
          
          // Update recovery stats in dashboard
          await updateRecoveryStats();
          
          // Update dashboard recovery count
          await updateDashboardRecoveryCount();
          
        } else {
          showNotification('Record not found or already removed', 'warning');
        }
        
      } catch (error) {
        console.error('Error removing from recovery list:', error);
        showNotification('Error removing player: ' + error.message, 'error');
      } finally {
        confirmRemovalBtn.disabled = false;
        confirmRemovalBtn.innerHTML = '<i class="fas fa-trash"></i> Confirm Removal';
      }
    }

    // Load recovery data
    async function loadRecoveryData() {
      try {
        // Get active recoveries
        const { data: activeData, error: activeError } = await supabase
          .from('client_recoveries')
          .select('*')
          .eq('page_name', selectedPage)
          .eq('is_active_in_list', true)
          .order('recovered_date', { ascending: false });
        
        if (activeError) throw activeError;
        
        // Get player status for each recovery
        const recoveriesWithStatus = await Promise.all(
          (activeData || []).map(async (recovery) => {
            const { data: playerData } = await supabase
              .from('latest_status')
              .select('last_deposit_date, status')
              .eq('page_name', selectedPage)
              .eq('player_name', recovery.player_name)
              .single();
            
            return {
              ...recovery,
              current_status: playerData?.status || 'inactive',
              last_deposit: playerData?.last_deposit_date,
              last_deposit_display: formatTimeSince(playerData?.last_deposit_date)
            };
          })
        );
        
        // Get removed recoveries
        const { data: removedData, error: removedError } = await supabase
          .from('client_recoveries')
          .select('*')
          .eq('page_name', selectedPage)
          .eq('is_active_in_list', false)
          .order('removed_date', { ascending: false });
        
        if (removedError) throw removedError;
        
        // Get analytics
        const activeCount = recoveriesWithStatus.length;
        const activeActiveCount = recoveriesWithStatus.filter(r => r.current_status === 'Active').length;
        const chatRecoveries = recoveriesWithStatus.filter(r => r.recovery_method === 'chat');
        const offerRecoveries = recoveriesWithStatus.filter(r => r.recovery_method === 'offer');
        
        const chatSuccessRate = chatRecoveries.length > 0 
          ? Math.round((chatRecoveries.filter(r => r.current_status === 'Active').length / chatRecoveries.length) * 100)
          : 0;
        
        const offerSuccessRate = offerRecoveries.length > 0
          ? Math.round((offerRecoveries.filter(r => r.current_status === 'Active').length / offerRecoveries.length) * 100)
          : 0;
        
        const overallSuccessRate = activeCount > 0
          ? Math.round((activeActiveCount / activeCount) * 100)
          : 0;
        
        recoveryState.current.data = recoveriesWithStatus;
        recoveryState.removed.data = removedData || [];
        recoveryState.analytics.data = {
          total_recovered: activeCount,
          currently_active: activeActiveCount,
          currently_inactive: activeCount - activeActiveCount,
          chat_success_rate: chatSuccessRate,
          offer_success_rate: offerSuccessRate,
          overall_success_rate: overallSuccessRate
        };
        
        // Update recovery stats in dashboard
        await updateRecoveryStats();
        
        // Render recovery dashboard
        renderRecoveryDashboard();
        
      } catch (error) {
        console.error('Error loading recovery data:', error);
        showNotification('Error loading recovery data: ' + error.message, 'error');
      }
    }

    // Update recovery stats in dashboard
    async function updateRecoveryStats() {
      try {
        const { data, error } = await supabase
          .from('client_recoveries')
          .select('id')
          .eq('page_name', selectedPage)
          .eq('is_active_in_list', true);
        
        if (error) throw error;
        
        const count = data ? data.length : 0;
        
        // Update the recovery button in dashboard
        const recoveryButton = document.querySelector('.stat-card.recovery .stat-value');
        if (recoveryButton) {
          recoveryButton.textContent = count;
        }
        
        // Update recovery stats
        if (recoveryState.current.data) {
          const activeCount = recoveryState.current.data.length;
          const activeActiveCount = recoveryState.current.data.filter(r => r.current_status === 'Active').length;
          
          recoveryState.current.stats = {
            total: activeCount,
            active: activeActiveCount,
            inactive: activeCount - activeActiveCount
          };
        }
        
      } catch (error) {
        console.error('Error updating recovery stats:', error);
      }
    }

    // Render recovery dashboard - FIXED VERSION
    function renderRecoveryDashboard() {
      const stats = recoveryState.current.stats || { total: 0, active: 0, inactive: 0 };
      const analytics = recoveryState.analytics.data || {
        total_recovered: 0,
        currently_active: 0,
        currently_inactive: 0,
        chat_success_rate: 0,
        offer_success_rate: 0,
        overall_success_rate: 0
      };
      
      let html = `
        <div class="recovery-dashboard">
          <div class="recovery-tabs">
            <button class="recovery-tab ${recoveryState.current.tab === 'active' ? 'active' : ''}" onclick="switchRecoveryTab('active')">
              Active Recoveries
            </button>
            <button class="recovery-tab ${recoveryState.current.tab === 'removed' ? 'active' : ''}" onclick="switchRecoveryTab('removed')">
              Removed Clients
            </button>
            <button class="recovery-tab ${recoveryState.current.tab === 'analytics' ? 'active' : ''}" onclick="switchRecoveryTab('analytics')">
              Analytics
            </button>
          </div>
          
          <div class="recovery-content">
      `;
      
      if (recoveryState.current.tab === 'active') {
        html += renderActiveRecoveries();
      } else if (recoveryState.current.tab === 'removed') {
        html += renderRemovedClients();
      } else if (recoveryState.current.tab === 'analytics') {
        html += renderAnalytics();
      }
      
      // ADD BACK BUTTON
      html += `
          </div>
        </div>
        <div style="margin-top: 2rem; display: flex; justify-content: center;">
          <button class="btn btn-secondary" onclick="backToDashboard()">
            <i class="fas fa-arrow-left"></i> Back to Dashboard
          </button>
        </div>
      `;
      
      clientRecoveryDashboard.innerHTML = html;
      clientRecoveryDashboard.style.display = 'block';
      
      // Apply viewer restrictions after rendering
      if (userRole === PIN_CONFIG.ROLES.VIEWER) {
        disableAllMarkButtons();
      }
    }

    // Render active recoveries - FIXED VERSION WITH UPDATED STYLING
    function renderActiveRecoveries() {
      const recoveries = recoveryState.current.data || [];
      const stats = recoveryState.current.stats || { total: 0, active: 0, inactive: 0 };
      
      // Apply search filter
      let filteredRecoveries = recoveries;
      if (recoveryState.current.search) {
        const searchTerm = recoveryState.current.search.toLowerCase();
        filteredRecoveries = recoveries.filter(r => 
          r.player_name.toLowerCase().includes(searchTerm) ||
          (r.recovery_notes && r.recovery_notes.toLowerCase().includes(searchTerm)) ||
          r.recovery_method.toLowerCase().includes(searchTerm)
        );
      }
      
      // Pagination
      const totalPages = Math.ceil(filteredRecoveries.length / RECOVERY_PLAYERS_PER_PAGE);
      const currentPage = recoveryState.current.page;
      const startIndex = (currentPage - 1) * RECOVERY_PLAYERS_PER_PAGE;
      const endIndex = Math.min(startIndex + RECOVERY_PLAYERS_PER_PAGE, filteredRecoveries.length);
      const paginatedRecoveries = filteredRecoveries.slice(startIndex, endIndex);
      
      let html = `
        <div class="recovery-search-container">
          <input 
            type="text" 
            class="search-input" 
            placeholder="Search recovered players..." 
            value="${recoveryState.current.search}"
            oninput="debouncedSearchRecoveries(this.value, 'active')"
            style="width: 100%;"
          >
        </div>
        
        <div class="recovery-stats">
          <div class="recovery-stat">
            <div class="recovery-stat-value">${stats.total}</div>
            <div class="recovery-stat-label">Total Recovered</div>
          </div>
          <div class="recovery-stat">
            <div class="recovery-stat-value" style="color: var(--success);">${stats.active}</div>
            <div class="recovery-stat-label">Currently Active</div>
          </div>
          <div class="recovery-stat">
            <div class="recovery-stat-value" style="color: var(--danger);">${stats.inactive}</div>
            <div class="recovery-stat-label">Became Inactive</div>
          </div>
          <div class="recovery-stat">
            <div class="recovery-stat-value">${filteredRecoveries.length}</div>
            <div class="recovery-stat-label">Showing</div>
          </div>
        </div>
        
        <div class="recovery-table-container">
          <table class="recovery-table">
            <thead>
              <tr>
                <th style="width: 50px; text-align: center;">#</th>
                <th style="width: 150px;">Date & Time</th>
                <th style="width: 120px;">Player Name</th>
                <th style="width: 100px;">Method</th>
                <th style="width: 100px;">Current Status</th>
                <th style="width: 120px;">Last Deposit</th>
                <th style="width: 150px;">Recovery Notes</th>
                <th style="width: 80px; text-align: center;">Actions</th>
              </tr>
            </thead>
            <tbody>
      `;
      
      if (paginatedRecoveries.length === 0) {
        html += `
          <tr>
            <td colspan="8" style="text-align: center; padding: 2rem; color: var(--text-secondary);">
              ${recoveryState.current.search ? 'No matching recovered players found' : 'No recovered players yet'}
            </td>
          </tr>
        `;
      } else {
        paginatedRecoveries.forEach((recovery, index) => {
          const serialNumber = startIndex + index + 1;
          // FIXED: Use convertUTCToPKT instead of convertUTCToPKTDateOnly for date AND time
          const recoveredDate = convertUTCToPKT(recovery.recovered_date);
          const methodClass = recovery.recovery_method === 'chat' ? 'method-chat' : 'method-offer';
          const methodText = recovery.recovery_method === 'chat' ? 'Chat' : 'Offer';
          const statusClass = recovery.current_status === 'Active' ? 'status-active' : 'status-inactive';
          const statusText = recovery.current_status === 'Active' ? 'Active' : 'Inactive';
          const statusIcon = recovery.current_status === 'Active' ? '✅' : '❌';
          
          // Determine notes display
          let notesDisplay = '-';
          if (recovery.recovery_notes && recovery.recovery_notes.trim() !== '') {
            notesDisplay = `
              <button class="view-notes-btn" onclick="showNotesViewModal('Notes for ${recovery.player_name}', '${recovery.recovery_notes.replace(/'/g, "\\'").replace(/\n/g, '<br>')}')">
                <i class="fas fa-eye"></i> View Notes
              </button>
            `;
          }
          
          // Remove button - disabled for viewer role
          const removeButton = userRole === PIN_CONFIG.ROLES.VIEWER 
            ? `<button class="removal-btn disabled" disabled title="Viewer cannot remove">
                <i class="fas fa-times"></i> Remove
              </button>`
            : `<button class="removal-btn" onclick="showRemovalModal('${recovery.id}', '${recovery.player_name}', '${recovery.recovered_date}', '${recovery.recovery_method}')">
                <i class="fas fa-times"></i> Remove
              </button>`;
          
          html += `
            <tr>
              <td style="text-align: center;">${serialNumber}</td>
              <td>${recoveredDate}</td>
              <td><strong>${recovery.player_name}</strong></td>
              <td class="${methodClass}"><strong>${methodText}</strong></td>
              <td><span class="${statusClass}">${statusIcon} ${statusText}</span></td>
              <td>${recovery.last_deposit_display || 'N/A'}</td>
              <td>${notesDisplay}</td>
              <td style="text-align: center;">
                ${removeButton}
              </td>
            </tr>
          `;
        });
      }
      
      html += `
            </tbody>
          </table>
        </div>
      `;
      
      // Add pagination if needed
      if (totalPages > 1) {
        html += `
          <div style="padding: 1rem; border-top: 1px solid var(--border-color); display: flex; justify-content: center; align-items: center; gap: 1rem;">
            <button class="pagination-btn" ${currentPage === 1 ? 'disabled' : ''} onclick="changeRecoveryPage(${currentPage - 1})">
              <i class="fas fa-chevron-left"></i> Previous
            </button>
            <span class="pagination-info">
              Page ${currentPage} of ${totalPages} (${filteredRecoveries.length} players)
            </span>
            <button class="pagination-btn" ${currentPage === totalPages ? 'disabled' : ''} onclick="changeRecoveryPage(${currentPage + 1})">
              Next <i class="fas fa-chevron-right"></i>
            </button>
          </div>
        `;
      }
      
      return html;
    }

    // Render removed clients - FIXED VERSION WITH UPDATED STYLING
    function renderRemovedClients() {
      const removed = recoveryState.removed.data || [];
      
      // Apply search filter
      let filteredRemoved = removed;
      if (recoveryState.removed.search) {
        const searchTerm = recoveryState.removed.search.toLowerCase();
        filteredRemoved = removed.filter(r => 
          r.player_name.toLowerCase().includes(searchTerm) ||
          (r.removal_notes && r.removal_notes.toLowerCase().includes(searchTerm)) ||
          (r.removal_reason && r.removal_reason.toLowerCase().includes(searchTerm))
        );
      }
      
      // Pagination
      const totalPages = Math.ceil(filteredRemoved.length / RECOVERY_PLAYERS_PER_PAGE);
      const currentPage = recoveryState.removed.page;
      const startIndex = (currentPage - 1) * RECOVERY_PLAYERS_PER_PAGE;
      const endIndex = Math.min(startIndex + RECOVERY_PLAYERS_PER_PAGE, filteredRemoved.length);
      const paginatedRemoved = filteredRemoved.slice(startIndex, endIndex);
      
      let html = `
        <div class="recovery-search-container">
          <input 
            type="text" 
            class="search-input" 
            placeholder="Search removed clients..." 
            value="${recoveryState.removed.search}"
            oninput="debouncedSearchRecoveries(this.value, 'removed')"
            style="width: 100%;"
          >
        </div>
        
        <div class="recovery-stats">
          <div class="recovery-stat">
            <div class="recovery-stat-value">${removed.length}</div>
            <div class="recovery-stat-label">Total Removed</div>
          </div>
          <div class="recovery-stat">
            <div class="recovery-stat-value">${filteredRemoved.length}</div>
            <div class="recovery-stat-label">Showing</div>
          </div>
        </div>
        
        <div class="recovery-table-container">
          <table class="recovery-table">
            <thead>
              <tr>
                <th style="width: 50px; text-align: center;">#</th>
                <th style="width: 120px;">Player Name</th>
                <th style="width: 150px;">Added Date & Time</th>
                <th style="width: 150px;">Removed Date & Time</th>
                <th style="width: 100px;">Method</th>
                <th style="width: 120px;">Removal Reason</th>
                <th style="width: 150px;">Removal Notes</th>
              </tr>
            </thead>
            <tbody>
      `;
      
      if (paginatedRemoved.length === 0) {
        html += `
          <tr>
            <td colspan="7" style="text-align: center; padding: 2rem; color: var(--text-secondary);">
              ${recoveryState.removed.search ? 'No matching removed clients found' : 'No removed clients yet'}
            </td>
          </tr>
        `;
      } else {
        paginatedRemoved.forEach((record, index) => {
          const serialNumber = startIndex + index + 1;
          const methodClass = record.recovery_method === 'chat' ? 'method-chat' : 'method-offer';
          const methodText = record.recovery_method === 'chat' ? 'Chat' : 'Offer';
          
          // FIXED: Use convertUTCToPKT instead of convertUTCToPKTDateOnly for date AND time
          const addedDate = convertUTCToPKT(record.recovered_date);
          const removedDate = record.removed_date ? convertUTCToPKT(record.removed_date) : '-';
          
          // Determine notes display
          let notesDisplay = '-';
          if (record.removal_notes && record.removal_notes.trim() !== '') {
            notesDisplay = `
              <button class="view-notes-btn" onclick="showNotesViewModal('Removal Notes for ${record.player_name}', '${record.removal_notes.replace(/'/g, "\\'").replace(/\n/g, '<br>')}')">
                <i class="fas fa-eye"></i> View Notes
              </button>
            `;
          }
          
          html += `
            <tr>
              <td style="text-align: center;">${serialNumber}</td>
              <td><strong>${record.player_name}</strong></td>
              <td>${addedDate}</td>
              <td>${removedDate}</td>
              <td class="${methodClass}"><strong>${methodText}</strong></td>
              <td>${record.removal_reason ? record.removal_reason.charAt(0).toUpperCase() + record.removal_reason.slice(1).replace('-', ' ') : 'User removed'}</td>
              <td>${notesDisplay}</td>
            </tr>
          `;
        });
      }
      
      html += `
            </tbody>
          </table>
        </div>
      `;
      
      // Add pagination if needed
      if (totalPages > 1) {
        html += `
          <div style="padding: 1rem; border-top: 1px solid var(--border-color); display: flex; justify-content: center; align-items: center; gap: 1rem;">
            <button class="pagination-btn" ${currentPage === 1 ? 'disabled' : ''} onclick="changeRemovedPage(${currentPage - 1})">
              <i class="fas fa-chevron-left"></i> Previous
            </button>
            <span class="pagination-info">
              Page ${currentPage} of ${totalPages} (${filteredRemoved.length} players)
            </span>
            <button class="pagination-btn" ${currentPage === totalPages ? 'disabled' : ''} onclick="changeRemovedPage(${currentPage + 1})">
              Next <i class="fas fa-chevron-right"></i>
            </button>
          </div>
        `;
      }
      
      return html;
    }

    // Render analytics - FIXED VERSION WITH 2 ROWS
    function renderAnalytics() {
      const analytics = recoveryState.analytics.data || {
        total_recovered: 0,
        currently_active: 0,
        currently_inactive: 0,
        chat_success_rate: 0,
        offer_success_rate: 0,
        overall_success_rate: 0
      };
      
      let html = `
        <div class="analytics-panel">
          <div class="analytics-stats">
            <div class="analytic-card">
              <div class="analytic-value">${analytics.overall_success_rate}%</div>
              <div class="analytic-label">Overall Success Rate</div>
            </div>
            <div class="analytic-card">
              <div class="analytic-value">${analytics.chat_success_rate}%</div>
              <div class="analytic-label">Chat Success</div>
            </div>
            <div class="analytic-card">
              <div class="analytic-value">${analytics.offer_success_rate}%</div>
              <div class="analytic-label">Offer Success</div>
            </div>
          </div>
          
          <div class="analytics-stats-row2">
            <div class="analytic-card">
              <div class="analytic-value">${analytics.total_recovered}</div>
              <div class="analytic-label">Total Recovered</div>
            </div>
            <div class="analytic-card">
              <div class="analytic-value" style="color: var(--success);">${analytics.currently_active}</div>
              <div class="analytic-label">Currently Active</div>
            </div>
            <div class="analytic-card">
              <div class="analytic-value" style="color: var(--danger);">${analytics.currently_inactive}</div>
              <div class="analytic-label">Became Inactive</div>
            </div>
          </div>
          
          <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 12px; margin-top: 2rem; border: 1px solid var(--border-color);">
            <h4 style="color: var(--text-primary); margin-bottom: 1rem;">Recovery Analytics Summary</h4>
            <div style="color: var(--text-secondary); line-height: 1.6;">
              <p>• Out of <strong>${analytics.total_recovered}</strong> recovered players, <strong style="color: var(--success);">${analytics.currently_active}</strong> are still active and <strong style="color: var(--danger);">${analytics.currently_inactive}</strong> have become inactive again.</p>
              <p>• <strong>Chat recoveries</strong> have a <strong>${analytics.chat_success_rate}%</strong> success rate.</p>
              <p>• <strong>Offer recoveries</strong> have a <strong>${analytics.offer_success_rate}%</strong> success rate.</p>
              <p>• The overall recovery success rate is <strong>${analytics.overall_success_rate}%</strong>.</p>
            </div>
          </div>
        </div>
      `;
      
      return html;
    }

    // Switch recovery tab
    function switchRecoveryTab(tab) {
      recoveryState.current.tab = tab;
      renderRecoveryDashboard();
    }

    // Debounced search function
    const debouncedSearchRecoveries = debounce(function(searchTerm, tab) {
      searchRecoveries(searchTerm, tab);
    }, SEARCH_DEBOUNCE_DELAY);

    // Search recoveries
    function searchRecoveries(searchTerm, tab) {
      if (tab === 'active') {
        recoveryState.current.search = searchTerm;
        recoveryState.current.page = 1;
      } else if (tab === 'removed') {
        recoveryState.removed.search = searchTerm;
        recoveryState.removed.page = 1;
      }
      renderRecoveryDashboard();
    }

    // Change recovery page
    function changeRecoveryPage(page) {
      if (page < 1) return;
      const totalPages = Math.ceil((recoveryState.current.data?.length || 0) / RECOVERY_PLAYERS_PER_PAGE);
      if (page > totalPages) return;
      
      recoveryState.current.page = page;
      renderRecoveryDashboard();
    }

    // Change removed page
    function changeRemovedPage(page) {
      if (page < 1) return;
      const totalPages = Math.ceil((recoveryState.removed.data?.length || 0) / RECOVERY_PLAYERS_PER_PAGE);
      if (page > totalPages) return;
      
      recoveryState.removed.page = page;
      renderRecoveryDashboard();
    }

    // =============================================
    // EXISTING FUNCTIONS (Updated for Performance)
    // =============================================

    // Initialize on load
    document.addEventListener('DOMContentLoaded', function() {
      initializeApp();
    });

    function initializeApp() {
      initPinSystem();
      setupLogoutButton();
      
      // Initialize debounced search
      window.debouncedSearchRecoveries = debouncedSearchRecoveries;
      window.showNotesViewModal = showNotesViewModal;
    }

    function showLandingPage() {
      clearAllSearchInputs();
      clearPlayerHistory();
      
      sessionStorage.removeItem('currentPage');
      sessionStorage.removeItem('currentView');
      
      navigationContext = 'landing';
      
      document.getElementById('dashboard').style.display = 'none';
      document.getElementById('landing').style.display = 'flex';
      
      const isAuthenticated = sessionStorage.getItem('pinAuthenticated') === 'true';
      
      if (landingLogoutSection) {
        landingLogoutSection.style.display = isAuthenticated ? 'block' : 'none';
      }
      
      if (logoutBtnLanding) {
        logoutBtnLanding.disabled = false;
      }
      
      currentView = 'landing';
    }

    async function loadDashboard(pageObj) {
      selectedPage = pageObj.name;
      currentPageObj = pageObj;
      sessionStorage.setItem('currentPage', selectedPage);
      sessionStorage.setItem('currentView', 'dashboard');
      
      navigationContext = 'dashboard';
      
      clearPlayerHistory();
      
      document.getElementById('landing').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      
      if (logoutBtnDashboard) {
        logoutBtnDashboard.style.display = 'inline-flex';
      }
      
      updatePageTitle();
      
      showLoader();
      disableControlButtons();
      
      // Clear cache when loading new page
      recoveryStatusCache.clear();
      recoveryStatusCacheTimestamp = null;
      
      await loadDashboardData();
    }

    function updatePageTitle() {
      if (currentPageObj) {
        pageTitle.textContent = `${currentPageObj.name} ${currentPageObj.emoji} - Analytics Dashboard`;
      } else if (selectedPage) {
        const pageObj = PAGES.find(p => p.name === selectedPage);
        if (pageObj) {
          currentPageObj = pageObj;
          pageTitle.textContent = `${pageObj.name} ${pageObj.emoji} - Analytics Dashboard`;
        } else {
          pageTitle.textContent = `${selectedPage} - Analytics Dashboard`;
        }
      }
    }

    async function loadDashboardData() {
      if (!selectedPage) return;
      
      showLoader();
      clearBackContainer();
      disableControlButtons();
      
      try {
        const data = await getPageActivity(selectedPage);
        handleDashboardData(data);
        
        // Load recovery stats
        await updateRecoveryStats();
      } catch (error) {
        handleDataError(error);
      }
    }

    function handleDashboardData(data) {
      hideLoader();
      currentPageData = data;
      renderDashboard(data);
      currentView = 'dashboard';
      sessionStorage.setItem('currentView', 'dashboard');
      enableControlButtons();
    }

    function handleDataError(error) {
      hideLoader();
      showNotification('Error loading data: ' + error, 'error');
      document.getElementById('dashboard').style.display = 'block';
      enableControlButtons();
    }

    function showLoader() {
      loader.style.display = 'block';
      document.getElementById('dashboardBoxes').style.display = 'none';
      document.getElementById('tableContainer').innerHTML = '';
      document.getElementById('playerHistorySection').style.display = 'none';
      document.getElementById('globalPlayerHistorySection').style.display = 'none';
      document.getElementById('backContainer').innerHTML = '';
      pageDepositsView.style.display = 'none';
      clientRecoveryDashboard.style.display = 'none';
    }

    function hideLoader() {
      loader.style.display = 'none';
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
    }

    function disableControlButtons() {
      changePageBtn.disabled = true;
      refreshBtn.disabled = true;
      forceCleanupBtn.disabled = true;
      if (logoutBtnDashboard) logoutBtnDashboard.disabled = true;
      if (logoutBtnLanding) logoutBtnLanding.disabled = true;
    }

    function enableControlButtons() {
      changePageBtn.disabled = false;
      refreshBtn.disabled = false;
      forceCleanupBtn.disabled = false;
      if (logoutBtnDashboard) logoutBtnDashboard.disabled = false;
      if (logoutBtnLanding) logoutBtnLanding.disabled = false;
    }

    function clearBackContainer() {
      document.getElementById('backContainer').innerHTML = '';
    }

    function clearPlayerHistory() {
      const playerSearchInput = document.getElementById('playerSearch');
      const playerHistoryContainer = document.getElementById('playerHistoryContainer');
      const globalPlayerHistoryContainer = document.getElementById('globalPlayerHistoryContainer');
      
      if (playerSearchInput) playerSearchInput.value = '';
      if (playerHistoryContainer) playerHistoryContainer.innerHTML = '';
      if (globalPlayerHistoryContainer) globalPlayerHistoryContainer.innerHTML = '';
    }

    function clearAllSearchInputs() {
      const playerSearchInput = document.getElementById('playerSearch');
      const playerSearchLanding = document.getElementById('playerSearchInput');
      const pageSearchInput = document.getElementById('pageSelectSearch');
      
      if (playerSearchInput) playerSearchInput.value = '';
      if (playerSearchLanding) playerSearchLanding.value = '';
      if (pageSearchInput) pageSearchInput.value = '';
      
      const pageSuggestions = document.getElementById('pageSuggestions');
      const playerSuggestions = document.getElementById('playerSuggestions');
      
      if (pageSuggestions) pageSuggestions.innerHTML = '';
      if (playerSuggestions) playerSuggestions.innerHTML = '';
      
      const findBtn = document.getElementById('findBtn');
      if (findBtn) findBtn.style.display = 'none';
    }

    // Page search functionality
    searchInput.addEventListener('input', function() {
      const val = this.value.toLowerCase().trim();
      pageSuggestions.innerHTML = '';
      findBtn.style.display = 'none';
      
      if (!val) return;
      
      const matches = PAGES.filter(p => p.name.toLowerCase().includes(val));
      if (matches.length === 0) {
        const div = document.createElement('div');
        div.className = 'suggestion-item';
        div.innerHTML = '<span class="page-emoji">😕</span> No results found';
        pageSuggestions.appendChild(div);
      } else {
        matches.forEach(p => {
          const div = document.createElement('div');
          div.className = 'suggestion-item';
          div.innerHTML = `
            <span class="page-emoji">${p.emoji}</span>
            <span>${p.name}</span>
          `;
          div.onclick = () => {
            searchInput.value = p.name;
            pageSuggestions.innerHTML = '';
            findBtn.style.display = 'inline-flex';
          };
          pageSuggestions.appendChild(div);
        });
        if (matches.length === 1) {
          findBtn.style.display = 'inline-flex';
        }
      }
    });

    // Player search functionality for LANDING PAGE
    playerSearchInput.addEventListener('input', async function() {
      const val = this.value.toLowerCase().trim();
      playerSuggestions.innerHTML = '';
      
      if (!val || val.length < 2) return;
      
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'suggestion-item';
      loadingDiv.innerHTML = '<span class="page-emoji">⏳</span> Searching players across all pages...';
      playerSuggestions.appendChild(loadingDiv);
      
      try {
        const players = await searchPlayers(val);
        playerSuggestions.innerHTML = '';
        
        if (!players || players.length === 0) {
          const div = document.createElement('div');
          div.className = 'suggestion-item';
          div.innerHTML = '<span class="page-emoji">😕</span> No players found';
          playerSuggestions.appendChild(div);
          return;
        }
        
        players.forEach(player => {
          const div = document.createElement('div');
          div.className = 'suggestion-item';
          
          const pageObj = PAGES.find(p => p.name === player.page);
          const pageEmoji = pageObj ? pageObj.emoji : '📄';
          
          div.innerHTML = `
            <span class="page-emoji">${pageEmoji}</span>
            <div style="flex: 1; min-width: 0;">
              <div style="font-weight: 500; margin-bottom: 0.25rem;">${player.name}</div>
              <div style="font-size: 0.875rem; color: var(--text-secondary);">
                <span class="page-indicator">${player.page}</span>
              </div>
            </div>
          `;
          
          div.onclick = () => {
            sessionStorage.setItem('searchPlayerName', player.name);
            sessionStorage.setItem('searchPlayerPage', player.page);
            tableState.history.page = 1;
            showEnhancedGlobalPlayerHistory(player.name, player.page);
          };
          
          playerSuggestions.appendChild(div);
        });
      } catch (error) {
        playerSuggestions.innerHTML = '';
        const div = document.createElement('div');
        div.className = 'suggestion-item';
        div.innerHTML = '<span class="page-emoji">❌</span> Error searching players';
        playerSuggestions.appendChild(div);
      }
    });

    async function showEnhancedGlobalPlayerHistory(playerName, pageName) {
      document.getElementById('landing').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      
      showLoader();
      disableControlButtons();
      
      document.getElementById('dashboardBoxes').style.display = 'none';
      document.getElementById('tableContainer').style.display = 'none';
      document.getElementById('playerHistorySection').style.display = 'none';
      document.getElementById('globalPlayerHistorySection').style.display = 'block';
      document.getElementById('backContainer').innerHTML = '';
      pageDepositsView.style.display = 'none';
      clientRecoveryDashboard.style.display = 'none';
      
      pageTitle.textContent = `Enhanced Player History: ${playerName}`;
      
      showLoadingProgress();
      
      try {
        const data = await getEnhancedPlayerHistory(playerName, pageName);
        hideLoader();
        const backDiv = document.getElementById('backContainer');
        backDiv.innerHTML = '<button class="btn btn-secondary" onclick="backToLanding()"><i class="fas fa-arrow-left"></i> Back to Search</button>';
        renderEnhancedPlayerHistory(data, playerName, pageName, true);
      } catch (error) {
        hideLoader();
        showNotification('Error loading enhanced player history: ' + error, 'error');
        document.getElementById('globalPlayerHistoryContainer').innerHTML = 
          `<div style="text-align: center; padding: 2rem; color: var(--danger);">
            <p>Error loading enhanced history for ${playerName}</p>
            <p style="margin-top: 1rem; color: var(--text-secondary);">${error}</p>
          </div>`;
      }
    }

    async function findPlayerForCurrentPage() {
      const playerName = document.getElementById('playerSearch').value.trim();
      if (!playerName) {
        showNotification('Please enter a player name', 'error');
        return;
      }
      
      sessionStorage.setItem('currentSearchedPlayer', playerName);
      tableState.history.page = 1;
      
      document.getElementById('playerHistoryContainer').innerHTML = `
        <div style="text-align: center; padding: 2rem;">
          <div class="spinner"></div>
          <p style="margin-top: 1rem; color: var(--text-secondary);">Loading enhanced player history for <strong>${playerName}</strong>...</p>
        </div>
      `;
      
      navigationContext = 'dashboard';
      
      try {
        const players = await searchPlayers(playerName);
        if (players && players.length > 0) {
          const currentPagePlayers = players.filter(player => 
            player.page === selectedPage && player.name === playerName
          );
          
          if (currentPagePlayers.length > 0) {
            const player = currentPagePlayers[0];
            showEnhancedPlayerHistoryForCurrentPage(player.name, selectedPage);
          } else {
            document.getElementById('playerHistoryContainer').innerHTML = `
              <div style="text-align: center; padding: 2rem; color: var(--danger);">
                <p><strong>Player "${playerName}" not found on ${selectedPage}</strong></p>
                <p style="margin-top: 1rem; color: var(--text-secondary);">Please try searching for a different player or check the spelling/capitalization.</p>
                <p style="margin-top: 0.5rem; color: var(--text-secondary); font-size: 0.875rem;">
                  Note: Player names are case-sensitive. "Gone Reed" and "GOne Reed" are different players.
                </p>
              </div>
            `;
          }
        } else {
          document.getElementById('playerHistoryContainer').innerHTML = `
            <div style="text-align: center; padding: 2rem; color: var(--danger);">
              <p><strong>Player "${playerName}" not found</strong></p>
              <p style="margin-top: 1rem; color: var(--text-secondary);">Please try searching for a different player.</p>
            </div>
          `;
        }
      } catch (error) {
        document.getElementById('playerHistoryContainer').innerHTML = `
          <div style="text-align: center; padding: 2rem; color: var(--danger);">
            <p><strong>Error searching player: ${error}</strong></p>
            <p style="margin-top: 1rem; color: var(--text-secondary);">Please try again.</p>
          </div>
        `;
      }
    }

    async function showEnhancedPlayerHistoryForCurrentPage(playerName, pageName) {
      const searchedPlayerName = sessionStorage.getItem('currentSearchedPlayer') || playerName;
      
      document.getElementById('playerHistoryContainer').innerHTML = `
        <div style="text-align: center; padding: 2rem;">
          <div class="spinner"></div>
          <p style="margin-top: 1rem; color: var(--text-secondary);">Loading enhanced player history for <strong>${searchedPlayerName}</strong>...</p>
        </div>
      `;
      
      try {
        const data = await getEnhancedPlayerHistory(playerName, pageName);
        renderEnhancedPlayerHistory(data, searchedPlayerName, pageName, false);
      } catch (error) {
        document.getElementById('playerHistoryContainer').innerHTML = 
          `<div style="text-align: center; padding: 2rem; color: var(--danger);">
            <p><strong>Error loading enhanced history for ${searchedPlayerName}</strong></p>
            <p style="margin-top: 1rem; color: var(--text-secondary);">${error}</p>
          </div>`;
      }
    }

    function findData() {
      const val = searchInput.value.trim();
      const pageObj = PAGES.find(p => p.name.toLowerCase() === val.toLowerCase());
      
      if (!val || !pageObj) {
        showNotification('Please select a valid page from the suggestions', 'error');
        return;
      }
      
      loadDashboard(pageObj);
    }

    function backToLanding() {
      clearAllSearchInputs();
      clearPlayerHistory();
      
      sessionStorage.removeItem('searchPlayerName');
      sessionStorage.removeItem('searchPlayerPage');
      sessionStorage.removeItem('searchPlayerPages');
      sessionStorage.removeItem('currentSearchedPlayer');
      
      navigationContext = 'landing';
      
      showLandingPage();
    }

    function backToDashboard() {
      resetAllTableStates();
      clearPlayerHistory();
      
      sessionStorage.removeItem('searchPlayerName');
      sessionStorage.removeItem('searchPlayerPage');
      sessionStorage.removeItem('currentSearchedPlayer');
      
      navigationContext = 'dashboard';
      
      updatePageTitle();
      disableControlButtons();
      showLoader();
      loadDashboardData();
    }

    function resetAllTableStates() {
      tableState.current = { type: null, page: 1, data: null, title: null };
      tableState.playerTables = {
        'Total': { page: 1, data: null },
        'Active': { page: 1, data: null },
        'Inactive': { page: 1, data: null },
        'RecentActive': { page: 1, data: null },
        'RecentInactive': { page: 1, data: null }
      };
      tableState.highRisk = { page: 1, data: null };
      tableState.history = { page: 1, data: null };
      tableState.deposits = { month: 0, data: null };
      
      // Reset recovery state
      recoveryState.current.tab = 'active';
      recoveryState.current.page = 1;
      recoveryState.current.search = '';
      recoveryState.current.data = null;
      recoveryState.current.stats = null;
      recoveryState.removed.page = 1;
      recoveryState.removed.search = '';
      recoveryState.removed.data = null;
      recoveryState.analytics.data = null;
    }

    function showLoadingProgress() {
      const progressMessages = [
        "Loading player data...",
        "Calculating deposits...", 
        "Analyzing activity...",
        "Finalizing dashboard..."
      ];
      
      let current = 0;
      loadingProgress.textContent = progressMessages[0];
      
      progressInterval = setInterval(() => {
        current++;
        if (current < progressMessages.length) {
          loadingProgress.textContent = progressMessages[current];
        } else {
          clearInterval(progressInterval);
        }
      }, 800);
    }

    async function renderDashboard(data) {
      currentPageData = data;

      const dash = document.getElementById('dashboardBoxes');
      dash.style.display = 'block';
      document.getElementById('tableContainer').style.display = 'block';

      statsRow1.innerHTML = "";
      statsRow2.innerHTML = "";
      statsRow3.innerHTML = "";

      document.getElementById('playerHistorySection').style.display = 'none';
      document.getElementById('globalPlayerHistorySection').style.display = 'none';
      clearPlayerHistory();
      pageDepositsView.style.display = 'none';
      clientRecoveryDashboard.style.display = 'none';

      // Get recovery count
      let recoveryCount = 0;
      try {
        const { data: recoveryData, error } = await supabase
          .from('client_recoveries')
          .select('id')
          .eq('page_name', selectedPage)
          .eq('is_active_in_list', true);
        
        if (!error && recoveryData) {
          recoveryCount = recoveryData.length;
        }
      } catch (error) {
        console.error('Error getting recovery count:', error);
      }

      const firstRowBoxes = [
        { label: "Total Players", value: data.counts.Total || 0, type: "Total", icon: "fas fa-users", colorClass: "total" },
        { label: "Active Players", value: data.counts.Active || 0, type: "Active", icon: "fas fa-user-check", colorClass: "active" },
        { label: "Inactive Players", value: data.counts.Inactive || 0, type: "Inactive", icon: "fas fa-user-times", colorClass: "inactive" }
      ];

      const secondRowBoxes = [
        { label: "Recent Active", value: data.counts.RecentActive || 0, type: "RecentActive", icon: "fas fa-bolt", colorClass: "recent-active" },
        { label: "Recent Inactive", value: data.counts.RecentInactive || 0, type: "RecentInactive", icon: "fas fa-clock", colorClass: "recent-inactive" },
        { label: "High Risk Players", value: data.counts.HighRisk || 0, type: "HighRisk", icon: "fas fa-exclamation-triangle", colorClass: "high-risk" }
      ];

      const thirdRowBoxes = [
        { label: "Player History", value: "", type: "PlayerHistory", icon: "fas fa-history", colorClass: "history" },
        { label: "Page Deposits", value: "", type: "PageDeposits", icon: "fas fa-money-bill-wave", colorClass: "deposits" },
{ label: "Recovered Clients", value: recoveryCount, type: "ClientRecovery", icon: "fas fa-handshake-angle", colorClass: "recovery" }
      ];

      firstRowBoxes.forEach(b => {
        const div = document.createElement('div');
        div.className = `stat-card ${b.colorClass}`;

        let displayValue = (b.value === "" || b.value === undefined || b.value === null) ? 0 : b.value;

        div.innerHTML = `
          <div class="stat-icon">
            <i class="${b.icon}"></i>
          </div>
          <div class="stat-value">${displayValue}</div>
          <div class="stat-label">${b.label}</div>
        `;

        div.onclick = () => showBoxData(b.type);
        statsRow1.appendChild(div);
      });

      secondRowBoxes.forEach(b => {
        const div = document.createElement('div');
        div.className = `stat-card ${b.colorClass}`;

        let displayValue = (b.value === "" || b.value === undefined || b.value === null) ? 0 : b.value;

        div.innerHTML = `
          <div class="stat-icon">
            <i class="${b.icon}"></i>
          </div>
          <div class="stat-value">${displayValue}</div>
          <div class="stat-label">${b.label}</div>
        `;

        div.onclick = () => showBoxData(b.type);
        statsRow2.appendChild(div);
      });

      thirdRowBoxes.forEach(b => {
        const div = document.createElement('div');
        div.className = `stat-card ${b.colorClass}`;

        let displayValue = (b.type === "PlayerHistory" || b.type === "PageDeposits") ? "" : (b.value === "" || b.value === undefined || b.value === null) ? 0 : b.value;

        div.innerHTML = `
          <div class="stat-icon">
            <i class="${b.icon}"></i>
          </div>
          <div class="stat-value">${displayValue}</div>
          <div class="stat-label">${b.label}</div>
        `;

        div.onclick = () => showBoxData(b.type);
        statsRow3.appendChild(div);
      });

      document.getElementById('tableContainer').innerHTML = "";
      clearBackContainer();
      document.getElementById('playerHistorySection').style.display = 'none';
      document.getElementById('globalPlayerHistorySection').style.display = 'none';
      
      document.getElementById('dashboard').style.display = 'block';
      
      sessionStorage.removeItem('searchPlayerName');
      sessionStorage.removeItem('searchPlayerPage');
      sessionStorage.removeItem('currentSearchedPlayer');
    }

    async function showBoxData(type) {
      document.getElementById('dashboardBoxes').style.display = 'none';
      const tbl = document.getElementById('tableContainer');
      const backDiv = document.getElementById('backContainer');
      tbl.innerHTML = "";
      document.getElementById('playerHistorySection').style.display = 'none';
      document.getElementById('globalPlayerHistorySection').style.display = 'none';
      pageDepositsView.style.display = 'none';
      clientRecoveryDashboard.style.display = 'none';

      tableState.current.type = type;
      tableState.current.title = getTableTitle(type);

      backDiv.innerHTML = '<button class="btn btn-secondary" onclick="backToDashboard()"><i class="fas fa-arrow-left"></i> Back to Dashboard</button>';
      
      if (type === "PlayerHistory") {
        document.getElementById('playerHistorySection').style.display = 'block';
        currentView = 'playerHistory';
        sessionStorage.setItem('currentView', 'playerHistory');
        return;
      }

      if (type === "PageDeposits") {
        showPageDeposits();
        return;
      }

      if (type === "ClientRecovery") {
        currentView = 'clientRecovery';
        sessionStorage.setItem('currentView', 'clientRecovery');
        
        // Load and show recovery dashboard
        showLoader();
        try {
          await loadRecoveryData();
          hideLoader();
          clientRecoveryDashboard.style.display = 'block';
        } catch (error) {
          hideLoader();
          showNotification('Error loading recovery data: ' + error.message, 'error');
        }
        return;
      }

      let filtered = [];
      let tableTitle = getTableTitle(type);
      
      switch(type) {
        case "Total": 
          filtered = currentPageData.players; 
          break;
        case "Active": 
          filtered = currentPageData.players.filter(p => p.status === "Active"); 
          break;
        case "Inactive": 
          filtered = currentPageData.players.filter(p => p.status === "Inactive" && p.daysSince >= INACTIVE_THRESHOLD); 
          break;
        case "RecentActive": 
          filtered = currentPageData.recentActivePlayers || []; 
          break;
        case "RecentInactive": 
          filtered = currentPageData.recentInactivePlayers || []; 
          break;
        case "HighRisk": 
          if (currentPageData.highRiskPlayers && currentPageData.highRiskPlayers.length > 0) {
            await renderHighRiskTable();
            return;
          } else {
            tbl.innerHTML = "<div class='table-container' style='text-align: center; padding: 2rem;'><p>No high risk players found.</p></div>";
          }
          break;
      }

      if (!filtered.length) {
        tbl.innerHTML = `<div class='table-container' style='text-align: center; padding: 2rem;'><p>No ${type.toLowerCase()} players found.</p></div>`;
      } else {
        await renderPlayerTable(filtered, tableTitle, type);
      }

      currentView = 'table';
      sessionStorage.setItem('currentView', 'table');
    }

    function getTableTitle(type) {
      switch(type) {
        case "Total": return "All Players";
        case "Active": return "Active Players (0-2 days)";
        case "Inactive": return "Inactive Players (15+ days)";
        case "RecentActive": return "Recent Active Players";
        case "RecentInactive": return "Recent Inactive Players (3-4 days)";
        case "HighRisk": return "High Risk Players Analysis";
        default: return "Players";
      }
    }

    // OPTIMIZED: Batch recovery button generation
    async function renderPlayerTable(players, title, type) {
      const totalPlayers = players.length;
      const currentPage = tableState.playerTables[type].page;
      const paginatedPlayers = getPaginatedPlayers(players, currentPage, PLAYERS_PER_PAGE);
      
      // Show loader for table
      document.getElementById('tableContainer').innerHTML = `
        <div class="table-container">
          <div class="table-header">
            <h3 class="table-title">${title} (${totalPlayers} total)</h3>
          </div>
          <div style="text-align: center; padding: 2rem;">
            <div class="spinner"></div>
            <p>Loading player data...</p>
          </div>
        </div>
      `;
      
      // Batch fetch recovery status for all players
      const recoveryButtonHTMLs = await getRecoveryButtonsHTMLBulk(paginatedPlayers);
      
      let html = `
        <div class="table-container">
          <div class="table-header">
            <h3 class="table-title">${title} (${totalPlayers} total)</h3>
            <div id="paginationContainer"></div>
          </div>
          <div class="table-scroll-container">
            <table style="font-size: 0.875rem;">
              <thead>
                <tr>
                  <th style="min-width: 50px; text-align: center;">S.No</th>
                  <th style="min-width: 120px;">Player</th>
                  <th style="min-width: 140px;">Last Deposit</th>
                  <th style="min-width: 100px;">Time Since</th>
                  <th style="min-width: 80px;">Status</th>
                  <th style="min-width: 90px; text-align: center;">Total $</th>
                  <th style="min-width: 90px; text-align: center;">Last 7d $</th>
                  ${type === "RecentActive" ? '<th style="min-width: 80px;">Gap Days</th>' : ''}
                  <th style="min-width: 90px; text-align: center;">Notes</th>
                  <th style="min-width: 110px; text-align: center;">Action</th>
                </tr>
              </thead>
              <tbody>
      `;
      
      for (let i = 0; i < paginatedPlayers.length; i++) {
        const p = paginatedPlayers[i];
        const cls = p.status === "Active" ? "status-active" : "status-inactive";
        
        const gapDisplay = formatTimeSince(p.originalTimestamp);
        const gapDays = p.gapDays ? p.gapDays : 'N/A';
        
        // FIXED: Check viewer role for notes button
        let notesBtnHTML = '';
        if (userRole === PIN_CONFIG.ROLES.VIEWER) {
          // Viewer can only view existing notes, not add new ones
          if (p.hasNotes) {
            notesBtnHTML = `<button class="notes-btn has-notes" onclick="showNotesModal('${p.player.replace(/'/g, "\\'")}', this)" title="View notes">
              <i class="fas fa-sticky-note"></i> Notes
            </button>`;
          } else {
            notesBtnHTML = `<button class="notes-btn" disabled style="opacity: 0.5; cursor: not-allowed;" title="No notes available (Viewer cannot add)">
              <i class="fas fa-plus"></i> Add
            </button>`;
          }
        } else {
          // Admin can add/view notes
          const notesBtnClass = p.hasNotes ? 'notes-btn has-notes' : 'notes-btn';
          const notesBtnIcon = p.hasNotes ? 'fa-sticky-note' : 'fa-plus';
          const notesBtnText = p.hasNotes ? 'Notes' : 'Add';
          
          notesBtnHTML = `<button class="${notesBtnClass}" onclick="showNotesModal('${p.player.replace(/'/g, "\\'")}', this)" title="${p.hasNotes ? 'View notes' : 'Add note'}">
            <i class="fas ${notesBtnIcon}"></i> ${notesBtnText}
          </button>`;
        }
        
        const serialNumber = (currentPage - 1) * PLAYERS_PER_PAGE + i + 1;
        
        // Use pre-generated button HTML
        const recoveryButtonHTML = recoveryButtonHTMLs[i];
        
        html += `
          <tr>
            <td style="text-align: center;">${serialNumber}</td>
            <td>${p.player}</td>
            <td>${p.lastDeposit}</td>
            <td>${gapDisplay}</td>
            <td><span class="status-badge ${cls}">${p.status}</span></td>
            <td style="text-align: center;">${p.totalDeposit || 0}</td>
            <td style="text-align: center;">${p.last7DaysDeposit || 0}</td>
            ${type === "RecentActive" ? `<td style="text-align: center;">${gapDays}</td>` : ''}
            <td style="text-align: center;">
              ${notesBtnHTML}
            </td>
            <td style="text-align: center;">
              ${recoveryButtonHTML}
            </td>
          </tr>
        `;
      }
      
      html += `
              </tbody>
            </table>
          </div>
        </div>
      `;
      
      document.getElementById('tableContainer').innerHTML = html;
      
      const paginationContainer = document.getElementById('paginationContainer');
      renderPagination(totalPlayers, currentPage, PLAYERS_PER_PAGE, paginationContainer, `changePlayerPage_${type}`);
    }

    // OPTIMIZED: Batch recovery button generation for high risk table - UPDATED FOR SMALLER SIZE
    async function renderHighRiskTable() {
      const highRiskPlayers = currentPageData.highRiskPlayers;
      const totalPlayers = highRiskPlayers.length;
      const currentPage = tableState.highRisk.page;
      const paginatedPlayers = getPaginatedPlayers(highRiskPlayers, currentPage, PLAYERS_PER_PAGE);
      
      // Show loader for table
      document.getElementById('tableContainer').innerHTML = `
        <div class="table-container">
          <div class="table-header">
            <h3 class="table-title">High Risk Players Analysis (${totalPlayers} total)</h3>
          </div>
          <div style="text-align: center; padding: 2rem;">
            <div class="spinner"></div>
            <p>Loading high risk player data...</p>
          </div>
        </div>
      `;
      
      // Batch fetch recovery status for all players
      const recoveryButtonHTMLs = await getRecoveryButtonsHTMLBulk(paginatedPlayers);
      
      let html = `
        <div class="table-container">
          <div class="table-header">
            <h3 class="table-title">High Risk Players Analysis (${totalPlayers} total)</h3>
            <div id="paginationContainer"></div>
          </div>
          <div class="table-scroll-container">
            <table class="high-risk-table">
              <thead>
                <tr>
                  <th style="text-align: center; width: 40px;">S.No</th>
                  <th style="width: 100px;">Player</th>
                  <th style="width: 70px;">Risk</th>
                  <th style="width: 50px; text-align: center;">Gaps</th>
                  <th style="width: 150px;">Gap Details</th>
                  <th style="width: 100px;">Last Deposit</th>
                  <th style="width: 100px;">Time Since</th>
                  <th style="width: 70px;">Status</th>
                  <th style="width: 70px; text-align: center;">Deposits</th>
                  <th style="width: 70px; text-align: center;">Notes</th>
                  <th style="width: 80px; text-align: center;">Action</th>
                </tr>
              </thead>
              <tbody>
      `;
      
      for (let i = 0; i < paginatedPlayers.length; i++) {
        const p = paginatedPlayers[i];
        const statusClass = p.currentStatus === "Active" ? "status-active" : "status-inactive";
        
        const lastDepositPKT = convertUTCToPKT(p.lastDeposit);
        const gapDisplay = formatTimeSince(p.lastDeposit);
        
        let gapDetails = '';
        p.gaps.forEach((gap, gapIndex) => {
          gapDetails += `
            <div style="font-size: 0.7rem; margin-bottom: 0.2rem; padding: 0.15rem 0.3rem; background: var(--bg-secondary); border-radius: 3px; border-left: 2px solid var(--primary);">
              <strong>${gap.gapDays}d</strong>: ${gap.gapBetween}
            </div>
          `;
        });
        
        // FIXED: Updated risk classes with emojis
        let riskClass = '';
        let riskEmoji = '';
        if (p.riskLevel === "Very High") {
          riskClass = 'risk-very-high';
          riskEmoji = '🔴';
        } else if (p.riskLevel === "High") {
          riskClass = 'risk-high';
          riskEmoji = '🟠';
        } else if (p.riskLevel === "Medium") {
          riskClass = 'risk-medium';
          riskEmoji = '🟡';
        } else if (p.riskLevel === "Low") {
          riskClass = 'risk-low';
          riskEmoji = '🟢';
        }
        
        // FIXED: Check viewer role for notes button
        let notesBtnHTML = '';
        if (userRole === PIN_CONFIG.ROLES.VIEWER) {
          // Viewer can only view existing notes, not add new ones
          if (p.hasNotes) {
            notesBtnHTML = `<button class="notes-btn has-notes" style="font-size: 0.7rem; padding: 0.3rem 0.5rem;" onclick="showNotesModal('${p.player.replace(/'/g, "\\'")}', this)" title="View notes">
              <i class="fas fa-sticky-note"></i> Notes
            </button>`;
          } else {
            notesBtnHTML = `<button class="notes-btn" style="font-size: 0.7rem; padding: 0.3rem 0.5rem;" disabled style="opacity: 0.5; cursor: not-allowed;" title="No notes available (Viewer cannot add)">
              <i class="fas fa-plus"></i> Add
            </button>`;
          }
        } else {
          // Admin can add/view notes
          const notesBtnClass = p.hasNotes ? 'notes-btn has-notes' : 'notes-btn';
          const notesBtnIcon = p.hasNotes ? 'fa-sticky-note' : 'fa-plus';
          const notesBtnText = p.hasNotes ? 'Notes' : 'Add';
          
          notesBtnHTML = `<button class="${notesBtnClass}" style="font-size: 0.7rem; padding: 0.3rem 0.5rem;" onclick="showNotesModal('${p.player.replace(/'/g, "\\'")}', this)" title="${p.hasNotes ? 'View notes' : 'Add note'}">
            <i class="fas ${notesBtnIcon}"></i> ${notesBtnText}
          </button>`;
        }
        
        const serialNumber = (currentPage - 1) * PLAYERS_PER_PAGE + i + 1;
        
        // Use pre-generated button HTML
        const recoveryButtonHTML = recoveryButtonHTMLs[i];
        
        html += `
          <tr>
            <td style="text-align: center; font-size: 0.75rem;">${serialNumber}</td>
            <td style="font-size: 0.75rem;"><strong>${p.player}</strong></td>
            <td class="${riskClass}" style="font-size: 0.75rem;"><strong>${riskEmoji} ${p.riskLevel}</strong></td>
            <td style="text-align: center; font-size: 0.75rem;">${p.totalQualifyingGaps}</td>
            <td style="font-size: 0.7rem;">
              <div>
                ${gapDetails}
              </div>
            </td>
            <td style="font-size: 0.75rem;">${lastDepositPKT}</td>
            <td style="font-size: 0.75rem;">${gapDisplay}</td>
            <td style="font-size: 0.75rem;"><span class="status-badge ${statusClass}" style="font-size: 0.7rem; padding: 0.15rem 0.4rem;">${p.currentStatus}</span></td>
            <td style="text-align: center; font-size: 0.75rem;">${p.totalDeposits}</td>
            <td style="text-align: center;">
              ${notesBtnHTML}
            </td>
            <td style="text-align: center;">
              ${recoveryButtonHTML}
            </td>
          </tr>
        `;
      }
      
      html += `
              </tbody>
            </table>
          </div>
        </div>
      `;
      
      // ADD RISK LEVEL EXPLANATION LEGEND
      html += `
        <div style="margin-top: 1.5rem; background: var(--bg-secondary); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color);">
          <h5 style="color: var(--text-primary); margin-bottom: 0.5rem;">Risk Level Explanation:</h5>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 0.75rem; font-size: 0.8rem;">
            <div><span class="risk-very-high" style="padding: 0.15rem 0.4rem; margin-right: 0.5rem;">🔴 Very High</span>: 3+ gaps OR 12+ day gap</div>
            <div><span class="risk-high" style="padding: 0.15rem 0.4rem; margin-right: 0.5rem;">🟠 High</span>: 2+ gaps OR 10+ day gap</div>
            <div><span class="risk-medium" style="padding: 0.15rem 0.4rem; margin-right: 0.5rem;">🟡 Medium</span>: 1 gap with 8+ days</div>
            <div><span class="risk-low" style="padding: 0.15rem 0.4rem; margin-right: 0.5rem;">🟢 Low</span>: Single smaller gaps</div>
          </div>
        </div>
      `;
      
      document.getElementById('tableContainer').innerHTML = html;
      
      const paginationContainer = document.getElementById('paginationContainer');
      renderPagination(totalPlayers, currentPage, PLAYERS_PER_PAGE, paginationContainer, 'changeHighRiskPage');
    }

    // =============================================
    // EXISTING UTILITY FUNCTIONS (Optimized)
    // =============================================

    function normalizePageName(pageName) {
      if (!pageName || typeof pageName !== 'string') return pageName;
      
      const trimmedName = pageName.trim();
      const lowerName = trimmedName.toLowerCase();
      
      if (PAGE_NAME_MAP[lowerName]) {
        return PAGE_NAME_MAP[lowerName];
      }
      
      return lowerName
        .split(' ')
        .map(word => {
          if (word === '2.0') return '2.0';
          if (word === 't') return 'T';
          if (word === 'vblink') return 'VBlink';
          return word.charAt(0).toUpperCase() + word.slice(1);
        })
        .join(' ')
        .replace(/\s+\+\s+/g, '+')
        .replace(/Egames/g, 'E-Games');
    }

    function showNotification(message, type = 'success') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        if (document.body.contains(notification)) {
          document.body.removeChild(notification);
        }
      }, 5000);
    }

    function getPaginatedPlayers(players, page, pageSize) {
      const startIndex = (page - 1) * pageSize;
      const endIndex = startIndex + pageSize;
      return players.slice(startIndex, endIndex);
    }

    function renderPagination(totalPlayers, currentPage, pageSize, container, onPageChange) {
      const totalPages = Math.ceil(totalPlayers / pageSize);
      
      if (totalPages <= 1) return '';
      
      let html = `
        <div class="pagination-buttons">
      `;
      
      html += `<button class="pagination-btn" ${currentPage === 1 ? 'disabled' : ''} onclick="${onPageChange}(${currentPage - 1})">
                <i class="fas fa-chevron-left"></i>
              </button>`;
      
      const maxVisiblePages = 5;
      let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
      let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
      
      if (endPage - startPage + 1 < maxVisiblePages) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
      }
      
      for (let i = startPage; i <= endPage; i++) {
        html += `<button class="pagination-btn ${i === currentPage ? 'active' : ''}" onclick="${onPageChange}(${i})">${i}</button>`;
      }
      
      html += `<button class="pagination-btn" ${currentPage === totalPages ? 'disabled' : ''} onclick="${onPageChange}(${currentPage + 1})">
                <i class="fas fa-chevron-right"></i>
              </button>`;
      
      html += `</div>`;
      
      container.innerHTML = html;
    }

    async function fetchAllRows(tableName, filters = {}, orderBy = null) {
      let allData = [];
      let currentPage = 0;
      const pageSize = 1000;
      let hasMore = true;
      
      console.log(`Fetching ALL rows from ${tableName} with filters:`, filters);
      
      while (hasMore) {
        let query = supabase
          .from(tableName)
          .select('*')
          .range(currentPage * pageSize, (currentPage + 1) * pageSize - 1);
        
        Object.keys(filters).forEach(key => {
          if (filters[key] !== undefined && filters[key] !== null) {
            query = query.eq(key, filters[key]);
          }
        });
        
        if (orderBy) {
          query = query.order(orderBy.field, { ascending: orderBy.ascending });
        }
        
        const { data, error } = await query;
        
        if (error) {
          console.error(`Error fetching page ${currentPage} from ${tableName}:`, error);
          throw error;
        }
        
        if (data && data.length > 0) {
          allData = [...allData, ...data];
          console.log(`Fetched page ${currentPage + 1}: ${data.length} rows (Total: ${allData.length})`);
          
          if (data.length < pageSize) {
            hasMore = false;
            console.log(`Reached last page for ${tableName}. Total rows: ${allData.length}`);
          } else {
            currentPage++;
          }
        } else {
          hasMore = false;
          console.log(`No more data for ${tableName}. Total rows: ${allData.length}`);
        }
      }
      
      return allData;
    }

    async function searchPlayers(searchTerm) {
      if (!searchTerm || searchTerm.length < 2) return [];
      
      try {
        let allPlayers = [];
        let currentPage = 0;
        const pageSize = 1000;
        let hasMore = true;
        
        console.log(`Searching players for: "${searchTerm}"`);
        
        while (hasMore) {
          const { data, error } = await supabase
            .from('latest_status')
            .select('player_name, page_name')
            .ilike('player_name', `%${searchTerm}%`)
            .range(currentPage * pageSize, (currentPage + 1) * pageSize - 1);
          
          if (error) throw error;
          
          if (data && data.length > 0) {
            allPlayers = [...allPlayers, ...data];
            
            if (data.length < pageSize) {
              hasMore = false;
            } else {
              currentPage++;
            }
          } else {
            hasMore = false;
          }
        }
        
        console.log(`Total players found for search "${searchTerm}": ${allPlayers.length}`);
        
        const uniqueResults = [];
        const seen = new Set();
        
        allPlayers.forEach(result => {
          const key = `${result.player_name}||${result.page_name}`;
          if (!seen.has(key)) {
            seen.add(key);
            uniqueResults.push({
              name: result.player_name,
              page: result.page_name,
              displayName: `${result.player_name} - ${result.page_name}`
            });
          }
        });
        
        uniqueResults.sort((a, b) => {
          const nameCompare = a.name.localeCompare(b.name);
          if (nameCompare !== 0) return nameCompare;
          return a.page.localeCompare(b.page);
        });
        
        console.log(`Unique players after deduping: ${uniqueResults.length}`);
        return uniqueResults;
      } catch (error) {
        console.error('Error searching players:', error);
        showNotification('Error searching players', 'error');
        return [];
      }
    }

    function calculatePlayerStatus(daysSince) {
      if (daysSince <= DAYS_ACTIVE) {
        return "Active";
      } else if (daysSince >= INACTIVE_THRESHOLD) {
        return "Inactive";
      } else if (daysSince >= RECENT_INACTIVE_MIN_DAYS && daysSince < RECENT_INACTIVE_MAX_DAYS) {
        return "Inactive";
      } else if (daysSince >= 5 && daysSince < HIGH_RISK_MAX_DAYS) {
        return "Inactive";
      }
      return "Inactive";
    }

    async function getPageActivity(pageName) {
      try {
        const { data: statusData, error: statusError } = await supabase
          .from('latest_status')
          .select('*')
          .eq('page_name', pageName);
        
        if (statusError) throw statusError;
        
        if (!statusData || statusData.length === 0) {
          return getEmptyPageData(pageName);
        }

        const depositData = await computePlayerDeposits(pageName);
        const playersWithNotes = await getAllPlayersWithNotes(pageName);
        
        const { data: changesData } = await supabase
          .from('status_changes')
          .select('*')
          .eq('page_name', pageName)
          .order('change_date', { ascending: false })
          .limit(100);

        const recentChanges = {};
        if (changesData) {
          changesData.forEach(change => {
            const key = change.player_name;
            if (!recentChanges[key]) {
              recentChanges[key] = change;
            }
          });
        }

        const resultPlayers = [];
        const recentActivePlayers = [];
        const recentInactivePlayers = [];
        
        statusData.forEach(player => {
          const playerName = player.player_name;
          const originalTimestamp = player.last_deposit_date;
          const lastDepositDisplay = convertUTCToPKT(originalTimestamp);
          
          const nowUTC = new Date();
          const lastDepositUTC = new Date(originalTimestamp);
          const daysSince = Math.floor((nowUTC - lastDepositUTC) / (1000 * 60 * 60 * 24));
          
          const status = calculatePlayerStatus(daysSince);
          
          const playerDeposits = depositData[playerName] || { total: 0, last7Days: 0 };
          
          let activityNotes = player.activity_notes || "";
          const recentChange = recentChanges[playerName];
          if (recentChange) {
            activityNotes += ` | Last status change: ${recentChange.old_status} → ${recentChange.new_status} on ${convertUTCToPKT(recentChange.change_date)}`;
          }
          
          const playerData = {
            player: playerName,
            lastDeposit: lastDepositDisplay,
            originalTimestamp: originalTimestamp,
            daysSince: daysSince,
            status: status,
            totalDeposit: playerDeposits.total,
            last7DaysDeposit: playerDeposits.last7Days,
            activityNotes: activityNotes,
            hasNotes: playersWithNotes[playerName] || false
          };
          
          resultPlayers.push(playerData);
          
          const recentActiveCheck = isRecentActiveOptimized(playerName, depositData);
          if (status === "Active" && recentActiveCheck.isRecentActive) {
            playerData.gapDays = recentActiveCheck.gapDays;
            recentActivePlayers.push(playerData);
          }
          
          if (status === "Inactive" && daysSince >= RECENT_INACTIVE_MIN_DAYS && daysSince < RECENT_INACTIVE_MAX_DAYS) {
            recentInactivePlayers.push(playerData);
          }
        });

        const highRiskData = await getHighRiskPlayers(pageName);
        const highRiskPlayers = highRiskData.highRiskPlayers || [];

        highRiskPlayers.forEach(player => {
          player.hasNotes = playersWithNotes[player.player] || false;
        });

        resultPlayers.sort((a, b) => new Date(b.originalTimestamp) - new Date(a.originalTimestamp));
        recentActivePlayers.sort((a, b) => new Date(b.originalTimestamp) - new Date(a.originalTimestamp));
        recentInactivePlayers.sort((a, b) => new Date(b.originalTimestamp) - new Date(a.originalTimestamp));
        highRiskPlayers.sort((a, b) => new Date(b.lastDeposit) - new Date(a.lastDeposit));

        const counts = {
          Total: resultPlayers.length,
          Active: resultPlayers.filter(p => p.status === "Active").length,
          Inactive: resultPlayers.filter(p => p.status === "Inactive" && p.daysSince >= INACTIVE_THRESHOLD).length,
          RecentActive: recentActivePlayers.length,
          RecentInactive: recentInactivePlayers.length,
          HighRisk: highRiskPlayers.length
        };

        return { 
          page: pageName, 
          counts, 
          players: resultPlayers, 
          recentActivePlayers, 
          recentInactivePlayers,
          highRiskPlayers: highRiskPlayers
        };
      } catch (error) {
        console.error('Error getting page activity:', error);
        showNotification('Error loading page data', 'error');
        return getEmptyPageData(pageName);
      }
    }

    function getEmptyPageData(pageName) {
      return {
        page: pageName, 
        counts: { Total: 0, Active: 0, Inactive: 0, RecentActive: 0, RecentInactive: 0, HighRisk: 0 }, 
        players: [], 
        recentActivePlayers: [], 
        recentInactivePlayers: [],
        highRiskPlayers: []
      };
    }

    async function computePlayerDeposits(pageName) {
      try {
        console.log(`Computing deposits for page: ${pageName}`);
        
        const allDeposits = await fetchAllRows('deposits', { page_name: pageName }, { field: 'deposit_date', ascending: true });
        
        console.log(`Total deposits fetched for ${pageName}: ${allDeposits.length}`);
        
        if (allDeposits.length === 0) {
          return {};
        }
        
        const depositData = {};
        const todayUTC = new Date();
        const sevenDaysAgo = new Date(todayUTC.getTime() - (7 * 24 * 60 * 60 * 1000));
        
        allDeposits.forEach(deposit => {
          const playerName = deposit.player_name;
          const amount = parseFloat(deposit.amount) || 0;
          const depositDateUTC = new Date(deposit.deposit_date);
          
          if (!depositData[playerName]) {
            depositData[playerName] = { total: 0, last7Days: 0, deposits: [] };
          }
          
          depositData[playerName].total += amount;
          depositData[playerName].deposits.push(depositDateUTC);
          
          if (depositDateUTC >= sevenDaysAgo) {
            depositData[playerName].last7Days += amount;
          }
        });
        
        console.log(`Processed deposits for ${Object.keys(depositData).length} players`);
        return depositData;
        
      } catch (error) {
        console.error('Error in computePlayerDeposits:', error);
        return {};
      }
    }

    function isRecentActiveOptimized(playerName, depositData) {
      const playerData = depositData[playerName];
      
      if (!playerData || !playerData.deposits || playerData.deposits.length < 2) {
        return { isRecentActive: false, gapDays: null };
      }
      
      const deposits = playerData.deposits.sort((a, b) => b - a);
      
      const latest = deposits[0];
      const secondLatest = deposits[1];
      const gapHours = Math.floor((latest - secondLatest) / (1000 * 60 * 60));
      const gapDays = gapHours / 24;
      
      const todayUTC = new Date();
      const hoursSinceLatest = Math.floor((todayUTC - latest) / (1000 * 60 * 60));
      const daysSinceLatest = hoursSinceLatest / 24;
      
      const isRecentActive = gapDays >= 3 && daysSinceLatest <= DAYS_ACTIVE;
      
      return { 
        isRecentActive: isRecentActive, 
        gapDays: isRecentActive ? Math.floor(gapDays) : null 
      };
    }

    async function getAllPlayersWithNotes(pageName) {
      try {
        const allNotes = await fetchAllRows('player_notes', { page_name: pageName });
        
        const playersWithNotes = {};
        allNotes.forEach(note => {
          playersWithNotes[note.player_name] = true;
        });
        
        console.log(`Players with notes on ${pageName}: ${Object.keys(playersWithNotes).length}`);
        return playersWithNotes;
      } catch (error) {
        console.error('Error getting players with notes:', error);
        return {};
      }
    }

    async function getPlayerNotes(pageName, playerName) {
      try {
        const allNotes = await fetchAllRows('player_notes', { 
          page_name: pageName, 
          player_name: playerName 
        }, { field: 'created_at', ascending: false });
        
        return { 
          notes: allNotes.map(note => ({
            timestamp: note.created_at,
            note: note.note_text
          })), 
          success: true 
        };
      } catch (error) {
        console.error('Error getting player notes:', error);
        return { notes: [], success: false };
      }
    }

    async function addPlayerNote(pageName, playerName, noteText) {
      try {
        if (userRole === PIN_CONFIG.ROLES.VIEWER) {
          return { 
            success: false, 
            message: "Viewer role cannot add notes" 
          };
        }
        
        const { data, error } = await supabase
          .from('player_notes')
          .insert([
            {
              page_name: pageName,
              player_name: playerName,
              note_text: noteText,
              created_at: new Date().toISOString()
            }
          ])
          .select();
        
        if (error) throw error;
        
        return { 
          success: true, 
          message: "Note added successfully",
          timestamp: new Date().toISOString()
        };
      } catch (error) {
        console.error('Error adding player note:', error);
        return { success: false, message: "Error adding note: " + error.toString() };
      }
    }

    function groupDepositsByDay(deposits) {
      const depositsByDay = {};
      
      deposits.forEach(deposit => {
        const pktDate = new Date(deposit.getTime() + (5 * 60 * 60 * 1000));
        const dateKey = formatDateForGrouping(pktDate);
        
        if (!depositsByDay[dateKey]) {
          depositsByDay[dateKey] = {
            date: dateKey,
            deposits: [deposit],
            count: 1
          };
        } else {
          depositsByDay[dateKey].deposits.push(deposit);
          depositsByDay[dateKey].count++;
        }
      });
      
      return depositsByDay;
    }

    function calculateRiskLevel(totalGaps, maxGapDays) {
      if (totalGaps === 1 && maxGapDays < 15) {
        if (maxGapDays >= 12) return "Very High";
        if (maxGapDays >= 10) return "High";
        if (maxGapDays >= 8) return "Medium";
        if (maxGapDays >= 5) return "Low";
      }
      
      if (totalGaps >= 3 || maxGapDays >= 12) {
        return "Very High";
      } else if (totalGaps >= 2 || maxGapDays >= 10) {
        return "High";
      } else if (totalGaps >= 1 && maxGapDays >= 8) {
        return "Medium";
      } else {
        return "Low";
      }
    }

    async function getHighRiskPlayers(pageName) {
      try {
        console.log(`Getting high risk players for page: ${pageName}`);
        
        const allDeposits = await fetchAllRows('deposits', { page_name: pageName }, { field: 'deposit_date', ascending: true });
        
        console.log(`Total deposits for high risk analysis: ${allDeposits.length}`);
        
        if (allDeposits.length === 0) {
          return { highRiskPlayers: [], message: "No deposit data available" };
        }
        
        const playerDeposits = {};
        const todayUTC = new Date();
        const fifteenDaysAgo = new Date(todayUTC.getTime() - (HIGH_RISK_MAX_DAYS * 24 * 60 * 60 * 1000));
        
        allDeposits.forEach(deposit => {
          const playerName = deposit.player_name;
          const depositDateUTC = new Date(deposit.deposit_date);
          
          if (!isNaN(depositDateUTC?.getTime()) && depositDateUTC >= fifteenDaysAgo) {
            if (!playerDeposits[playerName]) {
              playerDeposits[playerName] = [];
            }
            playerDeposits[playerName].push(depositDateUTC);
          }
        });

        console.log(`Players with deposits in last 15 days: ${Object.keys(playerDeposits).length}`);

        Object.keys(playerDeposits).forEach(player => {
          playerDeposits[player] = groupDepositsByDay(playerDeposits[player]);
        });

        const highRiskPlayers = [];
        const MIN_GAP_DAYS = 5;

        Object.keys(playerDeposits).forEach(player => {
          const depositsByDay = playerDeposits[player];
          const depositDates = Object.keys(depositsByDay).sort();
          
          if (depositDates.length === 0) return;

          const deposits = depositDates.map(date => {
            const dayData = depositsByDay[date];
            const latestDeposit = dayData.deposits.sort((a, b) => b - a)[0];
            return latestDeposit;
          }).sort((a, b) => a - b);
          
          if (deposits.length === 1) {
            const singleDepositDate = deposits[0];
            const hoursSinceSingleDeposit = Math.floor((todayUTC - singleDepositDate) / (1000 * 60 * 60));
            const daysSinceSingleDeposit = hoursSinceSingleDeposit / 24;
            
            if (daysSinceSingleDeposit >= MIN_GAP_DAYS && daysSinceSingleDeposit < HIGH_RISK_MAX_DAYS) {
              const currentStatus = daysSinceSingleDeposit <= DAYS_ACTIVE ? "Active" : "Inactive";
              
              highRiskPlayers.push({
                player: player,
                gaps: [{
                  gapDays: Math.floor(daysSinceSingleDeposit),
                  gapBetween: `Single activity day on ${convertUTCToPKTDateOnly(singleDepositDate.toISOString())}`
                }],
                totalQualifyingGaps: 1,
                maxGapDays: Math.floor(daysSinceSingleDeposit),
                lastDeposit: singleDepositDate.toISOString(),
                daysSinceLastDeposit: Math.floor(daysSinceSingleDeposit),
                currentStatus: currentStatus,
                totalDeposits: depositsByDay[depositDates[0]].count,
                riskLevel: calculateRiskLevel(1, Math.floor(daysSinceSingleDeposit)),
                depositType: "single"
              });
            }
            return;
          }
          
          const allGaps = [];
          const qualifyingGaps = [];
          
          for (let i = 0; i < deposits.length - 1; i++) {
            const currentDeposit = deposits[i];
            const nextDeposit = deposits[i + 1];
            const gapHours = Math.floor((nextDeposit - currentDeposit) / (1000 * 60 * 60));
            const gapDays = gapHours / 24;
            allGaps.push(gapDays);
            
            if (gapDays >= MIN_GAP_DAYS && gapDays < HIGH_RISK_MAX_DAYS) {
              qualifyingGaps.push({
                gapDays: Math.floor(gapDays),
                gapBetween: `${convertUTCToPKTDateOnly(currentDeposit.toISOString())} to ${convertUTCToPKTDateOnly(nextDeposit.toISOString())}`
              });
            }
          }
          
          const lastDepositDate = deposits[deposits.length - 1];
          const hoursSinceLastDeposit = Math.floor((todayUTC - lastDepositDate) / (1000 * 60 * 60));
          const daysSinceLastDeposit = hoursSinceLastDeposit / 24;
          
          if (daysSinceLastDeposit >= MIN_GAP_DAYS && daysSinceLastDeposit < HIGH_RISK_MAX_DAYS) {
            qualifyingGaps.push({
              gapDays: Math.floor(daysSinceLastDeposit),
              gapBetween: `${convertUTCToPKTDateOnly(lastDepositDate.toISOString())} to today`
            });
            allGaps.push(daysSinceLastDeposit);
          }
          
          const hasExcessiveGap = allGaps.some(gap => gap >= HIGH_RISK_MAX_DAYS);
          if (hasExcessiveGap) {
            return;
          }
          
          if (qualifyingGaps.length > 0) {
            const currentStatus = daysSinceLastDeposit <= DAYS_ACTIVE ? "Active" : "Inactive";
            const totalDepositCount = depositDates.reduce((sum, date) => sum + depositsByDay[date].count, 0);
            
            highRiskPlayers.push({
              player: player,
              gaps: qualifyingGaps,
              totalQualifyingGaps: qualifyingGaps.length,
              maxGapDays: Math.max(...qualifyingGaps.map(gap => gap.gapDays)),
              lastDeposit: lastDepositDate.toISOString(),
              daysSinceLastDeposit: Math.floor(daysSinceLastDeposit),
              currentStatus: currentStatus,
              totalDeposits: totalDepositCount,
              riskLevel: calculateRiskLevel(qualifyingGaps.length, Math.max(...qualifyingGaps.map(gap => gap.gapDays))),
              depositType: "multiple"
            });
          }
        });

        highRiskPlayers.sort((a, b) => new Date(b.lastDeposit) - new Date(a.lastDeposit));
        
        console.log(`High risk players found: ${highRiskPlayers.length}`);
        return {
          highRiskPlayers: highRiskPlayers,
          message: `Found ${highRiskPlayers.length} high risk players`
        };
        
      } catch (error) {
        console.error('Error getting high risk players:', error);
        return { highRiskPlayers: [], message: "Error loading high risk players: " + error.message };
      }
    }

    async function getEnhancedPlayerHistory(playerName, pageName) {
      try {
        console.log(`Getting enhanced history for player: ${playerName} on page: ${pageName}`);
        
        const allDeposits = await fetchAllRows('deposits', { 
          player_name: playerName, 
          page_name: pageName 
        }, { field: 'deposit_date', ascending: true });
        
        console.log(`Total deposits found for ${playerName}: ${allDeposits.length}`);
        
        if (!allDeposits || allDeposits.length === 0) {
          return { 
            enhancedHistory: [], 
            currentStatus: "Inactive",
            message: "No data found for this player",
            rawDeposits: 0,
            timeSinceDisplay: "N/A"
          };
        }

        const playerDeposits = allDeposits.map(deposit => {
          const utcDate = new Date(deposit.deposit_date);
          const pktDate = new Date(utcDate.getTime() + (5 * 60 * 60 * 1000));
          
          return {
            utcDate: utcDate,
            pktDate: pktDate,
            displayDate: convertUTCToPKT(deposit.deposit_date),
            displayDateOnly: convertUTCToPKTDateOnly(deposit.deposit_date),
            amount: parseFloat(deposit.amount) || 0,
            originalDate: deposit.deposit_date,
            exactTimePKT: pktDate.getTime()
          };
        }).filter(deposit => !isNaN(deposit.utcDate.getTime()));

        playerDeposits.sort((a, b) => a.pktDate - b.pktDate);
        
        const nowPKT = getCurrentPKT();
        const mostRecentDeposit = playerDeposits[playerDeposits.length - 1];
        
        const timeSinceMs = nowPKT - mostRecentDeposit.pktDate;
        const hoursSince = Math.floor(timeSinceMs / (1000 * 60 * 60));
        const minutesSince = Math.floor((timeSinceMs % (1000 * 60 * 60)) / (1000 * 60));
        const daysSince = hoursSince / 24;
        const remainingHours = hoursSince % 24;
        
        const currentStatus = calculatePlayerStatus(daysSince);

        let timeSinceDisplay = '';
        if (daysSince < 1) {
          if (hoursSince === 0) {
            timeSinceDisplay = `${minutesSince} minutes ago`;
          } else {
            timeSinceDisplay = `${hoursSince} hours ${minutesSince} minutes ago`;
          }
        } else {
          const fullDays = Math.floor(daysSince);
          if (remainingHours === 0) {
            timeSinceDisplay = `${fullDays} day${fullDays > 1 ? 's' : ''} ago`;
          } else {
            timeSinceDisplay = `${fullDays} day${fullDays > 1 ? 's' : ''} ${remainingHours} hour${remainingHours > 1 ? 's' : ''} ago`;
          }
        }

        const depositsByDay = {};
        playerDeposits.forEach(deposit => {
          const dateKey = deposit.displayDateOnly;
          
          if (!depositsByDay[dateKey]) {
            depositsByDay[dateKey] = {
              count: 0,
              totalAmount: 0,
              displayDate: dateKey,
              deposits: [],
              pktDate: deposit.pktDate,
              latestDepositTime: deposit.pktDate,
              exactTimePKT: deposit.exactTimePKT
            };
          }
          depositsByDay[dateKey].count++;
          depositsByDay[dateKey].totalAmount += deposit.amount;
          depositsByDay[dateKey].deposits.push(deposit);
          
          if (deposit.pktDate > depositsByDay[dateKey].latestDepositTime) {
            depositsByDay[dateKey].latestDepositTime = deposit.pktDate;
            depositsByDay[dateKey].exactTimePKT = deposit.exactTimePKT;
          }
        });

        const enhancedHistory = [];
        const depositDates = Object.keys(depositsByDay).sort((a, b) => {
          return depositsByDay[a].pktDate - depositsByDay[b].pktDate;
        });
        
        if (depositDates.length === 0) {
          return {
            enhancedHistory: [],
            currentStatus: "Inactive",
            message: "No deposit data available",
            rawDeposits: 0,
            timeSinceDisplay: "N/A"
          };
        }

        const timeline = [];
        const firstDepositDate = new Date(depositsByDay[depositDates[0]].pktDate);
        const lastDepositDate = new Date(depositsByDay[depositDates[depositDates.length - 1]].pktDate);
        
        let currentDate = new Date(firstDepositDate);
        currentDate.setUTCHours(0, 0, 0, 0);
        
        const todayPKT = getStartOfDayPKT(nowPKT);
        
        while (currentDate <= todayPKT) {
          const dateKey = convertUTCToPKTDateOnly(currentDate.toISOString());
          const dayData = depositsByDay[dateKey];
          
          if (dayData) {
            timeline.push({
              date: new Date(currentDate),
              dateKey: dateKey,
              isDepositDay: true,
              depositCount: dayData.count,
              totalAmount: dayData.totalAmount,
              displayDate: dateKey,
              deposits: dayData.deposits,
              pktDate: currentDate.getTime(),
              latestDepositTime: dayData.latestDepositTime,
              exactTimePKT: dayData.exactTimePKT
            });
          } else {
            timeline.push({
              date: new Date(currentDate),
              dateKey: dateKey,
              isDepositDay: false,
              depositCount: 0,
              totalAmount: 0,
              displayDate: dateKey,
              deposits: [],
              pktDate: currentDate.getTime(),
              latestDepositTime: null,
              exactTimePKT: null
            });
          }
          
          currentDate.setDate(currentDate.getDate() + 1);
          currentDate.setUTCHours(0, 0, 0, 0);
        }

        let i = 0;
        while (i < timeline.length) {
          const currentDay = timeline[i];
          
          if (currentDay.isDepositDay) {
            let activityLevel = "Normal";
            if (currentDay.depositCount > 4 || currentDay.totalAmount > 50) {
              activityLevel = "High";
            }
            
            const depositText = currentDay.depositCount === 1 
              ? "1 deposit" 
              : `${currentDay.depositCount} deposits`;
            
            const amountText = currentDay.totalAmount > 0 
              ? ` ($${currentDay.totalAmount.toFixed(2)})` 
              : "";
            
            enhancedHistory.push({
              dateRange: currentDay.displayDate,
              activity: `${depositText}${amountText}`,
              status: "Active",
              inactiveGap: 0,
              activityLevel: activityLevel,
              depositCount: currentDay.depositCount,
              totalAmount: currentDay.totalAmount,
              isDepositDay: true,
              timestamp: currentDay.pktDate,
              exactDepositTime: currentDay.latestDepositTime,
              gapDuration: "—"
            });
            i++;
          } else {
            let inactiveStart = i;
            let inactiveCount = 0;
            let startDay = timeline[inactiveStart];
            
            let previousDepositTime = null;
            for (let j = inactiveStart - 1; j >= 0; j--) {
              if (timeline[j].isDepositDay) {
                previousDepositTime = timeline[j].latestDepositTime;
                break;
              }
            }
            
            if (!previousDepositTime) {
              previousDepositTime = new Date(startDay.date);
              previousDepositTime.setUTCHours(0, 0, 0, 0);
              previousDepositTime = new Date(previousDepositTime.getTime() + (5 * 60 * 60 * 1000));
            }
            
            while (i < timeline.length && !timeline[i].isDepositDay) {
              inactiveCount++;
              i++;
            }
            
            let endTimePKT;
            if (i < timeline.length) {
              endTimePKT = timeline[i].latestDepositTime;
            } else {
              endTimePKT = nowPKT;
            }
            
            const gapDuration = calculateExactGapDuration(previousDepositTime, endTimePKT);
            
            if (inactiveCount === 1) {
              enhancedHistory.push({
                dateRange: timeline[inactiveStart].displayDate,
                activity: "No deposits",
                status: "Inactive",
                inactiveGap: inactiveCount,
                activityLevel: "None",
                depositCount: 0,
                totalAmount: 0,
                isDepositDay: false,
                timestamp: timeline[inactiveStart].pktDate,
                gapDuration: gapDuration
              });
            } else {
              const startDateStr = timeline[inactiveStart].displayDate;
              const endDateStr = timeline[i - 1].displayDate;
              enhancedHistory.push({
                dateRange: `${startDateStr} - ${endDateStr}`,
                activity: "No deposits",
                status: "Inactive",
                inactiveGap: inactiveCount,
                activityLevel: "None",
                depositCount: 0,
                totalAmount: 0,
                isDepositDay: false,
                timestamp: timeline[inactiveStart].pktDate,
                gapDuration: gapDuration
              });
            }
          }
        }

        const totalDepositDays = Object.keys(depositsByDay).length;
        const totalDepositCount = playerDeposits.length;
        const totalAmount = playerDeposits.reduce((sum, deposit) => sum + deposit.amount, 0);

        return {
          enhancedHistory: enhancedHistory,
          currentStatus: currentStatus,
          rawDeposits: totalDepositCount,
          totalDepositDays: totalDepositDays,
          totalAmount: totalAmount,
          timeSinceDisplay: timeSinceDisplay,
          message: `Found ${totalDepositCount} deposit(s) across ${totalDepositDays} day(s) from ${depositDates[0]} to ${depositDates[depositDates.length - 1]}`
        };
      } catch (error) {
        console.error('Error getting enhanced player history:', error);
        return { 
          enhancedHistory: [], 
          currentStatus: "Inactive",
          message: "Error loading player history",
          rawDeposits: 0,
          timeSinceDisplay: "N/A"
        };
      }
    }

    async function getPageDailyDeposits(pageName, monthOffset = 0) {
      try {
        console.log(`Getting daily deposits for page: ${pageName}, month offset: ${monthOffset}`);
        
        const allDeposits = await fetchAllRows('deposits', { page_name: pageName }, { field: 'deposit_date', ascending: true });
        
        console.log(`Total deposits fetched for ${pageName}: ${allDeposits.length}`);
        
        if (allDeposits.length === 0) {
          return {
            success: false,
            message: "No deposit data found",
            dailyDeposits: [],
            totalAmount: 0,
            totalTransactions: 0,
            monthlyComparison: null,
            availableMonths: []
          };
        }
        
        const processedDeposits = allDeposits.map(deposit => {
          const utcDate = new Date(deposit.deposit_date);
          const pktDate = new Date(utcDate.getTime() + (5 * 60 * 60 * 1000));
          const dateKey = formatDateForGrouping(pktDate);
          const displayDate = convertUTCToPKTDateOnly(deposit.deposit_date);
          const monthKey = pktDate.toISOString().substring(0, 7);
          
          return {
            utcDate: utcDate,
            pktDate: pktDate,
            dateKey: dateKey,
            displayDate: displayDate,
            monthKey: monthKey,
            amount: parseFloat(deposit.amount) || 0,
            player_name: deposit.player_name
          };
        }).filter(deposit => deposit.amount > 0);

        if (processedDeposits.length === 0) {
          return {
            success: false,
            message: "No deposit data with positive amounts",
            dailyDeposits: [],
            totalAmount: 0,
            totalTransactions: 0,
            monthlyComparison: null,
            availableMonths: []
          };
        }

        console.log(`Processed deposits with positive amounts: ${processedDeposits.length}`);

        const depositsByDay = {};
        processedDeposits.forEach(deposit => {
          if (!depositsByDay[deposit.dateKey]) {
            depositsByDay[deposit.dateKey] = {
              date: deposit.dateKey,
              displayDate: deposit.displayDate,
              monthKey: deposit.monthKey,
              totalAmount: 0,
              transactionCount: 0,
              timestamp: deposit.pktDate.getTime()
            };
          }
          depositsByDay[deposit.dateKey].totalAmount += deposit.amount;
          depositsByDay[deposit.dateKey].transactionCount++;
        });

        const allMonths = new Set();
        Object.values(depositsByDay).forEach(day => {
          allMonths.add(day.monthKey);
        });
        
        const sortedMonths = Array.from(allMonths).sort().reverse();
        const availableMonths = sortedMonths.map((month, index) => ({
          month: month,
          display: new Date(month + '-01').toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
          page: index + 1
        }));
        
        console.log(`Available months: ${sortedMonths.length}`, sortedMonths);
        
        if (sortedMonths.length === 0) {
          return {
            success: false,
            message: "No deposit data available",
            dailyDeposits: [],
            totalAmount: 0,
            totalTransactions: 0,
            monthlyComparison: null,
            availableMonths: []
          };
        }
        
        const currentMonthIndex = Math.min(monthOffset, sortedMonths.length - 1);
        const currentMonth = sortedMonths[currentMonthIndex];
        const previousMonth = currentMonthIndex + 1 < sortedMonths.length ? sortedMonths[currentMonthIndex + 1] : null;
        
        const currentMonthDeposits = Object.values(depositsByDay).filter(day => day.monthKey === currentMonth);
        
        const getDaysInMonth = (year, month) => {
          const monthDays = {
            1: 31,
            2: 28,
            3: 31,
            4: 30,
            5: 31,
            6: 30,
            7: 31,
            8: 31,
            9: 30,
            10: 31,
            11: 30,
            12: 31
          };
          
          if (month === 2) {
            const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
            return isLeapYear ? 29 : 28;
          }
          
          return monthDays[month] || 30;
        };
        
        const [year, month] = currentMonth.split('-').map(Number);
        const daysInMonth = getDaysInMonth(year, month);
        
        const currentMonthStart = new Date(Date.UTC(year, month - 1, 1, 0, 0, 0));
        const currentMonthEnd = new Date(Date.UTC(year, month - 1, daysInMonth, 23, 59, 59));
        
        const nowPKT = getCurrentPKT();
        const today = getStartOfDayPKT(nowPKT);
        
        const isCurrentMonth = currentMonth === formatDateForGrouping(nowPKT).substring(0, 7);
        
        let actualEndDate;
        if (isCurrentMonth) {
          actualEndDate = today;
        } else {
          actualEndDate = new Date(Date.UTC(year, month - 1, daysInMonth, 0, 0, 0));
        }
        
        const dailyDataMap = {};
        currentMonthDeposits.forEach(day => {
          dailyDataMap[day.date] = day;
        });
        
        const dailyDepositsArray = [];
        
        let currentDate = new Date(currentMonthStart);
        
        for (let day = 1; day <= daysInMonth; day++) {
          const utcDate = new Date(Date.UTC(year, month - 1, day, 12, 0, 0));
          const pktDate = new Date(utcDate.getTime() + (5 * 60 * 60 * 1000));
          const dateKey = formatDateForGrouping(pktDate);
          const displayDate = convertUTCToPKTDateOnly(utcDate.toISOString());
          
          const shouldInclude = isCurrentMonth ? 
            pktDate.getUTCFullYear() <= nowPKT.getUTCFullYear() && 
            pktDate.getUTCMonth() <= nowPKT.getUTCMonth() && 
            pktDate.getUTCDate() <= nowPKT.getUTCDate() : 
            true;
          
          if (shouldInclude) {
            if (dailyDataMap[dateKey]) {
              dailyDepositsArray.push(dailyDataMap[dateKey]);
            } else {
              dailyDepositsArray.push({
                date: dateKey,
                displayDate: displayDate,
                monthKey: currentMonth,
                totalAmount: 0,
                transactionCount: 0,
                timestamp: pktDate.getTime()
              });
            }
          }
        }
        
        dailyDepositsArray.sort((a, b) => b.timestamp - a.timestamp);
        
        console.log(`Daily deposits for ${currentMonth}: ${dailyDepositsArray.length} days`);
        
        const dailyDepositsWithTrends = dailyDepositsArray.map((day, index) => {
          let trend = null;
          
          if (index < dailyDepositsArray.length - 1) {
            const previousDay = dailyDepositsArray[index + 1];
            
            if (previousDay.totalAmount > 0 || day.totalAmount > 0) {
              const difference = day.totalAmount - previousDay.totalAmount;
              let percentage = 0;
              
              if (previousDay.totalAmount === 0 && day.totalAmount > 0) {
                percentage = 100;
              } else if (previousDay.totalAmount > 0) {
                percentage = (difference / previousDay.totalAmount) * 100;
              }
              
              trend = {
                difference: difference,
                percentage: percentage.toFixed(1),
                direction: difference > 0 ? 'up' : difference < 0 ? 'down' : 'same'
              };
            }
          }
          
          return {
            ...day,
            trend: trend
          };
        });
        
        const currentMonthTotal = dailyDepositsWithTrends.reduce((sum, day) => sum + day.totalAmount, 0);
        const currentMonthTransactions = dailyDepositsWithTrends.reduce((sum, day) => sum + day.transactionCount, 0);
        const totalDaysInPeriod = dailyDepositsWithTrends.length;
        const dailyAverage = totalDaysInPeriod > 0 ? currentMonthTotal / totalDaysInPeriod : 0;
        
        console.log(`Month ${currentMonth} summary: Total=$${currentMonthTotal.toFixed(2)}, Transactions=${currentMonthTransactions}, Days=${totalDaysInPeriod}`);
        
        let previousMonthTotal = 0;
        let previousMonthTransactions = 0;
        let monthlyComparison = null;
        
        if (previousMonth) {
          Object.values(depositsByDay).forEach(day => {
            if (day.monthKey === previousMonth) {
              previousMonthTotal += day.totalAmount;
              previousMonthTransactions += day.transactionCount;
            }
          });
          
          const monthlyDifference = currentMonthTotal - previousMonthTotal;
          let monthlyPercentage = 0;
          
          if (previousMonthTotal > 0) {
            monthlyPercentage = (monthlyDifference / previousMonthTotal) * 100;
          } else if (currentMonthTotal > 0) {
            monthlyPercentage = 100;
          }
          
          monthlyComparison = {
            previousMonth: new Date(previousMonth + '-01').toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
            previousMonthTotal: previousMonthTotal,
            previousMonthTransactions: previousMonthTransactions,
            difference: monthlyDifference,
            percentage: monthlyPercentage.toFixed(1),
            direction: monthlyDifference > 0 ? 'up' : monthlyDifference < 0 ? 'down' : 'same'
          };
          
          console.log(`Monthly comparison: ${currentMonth} vs ${previousMonth}: ${monthlyDifference > 0 ? '+' : ''}$${monthlyDifference.toFixed(2)} (${monthlyPercentage.toFixed(1)}%)`);
        }
        
        return {
          success: true,
          dailyDeposits: dailyDepositsWithTrends,
          totalAmount: currentMonthTotal,
          totalTransactions: currentMonthTransactions,
          dailyAverage: dailyAverage,
          totalDaysInPeriod: totalDaysInPeriod,
          monthlyComparison: monthlyComparison,
          currentMonth: new Date(currentMonth + '-01').toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
          availableMonths: availableMonths,
          currentPage: currentMonthIndex + 1,
          totalPages: sortedMonths.length,
          message: `Showing ${totalDaysInPeriod} days for ${new Date(currentMonth + '-01').toLocaleDateString('en-US', { month: 'short', year: 'numeric' })} - Total transactions: ${currentMonthTransactions}`
        };
      } catch (error) {
        console.error('Error getting page daily deposits:', error);
        return {
          success: false,
          message: "Error loading daily deposits: " + error.message,
          dailyDeposits: [],
          totalAmount: 0,
          totalTransactions: 0,
          monthlyComparison: null,
          availableMonths: []
        };
      }
    }

    // =============================================
    // EXISTING PAGE CHANGE FUNCTIONS
    // =============================================

    function createPlayerPageChangeFunction(type) {
      return async function(page) {
        tableState.playerTables[type].page = page;
        let filtered = [];
        
        switch(type) {
          case "Total": filtered = currentPageData.players; break;
          case "Active": filtered = currentPageData.players.filter(p => p.status === "Active"); break;
          case "Inactive": filtered = currentPageData.players.filter(p => p.status === "Inactive" && p.daysSince >= 15); break;
          case "RecentActive": filtered = currentPageData.recentActivePlayers || []; break;
          case "RecentInactive": filtered = currentPageData.recentInactivePlayers || []; break;
        }
        
        await renderPlayerTable(filtered, getTableTitle(type), type);
      };
    }

    const changePlayerPage_Total = createPlayerPageChangeFunction('Total');
    const changePlayerPage_Active = createPlayerPageChangeFunction('Active');
    const changePlayerPage_Inactive = createPlayerPageChangeFunction('Inactive');
    const changePlayerPage_RecentActive = createPlayerPageChangeFunction('RecentActive');
    const changePlayerPage_RecentInactive = createPlayerPageChangeFunction('RecentInactive');

    function changeHighRiskPage(page) {
      tableState.highRisk.page = page;
      renderHighRiskTable();
    }

    async function showPageDeposits() {
      tableState.deposits.month = 0;
      
      document.getElementById('tableContainer').innerHTML = '';
      document.getElementById('playerHistorySection').style.display = 'none';
      document.getElementById('globalPlayerHistorySection').style.display = 'none';
      document.getElementById('backContainer').innerHTML = '';
      clientRecoveryDashboard.style.display = 'none';
      
      pageDepositsView.innerHTML = `
        <div style="text-align: center; padding: 2rem;">
          <div class="spinner"></div>
          <p style="margin-top: 1rem; color: var(--text-secondary);">Loading daily deposits data...</p>
        </div>
      `;
      pageDepositsView.style.display = 'block';
      
      await loadPageDepositsData();
    }

    async function loadPageDepositsData() {
      try {
        const data = await getPageDailyDeposits(selectedPage, tableState.deposits.month);
        renderPageDeposits(data);
      } catch (error) {
        pageDepositsView.innerHTML = `
          <div style="text-align: center; padding: 2rem; color: var(--danger);">
            <p><strong>Error loading daily deposits:</strong></p>
            <p style="margin-top: 1rem; color: var(--text-secondary);">${error}</p>
          </div>
        `;
      }
    }

    async function changePageDepositsMonth(page) {
      tableState.deposits.month = page - 1;
      pageDepositsView.innerHTML = `
        <div style="text-align: center; padding: 2rem;">
          <div class="spinner"></div>
          <p style="margin-top: 1rem; color: var(--text-secondary);">Loading monthly data...</p>
        </div>
      `;
      await loadPageDepositsData();
    }

    function closePageDeposits() {
      pageDepositsView.style.display = 'none';
      tableState.deposits.month = 0;
      backToDashboard();
    }

    function renderPageDeposits(data) {
      if (!data.success || !data.dailyDeposits || data.dailyDeposits.length === 0) {
        pageDepositsView.innerHTML = `
          <div class="page-deposits-view">
            <div class="deposits-header">
              <h2 class="deposits-title">Daily Deposits - ${selectedPage}</h2>
              <button class="close-deposits-btn" onclick="closePageDeposits()" title="Close">
                <i class="fas fa-times"></i>
              </button>
            </div>
            <div style="text-align: center; padding: 2rem; color: var(--text-secondary);">
              <p>${data.message || "No daily deposit data available."}</p>
            </div>
          </div>
        `;
        return;
      }

      const totalDaysInPeriod = data.dailyDeposits.length;
      const dailyAverage = totalDaysInPeriod > 0 ? data.totalAmount / totalDaysInPeriod : 0;

      let html = `
        <div class="page-deposits-view">
          <div class="deposits-header">
            <h2 class="deposits-title">Daily Deposits - ${selectedPage}</h2>
            <button class="close-deposits-btn" onclick="closePageDeposits()" title="Close">
              <i class="fas fa-times"></i>
            </button>
          </div>
          
          <div style="margin-bottom: 1.5rem;">
            <h4 style="color: var(--text-primary); margin-bottom: 1rem; text-align: center;">${data.currentMonth}</h4>
      `;

      if (data.monthlyComparison) {
        const comparison = data.monthlyComparison;
        const comparisonClass = comparison.direction === 'up' ? 'monthly-comparison up' : 
                               comparison.direction === 'down' ? 'monthly-comparison down' : 
                               'monthly-comparison same';
        const arrow = comparison.direction === 'up' ? '🔼' : comparison.direction === 'down' ? '🔽' : '⚪';
        
        html += `
          <div class="${comparisonClass}">
            ${arrow} $${Math.abs(comparison.difference).toFixed(2)} vs ${comparison.previousMonth} (${comparison.direction === 'up' ? '+' : ''}${comparison.percentage}%)
          </div>
        `;
      }

      html += `
          <div class="monthly-summary">
            <div class="summary-card">
              <div class="summary-value">$${data.totalAmount.toFixed(2)}</div>
              <div class="summary-label">Total Amount</div>
            </div>
            <div class="summary-card">
              <div class="summary-value">${data.totalTransactions}</div>
              <div class="summary-label">Total Transactions</div>
            </div>
            <div class="summary-card">
              <div class="summary-value">${totalDaysInPeriod}</div>
              <div class="summary-label">Total Days</div>
            </div>
            <div class="summary-card">
              <div class="summary-value">$${dailyAverage.toFixed(2)}</div>
              <div class="summary-label">Daily Average</div>
            </div>
          </div>
        </div>
        
        <div class="table-container">
          <div class="table-header">
            <h3 class="table-title">Daily Deposit Breakdown - ${data.currentMonth} (${data.totalTransactions} total transactions)</h3>
            <div class="pagination-controls">
              <div class="pagination-info">
                Page ${data.currentPage} of ${data.totalPages}
              </div>
              <div class="pagination-buttons" id="pageDepositsPaginationContainer"></div>
            </div>
          </div>
          <div class="table-scroll-container">
            <table class="daily-deposits-table">
              <thead>
                <tr>
                  <th style="text-align: left; min-width: 120px;">Date</th>
                  <th style="text-align: right; min-width: 100px;">Amount</th>
                  <th style="text-align: center; min-width: 100px;">Transactions</th>
                  <th style="text-align: center; min-width: 140px;">Daily Trend</th>
                </tr>
              </thead>
              <tbody>
      `;

      data.dailyDeposits.forEach(day => {
        let trendHtml = '-';
        if (day.trend) {
          const trendClass = day.trend.direction === 'up' ? 'trend-up' : day.trend.direction === 'down' ? 'trend-down' : 'trend-same';
          const arrow = day.trend.direction === 'up' ? '🔼' : day.trend.direction === 'down' ? '🔽' : '⚪';
          const sign = day.trend.direction === 'up' ? '+' : '';
          
          trendHtml = `
            <span class="${trendClass}">
              ${arrow} $${Math.abs(day.trend.difference).toFixed(2)} (${sign}${day.trend.percentage}%)
            </span>
          `;
        }

        const amountClass = day.totalAmount > 0 ? 'amount-cell positive' : 'amount-cell zero';
        const amountDisplay = day.totalAmount > 0 ? '$' + day.totalAmount.toFixed(2) : '$0.00';
        
        html += `
          <tr>
            <td style="text-align: left;">${day.displayDate}</td>
            <td class="${amountClass}">${amountDisplay}</td>
            <td class="count-cell">${day.transactionCount}</td>
            <td class="trend-cell">${trendHtml}</td>
          </tr>
        `;
      });

      html += `
            <tr class="total-row">
              <td style="text-align: left;"><strong>TOTAL</strong></td>
              <td class="amount-cell positive"><strong>$${data.totalAmount.toFixed(2)}</strong></td>
              <td class="count-cell"><strong>${data.totalTransactions}</strong></td>
              <td class="trend-cell">-</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    
    <div style="margin-top: 1.5rem; background: var(--bg-secondary); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color);">
      <p style="color: var(--text-primary); font-size: 0.9rem; text-align: center;">
        <i class="fas fa-info-circle"></i> Showing ${data.dailyDeposits.length} day(s) for ${data.currentMonth}
        ${data.monthlyComparison ? ` | Compared to ${data.monthlyComparison.previousMonth}` : ''}
      </p>
    </div>
  `;

      pageDepositsView.innerHTML = html;

      const paginationContainer = document.getElementById('pageDepositsPaginationContainer');
      if (data.totalPages > 1) {
        renderPagination(data.totalPages, data.currentPage, 1, paginationContainer, 'changePageDepositsMonth');
      }
    }

    function renderEnhancedPlayerHistory(data, playerName, pageName, isGlobal = false) {
      const container = isGlobal ? 
        document.getElementById('globalPlayerHistoryContainer') : 
        document.getElementById('playerHistoryContainer');
      
      if (!data.enhancedHistory || data.enhancedHistory.length === 0) {
        container.innerHTML = `
          <div style="text-align: center; padding: 2rem; color: var(--text-secondary);">
            <p>${data.message || "No enhanced history available for this player."}</p>
          </div>
        `;
        return;
      }

      const pageObj = PAGES.find(p => p.name === pageName);
      const pageEmoji = pageObj ? pageObj.emoji : '📄';
      const currentStatus = data.currentStatus || "Unknown";
      const isCurrentlyActive = currentStatus === "Active";

      const reversedHistory = [...data.enhancedHistory].reverse();
      const totalEntries = reversedHistory.length;
      const startIndex = (tableState.history.page - 1) * PLAYERS_PER_PAGE;
      const endIndex = Math.min(startIndex + PLAYERS_PER_PAGE, totalEntries);
      const paginatedHistory = reversedHistory.slice(startIndex, endIndex);

      // FIXED: Player status in container - REMOVED "Last activity" line
      const statusClass = isCurrentlyActive ? 'active' : 'inactive';
      const statusIcon = isCurrentlyActive ? '✅' : '❌';
      const statusText = isCurrentlyActive ? 'ACTIVE' : 'INACTIVE';
      
      let html = `
        <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; border: 1px solid var(--border-color);">
          <div style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 0.5rem; font-weight: 500;">
            <i class="fas fa-layer-group"></i> Player on ${isGlobal ? 'Page' : 'Current Page'}:
          </div>
          <div style="display: flex; align-items: center; gap: 0.5rem;">
            <span style="font-size: 1.2rem;">${pageEmoji}</span>
            <span style="font-weight: 600; color: var(--text-primary);">${pageName}</span>
          </div>
          <div style="margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-primary);">
            <i class="fas fa-user"></i> Player: <strong>${playerName}</strong>
          </div>
        </div>
        
        <div class="player-status-container ${statusClass}">
          <div class="player-status-icon">
            ${statusIcon}
          </div>
          <div class="player-status-text">
            Player is currently ${statusText} on ${pageName}
          </div>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
          <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid var(--border-color);">
            <div style="font-size: 0.875rem; color: var(--text-secondary);">Total Deposits</div>
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--text-primary);">${data.rawDeposits || 0}</div>
          </div>
          <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid var(--border-color);">
            <div style="font-size: 0.875rem; color: var(--text-secondary);">Deposit Days</div>
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--text-primary);">${data.totalDepositDays || 0}</div>
          </div>
          <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid var(--border-color);">
            <div style="font-size: 0.875rem; color: var(--text-secondary);">Last Deposit</div>
            <div style="font-size: 1rem; font-weight: 600; color: var(--text-primary);">${data.timeSinceDisplay || 'N/A'}</div>
          </div>
          <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid var(--border-color);">
            <div style="font-size: 0.875rem; color: var(--text-secondary);">Total Amount</div>
            <div style="font-size: 1rem; font-weight: 600; color: var(--text-primary);">$${(data.totalAmount || 0).toFixed(2)}</div>
          </div>
        </div>
        
        <div class="table-container">
          <div class="table-header">
            <h3 class="table-title">Complete Activity Timeline (Latest First) - Showing ALL Deposits</h3>
            <div class="pagination-controls">
              <div class="pagination-info">
                Showing ${startIndex + 1}-${endIndex} of ${totalEntries} periods
              </div>
              <div class="pagination-buttons" id="historyPaginationContainer"></div>
            </div>
          </div>
          <div class="table-scroll-container">
            <table class="enhanced-history-table">
              <thead>
                <tr>
                  <th style="text-align: left;">Date / Period</th>
                  <th style="text-align: left;">Activity Details</th>
                  <th style="text-align: center;">Status</th>
                  <th style="text-align: center;">Gap Duration</th>
                  <th style="text-align: left;">Activity Level</th>
                </tr>
              </thead>
              <tbody>
      `;

      paginatedHistory.forEach(period => {
        const isActive = period.status === 'Active';
        const rowClass = isActive ? 'active-row' : 'inactive-row';
        const statusBadge = isActive ? 
          '<span class="status-badge status-active">Active</span>' : 
          '<span class="status-badge status-inactive">Inactive</span>';
        
        const gapDisplay = period.gapDuration;
        let gapClass = '';
        
        if (!isActive && period.inactiveGap > 0) {
          if (period.inactiveGap >= 7) gapClass = 'gap-high';
          else if (period.inactiveGap >= 4) gapClass = 'gap-medium';
          else gapClass = 'gap-low';
        }

        let activityDisplay = period.activity;
        if (isActive && period.depositCount > 0) {
          const amountText = period.totalAmount > 0 ? ` - $${period.totalAmount.toFixed(2)}` : '';
          activityDisplay = `${period.depositCount} deposit${period.depositCount > 1 ? 's' : ''}${amountText}`;
        }

        let activityLevelDisplay = '';
        if (isActive) {
          if (period.activityLevel === 'High') {
            activityLevelDisplay = '<span style="color: var(--success);"><i class="fas fa-bolt"></i> High Activity</span>';
          } else {
            activityLevelDisplay = '<span style="color: var(--info);"><i class="fas fa-check"></i> Normal</span>';
          }
        } else {
          activityLevelDisplay = '<span style="color: var(--text-secondary);"><i class="fas fa-moon"></i> No Activity</span>';
        }

        html += `
          <tr class="${rowClass}">
            <td class="date-range-cell" style="text-align: left;">${period.dateRange}</td>
            <td style="text-align: left;">
              <div style="font-weight: 500;">${activityDisplay}</div>
              ${isActive && period.depositCount > 1 ? 
                `<div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.25rem;">
                  <i class="fas fa-coins"></i> Multiple transactions this day
                </div>` : ''
              }
            </td>
            <td style="text-align: center;">${statusBadge}</td>
            <td class="gap-cell" style="text-align: center;">
              ${isActive ? 
                '<span>—</span>' : 
                `<span class="${gapClass}">${gapDisplay}</span>`
              }
            </td>
            <td style="text-align: left;">
              ${activityLevelDisplay}
            </td>
          </tr>
        `;
      });

      html += `
          </tbody>
        </table>
      </div>
    </div>
    
    <div style="margin-top: 1.5rem; background: var(--bg-secondary); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color);">
      <h5 style="color: var(--text-primary); margin-bottom: 0.5rem;">Activity Level Legend:</h5>
      <div style="display: flex; flex-wrap: wrap; gap: 1rem; font-size: 0.875rem;">
        <div><span style="color: var(--success);"><i class="fas fa-bolt"></i> High Activity</span>: >4 deposits OR >$50 in one day</div>
        <div><span style="color: var(--info);"><i class="fas fa-check"></i> Normal Activity</span>: ≤4 deposits AND ≤$50 in one day</div>
        <div><span style="color: var(--text-secondary);"><i class="fas fa-moon"></i> No Activity</span>: No deposits</div>
      </div>
    </div>
  `;

  container.innerHTML = html;

  const paginationContainer = document.getElementById('historyPaginationContainer');
  renderPagination(totalEntries, tableState.history.page, PLAYERS_PER_PAGE, paginationContainer, 'changeHistoryPage');
}

    function changeHistoryPage(page) {
      tableState.history.page = page;
      const playerName = sessionStorage.getItem('searchPlayerName') || sessionStorage.getItem('currentSearchedPlayer');
      const pageName = sessionStorage.getItem('searchPlayerPage') || selectedPage;
      const isGlobal = !!sessionStorage.getItem('searchPlayerName');
      
      if (isGlobal) {
        showEnhancedGlobalPlayerHistory(playerName, pageName);
      } else {
        showEnhancedPlayerHistoryForCurrentPage(playerName, pageName);
      }
    }

    // Notes Modal Functions
    async function showNotesModal(playerName, buttonElement) {
      currentNotesPlayer = playerName;
      currentNotesPlayerName = playerName;
      currentNotesButton = buttonElement;
      
      notesModalTitle.textContent = `Notes for ${playerName}`;
      noteTextInput.value = '';
      
      await loadPlayerNotes(playerName);
      
      notesModal.style.display = 'block';
      noteTextInput.focus();
      
      if (userRole === PIN_CONFIG.ROLES.VIEWER) {
        noteTextInput.disabled = true;
        noteTextInput.placeholder = "Viewer role cannot add notes";
        saveNoteBtn.disabled = true;
        saveNoteBtn.style.display = 'none';
      } else {
        noteTextInput.disabled = false;
        noteTextInput.placeholder = "Enter your note here...";
        saveNoteBtn.disabled = false;
        saveNoteBtn.style.display = 'inline-flex';
      }
    }

    function hideNotesModal() {
      notesModal.style.display = 'none';
      currentNotesPlayer = null;
      currentNotesPlayerName = null;
      currentNotesButton = null;
      noteTextInput.value = '';
      noteTextInput.disabled = false;
      saveNoteBtn.disabled = false;
      saveNoteBtn.style.display = 'inline-flex';
    }

    async function loadPlayerNotes(playerName) {
      notesList.innerHTML = '<div class="no-notes">Loading notes...</div>';
      
      try {
        const result = await getPlayerNotes(selectedPage, playerName);
        if (result.success && result.notes.length > 0) {
          let notesHtml = '';
          result.notes.forEach(note => {
            const formattedDate = convertUTCToPKT(note.timestamp);
            
            notesHtml += `
              <div class="note-item">
                <div class="note-timestamp">
                  <i class="fas fa-clock"></i> ${formattedDate}
                </div>
                <div class="note-text">${note.note}</div>
              </div>
            `;
          });
          notesList.innerHTML = notesHtml;
        } else {
          notesList.innerHTML = '<div class="no-notes">No notes yet for this player.</div>';
        }
      } catch (error) {
        notesList.innerHTML = '<div class="no-notes">Error loading notes.</div>';
        console.error('Error loading notes:', error);
      }
    }

    async function savePlayerNote() {
      if (userRole === PIN_CONFIG.ROLES.VIEWER) {
        showNotification('Viewer role cannot add notes', 'warning');
        return;
      }
      
      const noteText = noteTextInput.value.trim();
      
      if (!noteText) {
        showNotification('Please enter a note before saving', 'error');
        return;
      }
      
      saveNoteBtn.disabled = true;
      saveNoteBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
      
      try {
        const result = await addPlayerNote(selectedPage, currentNotesPlayer, noteText);
        if (result.success) {
          showNotification('Note saved successfully!', 'success');
          noteTextInput.value = '';
          await loadPlayerNotes(currentNotesPlayer);
          
          if (currentNotesButton) {
            currentNotesButton.innerHTML = '<i class="fas fa-sticky-note"></i> Notes';
            currentNotesButton.className = 'notes-btn has-notes';
          }
          
          updateCurrentPageDataWithNote(currentNotesPlayer);
        } else {
          showNotification('Error saving note: ' + result.message, 'error');
        }
      } catch (error) {
        showNotification('Error saving note: ' + error, 'error');
      } finally {
        saveNoteBtn.disabled = false;
        saveNoteBtn.innerHTML = '<i class="fas fa-save"></i> Save Note';
      }
    }

    function updateCurrentPageDataWithNote(playerName) {
      currentPageData.players.forEach(player => {
        if (player.player === playerName) {
          player.hasNotes = true;
        }
      });
      
      if (currentPageData.recentActivePlayers) {
        currentPageData.recentActivePlayers.forEach(player => {
          if (player.player === playerName) {
            player.hasNotes = true;
          }
        });
      }
      
      if (currentPageData.recentInactivePlayers) {
        currentPageData.recentInactivePlayers.forEach(player => {
          if (player.player === playerName) {
            player.hasNotes = true;
          }
        });
      }
      
      if (currentPageData.highRiskPlayers) {
        currentPageData.highRiskPlayers.forEach(player => {
          if (player.player === playerName) {
            player.hasNotes = true;
          }
        });
      }
    }

    // Modal functions
    function showRefreshModal() {
      if (userRole === PIN_CONFIG.ROLES.VIEWER) {
        showNotification('Viewer role cannot refresh data', 'warning');
        return;
      }
      
      if (refreshBtn.disabled) return;
      refreshPinInput.value = '';
      refreshModal.style.display = 'block';
      refreshPinInput.focus();
    }

    function hideRefreshModal() {
      refreshModal.style.display = 'none';
      refreshPinInput.value = '';
    }

    function showCleanupModal() {
      if (userRole === PIN_CONFIG.ROLES.VIEWER) {
        showNotification('Viewer role cannot perform cleanup', 'warning');
        return;
      }
      
      if (forceCleanupBtn.disabled) return;
      cleanupPinInput.value = '';
      cleanupModal.style.display = 'block';
      cleanupPinInput.focus();
    }

    function hideCleanupModal() {
      cleanupModal.style.display = 'none';
      cleanupPinInput.value = '';
    }

    async function confirmRefresh() {
      const pin = refreshPinInput.value.trim();
      if (!pin) {
        showNotification('Please enter PIN', 'error');
        return;
      }
      
      if (pin !== AUTH_PIN) {
        showNotification('Invalid PIN', 'error');
        return;
      }
      
      hideRefreshModal();
      disableAllButtons();
      refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
      showLoader();
      
      try {
        const { data, error } = await supabase.rpc('refresh_player_status', {});
        
        if (error) throw error;
        
        if (data && data.success) {
          showNotification(data.message, 'success');
          await loadDashboardData();
        } else {
          showNotification('Refresh failed: ' + (data?.message || 'Unknown error'), 'error');
        }
      } catch (error) {
        showNotification('Error refreshing data: ' + error.message, 'error');
      } finally {
        refreshBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Refresh Data';
        enableAllButtons();
      }
    }

    async function confirmForceCleanup() {
      const pin = cleanupPinInput.value.trim();
      if (!pin) {
        showNotification('Please enter PIN', 'error');
        return;
      }
      
      if (pin !== AUTH_PIN) {
        showNotification('Invalid PIN', 'error');
        return;
      }
      
      hideCleanupModal();
      disableAllButtons();
      forceCleanupBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Cleaning...';
      showLoader();
      
      try {
        const { data, error } = await supabase.rpc('force_cleanup', {});
        
        if (error) throw error;
        
        if (data && data.success) {
          showNotification(data.message, 'warning');
          await loadDashboardData();
        } else {
          showNotification('Cleanup failed: ' + (data?.message || 'Unknown error'), 'error');
        }
      } catch (error) {
        showNotification('Error during cleanup: ' + error.message, 'error');
      } finally {
        forceCleanupBtn.innerHTML = '<i class="fas fa-broom"></i> Force Cleanup';
        enableAllButtons();
      }
    }

    function disableAllButtons() {
      changePageBtn.disabled = true;
      refreshBtn.disabled = true;
      forceCleanupBtn.disabled = true;
      if (logoutBtnDashboard) logoutBtnDashboard.disabled = true;
      if (logoutBtnLanding) logoutBtnLanding.disabled = true;
    }

    function enableAllButtons() {
      changePageBtn.disabled = false;
      refreshBtn.disabled = false;
      forceCleanupBtn.disabled = false;
      if (logoutBtnDashboard) logoutBtnDashboard.disabled = false;
      if (logoutBtnLanding) logoutBtnLanding.disabled = false;
    }

    // Event listeners
    window.addEventListener('click', function(event) {
      if (event.target === refreshModal) {
        hideRefreshModal();
      }
      if (event.target === cleanupModal) {
        hideCleanupModal();
      }
      if (event.target === notesModal) {
        hideNotesModal();
      }
      if (event.target === recoveryModal) {
        hideRecoveryModal();
      }
      if (event.target === removalModal) {
        hideRemovalModal();
      }
      if (event.target === notesViewModal) {
        hideNotesViewModal();
      }
    });

    refreshPinInput.addEventListener('keypress', function(event) {
      if (event.key === 'Enter') {
        confirmRefresh();
      }
    });

    cleanupPinInput.addEventListener('keypress', function(event) {
      if (event.key === 'Enter') {
        confirmForceCleanup();
      }
    });

    noteTextInput.addEventListener('keypress', function(event) {
      if (event.key === 'Enter' && (event.ctrlKey || event.metaKey)) {
        savePlayerNote();
      }
    });

    removalPinInput.addEventListener('keypress', function(event) {
      if (event.key === 'Enter') {
        confirmRemoval();
      }
    });

    document.addEventListener('click', function(event) {
      if (!event.target.closest('.search-container')) {
        pageSuggestions.innerHTML = '';
        playerSuggestions.innerHTML = '';
      }
    });

    // Theme detection
    function detectTheme() {
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
    }

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', detectTheme);
    detectTheme();
  </script>
</body>
</html>
