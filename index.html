<!DOCTYPE html>
<html>
<head>
  <title>Player Tracking</title>
  <link rel="icon" type="image/png" href="https://cdn-icons-png.flaticon.com/512/8695/8695383.png">
  <base target="_top">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    /* === ALL YOUR EXISTING CSS STYLES === */
    :root {
      --primary: #4361ee;
      --primary-dark: #3a56d4;
      --secondary: #7209b7;
      --success: #06d6a0;
      --warning: #ffd166;
      --danger: #ef476f;
      --info: #118ab2;
      --dark: #2b2d42;
      --light: #f8f9fa;
      --gray: #6c757d;
      --border: #e9ecef;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      
      /* Theme variables */
      --bg-primary: #ffffff;
      --bg-secondary: #f8f9fa;
      --bg-card: #ffffff;
      --text-primary: #2b2d42;
      --text-secondary: #6c757d;
      --border-color: #e9ecef;
      --shadow-color: rgba(0, 0, 0, 0.1);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg-primary: #1a1b23;
        --bg-secondary: #2d2e3a;
        --bg-card: #2d2e3a;
        --text-primary: #ffffff;
        --text-secondary: #a0a0a0;
        --border-color: #3a3b4a;
        --shadow-color: rgba(0, 0, 0, 0.3);
      }
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.6;
      transition: all 0.3s ease;
    }

    /* ==================== */
    /* NEW: PIN SCREEN STYLES - FIXED WITH position: fixed */
    /* ==================== */
    #pinScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      z-index: 9999;
    }

    .pin-container {
      background: var(--bg-card);
      border-radius: 20px;
      padding: 3rem;
      box-shadow: var(--shadow-lg);
      text-align: center;
      max-width: 400px;
      width: 100%;
      border: 1px solid var(--border-color);
      animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .pin-logo {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .pin-subtitle {
      color: var(--text-secondary);
      font-size: 1rem;
      margin-bottom: 2rem;
      font-weight: 400;
    }

    .pin-input-container {
      position: relative;
      margin-bottom: 1.5rem;
    }

    .pin-input {
      width: 100%;
      padding: 1.2rem 1.5rem;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      font-size: 1.5rem;
      text-align: center;
      letter-spacing: 0.5rem;
      background: var(--bg-card);
      color: var(--text-primary);
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .pin-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
    }

    .pin-input.error {
      border-color: var(--danger);
      animation: shake 0.5s ease;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }

    .pin-input.locked {
      background: var(--bg-secondary);
      border-color: var(--border-color);
      color: var(--text-secondary);
      cursor: not-allowed;
    }

    .pin-status {
      margin-top: 0.75rem;
      min-height: 1.5rem;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .pin-status.error {
      color: var(--danger);
    }

    .pin-status.warning {
      color: var(--warning);
    }

    .pin-status.success {
      color: var(--success);
    }

    .pin-status.info {
      color: var(--info);
    }

    .pin-attempts {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .pin-lockout {
      margin-top: 1rem;
      padding: 1rem;
      background: rgba(239, 71, 111, 0.1);
      border-radius: 10px;
      border: 1px solid var(--danger);
    }

    .lockout-timer {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--danger);
      margin: 0.5rem 0;
    }

    .lockout-message {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .pin-btn {
      width: 100%;
      padding: 1rem;
      border: none;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .pin-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }

    .pin-btn:hover::before {
      left: 100%;
    }

    .pin-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .pin-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      pointer-events: none;
    }

    .pin-btn:disabled:hover::before {
      left: -100%;
    }

    .pin-footer {
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border-color);
      font-size: 0.85rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    /* ==================== */
    /* YOUR EXISTING STYLES */
    /* ==================== */

    /* Landing Page */
    #landing {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 2rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .landing-container {
      background: var(--bg-card);
      border-radius: 20px;
      padding: 3rem;
      box-shadow: var(--shadow-lg);
      text-align: center;
      max-width: 600px;
      width: 100%;
      border: 1px solid var(--border-color);
    }

    /* NEW: Logo header with logout button */
    .logo-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      width: 100%;
    }

    .logo-left {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      text-align: left;
    }

    .logo {
      font-size: 3rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 0.25rem;
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 1.1rem;
      font-weight: 400;
    }

    /* NEW: Top-right logout button */
    .logout-top {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
      border: 2px solid var(--danger);
      border-radius: 12px;
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: all 0.3s ease;
      white-space: nowrap;
    }

    .logout-top:hover:not(:disabled) {
      background: var(--danger);
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
    }

    .logout-top:active:not(:disabled) {
      transform: translateY(0);
    }

    .logout-top:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      pointer-events: none;
    }

    .search-section {
      margin-bottom: 2rem;
      text-align: left;
    }

    .section-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .search-container {
      position: relative;
      margin-bottom: 1rem;
    }

    .search-input {
      width: 100%;
      padding: 1rem 1.5rem;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      font-size: 1rem;
      transition: all 0.3s ease;
      background: var(--bg-card);
      color: var(--text-primary);
    }

    .search-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
    }

    .search-icon {
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-secondary);
    }

    #pageSuggestions,
    #playerSuggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: var(--shadow-lg);
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      margin-top: 0.5rem;
    }

    .suggestion-item {
      padding: 1rem 1.5rem;
      cursor: pointer;
      border-bottom: 1px solid var(--border-color);
      transition: background-color 0.2s ease;
      color: var(--text-primary);
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
    }

    .suggestion-item:hover {
      background-color: var(--bg-secondary);
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .page-emoji {
      font-size: 1.2rem;
      width: 24px;
      text-align: center;
    }

    .player-pages {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      margin-top: 0.25rem;
    }

    .page-indicator {
      background: var(--primary);
      color: white;
      padding: 0.2rem 0.5rem;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 500;
      white-space: nowrap;
    }

    .btn {
      padding: 1rem 2rem;
      border: none;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }

    .btn:hover::before {
      left: 100%;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      box-shadow: var(--shadow);
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-3px);
      box-shadow: var(--shadow-lg);
    }

    /* Enhanced disabled button styles */
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      pointer-events: none;
    }

    .btn:disabled:hover::before {
      left: -100%;
    }

    .btn-primary:disabled {
      background: #94a3b8;
      color: #cbd5e1;
    }

    .btn-secondary:disabled {
      background: var(--bg-secondary);
      color: var(--text-secondary);
      border-color: var(--border-color);
    }

    .btn-success:disabled {
      background: #a7f3d0;
      color: #065f46;
    }

    .btn-warning:disabled {
      background: #fef3c7;
      color: #92400e;
    }

    .btn-danger:disabled {
      background: #fecaca;
      color: #991b1b;
    }

    .btn-secondary {
      background: var(--bg-card);
      color: var(--text-secondary);
      border: 2px solid var(--border-color);
      box-shadow: var(--shadow);
    }

    .btn-secondary:hover:not(:disabled) {
      border-color: var(--primary);
      color: var(--primary);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .btn-success {
      background: var(--success);
      color: white;
      box-shadow: var(--shadow);
    }

    .btn-success:hover:not(:disabled) {
      background: #05b58c;
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .btn-warning {
      background: var(--warning);
      color: var(--dark);
      box-shadow: var(--shadow);
    }

    .btn-warning:hover:not(:disabled) {
      background: #fbbf24;
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .btn-danger {
      background: var(--danger);
      color: white;
      box-shadow: var(--shadow);
    }

    .btn-danger:hover:not(:disabled) {
      background: #e53e3e;
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    /* Dashboard */
    #dashboard {
      display: none;
      min-height: 100vh;
      background: var(--bg-secondary);
    }

    .dashboard-header {
      background: var(--bg-card);
      box-shadow: var(--shadow);
      padding: 1.5rem 2rem;
      position: sticky;
      top: 0;
      z-index: 100;
      border-bottom: 1px solid var(--border-color);
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1400px;
      margin: 0 auto;
    }

    .page-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .control-buttons {
      display: flex;
      gap: 1rem;
    }

    .dashboard-content {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
    }

    /* Stats Grid - FIXED 3-ROW LAYOUT */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .stats-grid-row-2 {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .stats-grid-row-3 {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .stat-card {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 2rem;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      cursor: pointer;
      border-left: 4px solid var(--primary);
      border: 1px solid var(--border-color);
      text-align: center;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .stat-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      transform: scaleX(0);
      transform-origin: left;
      transition: transform 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: var(--shadow-lg);
    }

    .stat-card:hover::before {
      transform: scaleX(1);
    }

    .stat-card.total { border-left-color: var(--primary); }
    .stat-card.active { border-left-color: var(--success); }
    .stat-card.inactive { border-left-color: var(--danger); }
    .stat-card.recent-active { border-left-color: var(--info); }
    .stat-card.recent-inactive { border-left-color: var(--warning); }
    .stat-card.high-risk { border-left-color: var(--danger); }
    .stat-card.history { border-left-color: var(--secondary); }
    .stat-card.deposits { border-left-color: #f59e0b; }
    .stat-card.coming-soon { border-left-color: var(--gray); }

    .stat-value {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
      color: var(--text-primary);
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .stat-label {
      color: var(--text-secondary);
      font-weight: 500;
      text-align: center;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      justify-content: center;
    }

    .stat-icon {
      font-size: 2rem;
      margin-bottom: 1rem;
      opacity: 0.8;
      text-align: center;
    }

    /* Improved Table Styles for High Risk Players */
    .high-risk-table {
      font-size: 0.875rem;
      width: 100%;
    }

    .high-risk-table th,
    .high-risk-table td {
      padding: 0.75rem 0.5rem;
      word-wrap: break-word;
    }

    /* Specific column widths for high risk table */
    .high-risk-table th:nth-child(1), /* S.No */
    .high-risk-table td:nth-child(1) {
      min-width: 50px;
      max-width: 70px;
      text-align: center;
    }

    .high-risk-table th:nth-child(2), /* Player */
    .high-risk-table td:nth-child(2) {
      min-width: 120px;
      max-width: 150px;
    }

    .high-risk-table th:nth-child(3), /* Risk Level */
    .high-risk-table td:nth-child(3) {
      min-width: 80px;
      max-width: 100px;
    }

    .high-risk-table th:nth-child(4), /* Total Gaps */
    .high-risk-table td:nth-child(4) {
      min-width: 60px;
      max-width: 80px;
      text-align: center;
    }

    .high-risk-table th:nth-child(5), /* Gap Details */
    .high-risk-table td:nth-child(5) {
      min-width: 180px;
      max-width: 220px;
      line-height: 1.3;
    }

    .high-risk-table th:nth-child(6), /* Last Deposit */
    .high-risk-table td:nth-child(6) {
      min-width: 140px;
      max-width: 160px;
    }

    .high-risk-table th:nth-child(7), /* Gap */
    .high-risk-table td:nth-child(7) {
      min-width: 100px;
      max-width: 120px;
    }

    .high-risk-table th:nth-child(8), /* Current Status */
    .high-risk-table td:nth-child(8) {
      min-width: 90px;
      max-width: 110px;
      text-align: center;
    }

    .high-risk-table th:nth-child(9), /* Total Deposits */
    .high-risk-table td:nth-child(9) {
      min-width: 70px;
      max-width: 90px;
      text-align: center;
    }

    .high-risk-table th:nth-child(10), /* Notes */
    .high-risk-table td:nth-child(10) {
      min-width: 90px;
      max-width: 110px;
      text-align: center;
    }

    /* Compact gap details */
    .gap-details-compact {
      font-size: 0.8rem;
      line-height: 1.2;
    }

    .gap-item {
      margin-bottom: 0.25rem;
      padding: 0.2rem 0.4rem;
      background: var(--bg-secondary);
      border-radius: 4px;
      border-left: 3px solid var(--primary);
    }

    .gap-item:last-child {
      margin-bottom: 0;
    }

    /* Scrollable table container for mobile */
    .table-scroll-container {
      overflow-x: auto;
      margin: 0 -1rem;
      padding: 0 1rem;
    }

    /* Tables */
    .table-container {
      background: var(--bg-card);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    .table-header {
      padding: 1.5rem 2rem;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .table-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .pagination-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .pagination-info {
      color: var(--text-secondary);
      font-size: 0.875rem;
    }

    .pagination-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .pagination-btn {
      padding: 0.5rem 1rem;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .pagination-btn:hover:not(:disabled) {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .pagination-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pagination-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th {
      background: var(--bg-secondary);
      padding: 1rem 1.5rem;
      text-align: left;
      font-weight: 600;
      color: var(--text-secondary);
      border-bottom: 1px solid var(--border-color);
    }

    td {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border-color);
      color: var(--text-primary);
    }

    tr:last-child td {
      border-bottom: none;
    }

    tr:hover {
      background: var(--bg-secondary);
    }

    .status-badge {
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .status-active {
      background: #d1fae5;
      color: #065f46;
    }

    .status-inactive {
      background: #fee2e2;
      color: #991b1b;
    }

    .risk-high { color: var(--danger); font-weight: 600; }
    .risk-very-high { color: #dc2626; font-weight: 700; }
    .risk-medium { color: var(--warning); font-weight: 600; }
    .risk-low { color: var(--success); font-weight: 600; }

    /* Notes Button */
    .notes-btn {
      padding: 0.5rem 1rem;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.875rem;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .notes-btn:hover {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .notes-btn.has-notes {
      background: var(--warning);
      color: var(--dark);
      border-color: var(--warning);
    }

    .notes-btn.has-notes:hover {
      background: #f59e0b;
      border-color: #f59e0b;
    }

    /* Player History */
    .player-history {
      background: var(--bg-card);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 2rem;
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    .current-status {
      font-size: 1.25rem;
      font-weight: 600;
      padding: 1rem;
      border-radius: 12px;
      margin-bottom: 2rem;
      text-align: center;
    }

    .status-active-bg {
      background: #d1fae5;
      color: #065f46;
      border: 2px solid #10b981;
    }

    .status-inactive-bg {
      background: #fee2e2;
      color: #991b1b;
      border: 2px solid #ef4444;
    }

    .history-timeline {
      margin: 2rem 0;
    }

    .timeline-item {
      display: flex;
      align-items: flex-start;
      margin-bottom: 1.5rem;
      padding-left: 2rem;
      position: relative;
    }

    .timeline-dot {
      position: absolute;
      left: 0;
      top: 0.5rem;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--primary);
    }

    .timeline-content {
      flex: 1;
    }

    .timeline-date {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    .timeline-event {
      color: var(--text-secondary);
    }

    /* Enhanced Player History Table */
    .enhanced-history-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }

    .enhanced-history-table th {
      background: var(--bg-secondary);
      padding: 1rem;
      text-align: left;
      font-weight: 600;
      color: var(--text-secondary);
      border-bottom: 2px solid var(--border-color);
    }

    .enhanced-history-table td {
      padding: 1rem;
      border-bottom: 1px solid var(--border-color);
    }

    .active-row {
      background: rgba(16, 185, 129, 0.05);
    }

    .inactive-row {
      background: rgba(239, 68, 68, 0.05);
    }

    .date-range-cell {
      font-weight: 500;
    }

    .gap-cell {
      text-align: center;
      font-weight: 600;
    }

    .gap-high {
      color: #dc2626;
      background: rgba(220, 38, 38, 0.1);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
    }

    .gap-medium {
      color: #d97706;
      background: rgba(217, 119, 6, 0.1);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
    }

    .gap-low {
      color: #059669;
      background: rgba(5, 150, 105, 0.1);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
    }

    /* Daily Deposits Table - FIXED ALIGNMENT */
    .daily-deposits-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
      font-size: 0.9rem;
    }

    .daily-deposits-table th {
      background: var(--bg-secondary);
      padding: 0.75rem 1rem;
      font-weight: 600;
      color: var(--text-secondary);
      border-bottom: 2px solid var(--border-color);
      white-space: nowrap;
    }

    .daily-deposits-table td {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border-color);
      white-space: nowrap;
    }

    /* FIXED: All amount cells right-aligned */
    .amount-cell {
      text-align: right !important;
      font-weight: 600;
    }

    .amount-cell.positive {
      color: var(--success);
    }

    .amount-cell.zero {
      color: var(--text-secondary);
    }

    .count-cell {
      text-align: center;
      font-weight: 500;
    }

    .trend-cell {
      text-align: center;
      min-width: 120px;
    }

    .total-row {
      background: var(--bg-secondary);
      font-weight: 700;
    }

    .total-row td {
      border-top: 2px solid var(--border-color);
    }

    /* Trend indicators */
    .trend-up {
      color: #059669;
      font-weight: 600;
    }

    .trend-down {
      color: #dc2626;
      font-weight: 600;
    }

    .trend-same {
      color: #6b7280;
      font-weight: 500;
    }

    .monthly-comparison {
      padding: 1rem 1.5rem;
      border-radius: 12px;
      margin-bottom: 1.5rem;
      font-weight: 600;
      text-align: center;
      border: 2px solid;
    }

    .monthly-comparison.up {
      background: rgba(5, 150, 105, 0.1);
      color: #059669;
      border-color: #059669;
    }

    .monthly-comparison.down {
      background: rgba(220, 38, 38, 0.1);
      color: #dc2626;
      border-color: #dc2626;
    }

    .monthly-comparison.same {
      background: rgba(107, 114, 128, 0.1);
      color: #6b7280;
      border-color: #6b7280;
    }

    .monthly-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .summary-card {
      background: var(--bg-secondary);
      padding: 1.5rem;
      border-radius: 12px;
      text-align: center;
      border: 1px solid var(--border-color);
    }

    .summary-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 0.5rem;
    }

    .summary-label {
      color: var(--text-secondary);
      font-size: 0.875rem;
      font-weight: 500;
    }

    /* Enhanced Loader Styles */
    #loader {
      display: none;
      text-align: center;
      padding: 4rem 2rem;
    }

    .loading-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 50vh;
      padding: 2rem;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid var(--border-color);
      border-left: 4px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-progress {
      margin-top: 1rem;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      backdrop-filter: blur(4px);
    }

    .modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-card);
      border-radius: 20px;
      padding: 2rem;
      box-shadow: var(--shadow-lg);
      max-width: 800px;
      width: 90%;
      border: 1px solid var(--border-color);
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 1rem;
      text-align: center;
      color: var(--text-primary);
    }

    .modal-input {
      width: 100%;
      padding: 1rem;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      font-size: 1rem;
      text-align: center;
      letter-spacing: 0.5rem;
      margin-bottom: 1.5rem;
      background: var(--bg-card);
      color: var(--text-primary);
    }

    .modal-textarea {
      width: 100%;
      padding: 1rem;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      font-size: 1rem;
      background: var(--bg-card);
      color: var(--text-primary);
      resize: vertical;
      min-height: 120px;
      font-family: inherit;
    }

    .modal-textarea:focus {
      outline: none;
      border-color: var(--primary);
    }

    .modal-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .modal-buttons {
      display: flex;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .modal-buttons .btn {
      flex: 1;
      justify-content: center;
    }

    /* Notes History */
    .notes-history {
      margin-top: 1.5rem;
      max-height: 300px;
      overflow-y: auto;
    }

    .notes-history-title {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: var(--text-primary);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.5rem;
    }

    .note-item {
      padding: 1rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin-bottom: 0.75rem;
      background: var(--bg-secondary);
    }

    .note-timestamp {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }

    .note-text {
      color: var(--text-primary);
      line-height: 1.4;
    }

    .no-notes {
      text-align: center;
      color: var(--text-secondary);
      font-style: italic;
      padding: 1rem;
    }

    /* Notifications */
    .notification {
      position: fixed;
      top: 2rem;
      right: 2rem;
      padding: 1rem 1.5rem;
      border-radius: 12px;
      color: white;
      font-weight: 500;
      box-shadow: var(--shadow-lg);
      z-index: 3000;
      animation: slideIn 0.3s ease;
    }

    .notification.success { background: var(--success); }
    .notification.error { background: var(--danger); }
    .notification.warning { background: var(--warning); color: var(--dark); }

    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    /* Coming Soon Button Styles */
    .stat-card.coming-soon {
      cursor: not-allowed;
      opacity: 0.7;
    }

    .stat-card.coming-soon:hover {
      transform: none;
    }

    .coming-soon-badge {
      position: absolute;
      top: 10px;
      right: 10px;
      background: var(--warning);
      color: var(--dark);
      padding: 0.25rem 0.5rem;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 600;
    }

    /* Page Deposits View */
    .page-deposits-view {
      background: var(--bg-card);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 2rem;
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
      position: relative;
    }

    .deposits-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--border-color);
    }

    .deposits-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .close-deposits-btn {
      background: none;
      border: none;
      font-size: 1.5rem;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 8px;
      transition: all 0.2s ease;
    }

    .close-deposits-btn:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .stats-grid,
      .stats-grid-row-2,
      .stats-grid-row-3 {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .high-risk-table {
        font-size: 0.8rem;
      }
      
      .high-risk-table th,
      .high-risk-table td {
        padding: 0.5rem 0.3rem;
      }
      
      .pin-container {
        padding: 2rem;
        max-width: 380px;
      }
    }

    @media (max-width: 768px) {
      .pin-container {
        padding: 1.5rem;
        max-width: 350px;
      }
      
      .pin-logo {
        font-size: 2rem;
      }
      
      .pin-input {
        font-size: 1.2rem;
        padding: 1rem;
      }
      
      .landing-container {
        padding: 2rem 1.5rem;
      }
      
      /* Mobile responsive for logo header */
      .logo-header {
        flex-direction: column;
        align-items: stretch;
        gap: 1rem;
        margin-bottom: 1rem;
      }
      
      .logo-left {
        text-align: center;
        align-items: center;
      }
      
      #landingLogoutSection {
        display: flex;
        justify-content: center;
        margin-top: 0.5rem;
      }
      
      .dashboard-content {
        padding: 1rem;
      }
      
      .stats-grid,
      .stats-grid-row-2,
      .stats-grid-row-3 {
        grid-template-columns: 1fr;
      }
      
      .header-content {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
      }
      
      .control-buttons {
        flex-wrap: wrap;
        justify-content: center;
      }
      
      .table-header {
        flex-direction: column;
        gap: 1rem;
        align-items: flex-start;
      }
      
      .pagination-controls {
        width: 100%;
        justify-content: space-between;
      }
      
      table {
        font-size: 0.875rem;
      }
      
      th, td {
        padding: 0.75rem 1rem;
      }
      
      .modal-content {
        padding: 1.5rem;
        max-width: 95%;
      }

      .daily-deposits-table {
        font-size: 0.8rem;
      }
      
      .daily-deposits-table th,
      .daily-deposits-table td {
        padding: 0.5rem 0.5rem;
      }
    }
    
    @media (max-width: 480px) {
      .pin-container {
        padding: 1.5rem;
        max-width: 320px;
      }
      
      .pin-logo {
        font-size: 1.75rem;
      }
      
      .pin-subtitle {
        font-size: 0.9rem;
      }
      
      .logo {
        font-size: 2.5rem;
      }
      
      .subtitle {
        font-size: 1rem;
      }
    }
  </style>
</head>

<body>
  <!-- ==================== -->
  <!-- NEW: PIN SCREEN - FIXED WITH position: fixed -->
  <!-- ==================== -->
  <div id="pinScreen">
    <div class="pin-container">
      <div class="pin-logo">
        <i class="fas fa-chart-line"></i> Tech Pulse
      </div>
      <p class="pin-subtitle">Marketing Analytics Portal</p>
      
      <div class="pin-input-container">
        <input 
          type="password" 
          id="pinInput" 
          class="pin-input" 
          placeholder="Enter PIN" 
          maxlength="5"
          inputmode="numeric"
          pattern="[0-9]*"
        />
        <div id="pinStatus" class="pin-status"></div>
        <div id="pinAttempts" class="pin-attempts"></div>
        <div id="pinLockout" class="pin-lockout" style="display: none;">
          <div class="lockout-timer" id="lockoutTimer">10:00</div>
          <div class="lockout-message">Account locked. Please try again later.</div>
        </div>
      </div>
      
      <button id="pinSubmit" class="pin-btn">
        <i class="fas fa-lock"></i> Access Dashboard
      </button>
      
      <div class="pin-footer">
        <i class="fas fa-shield-alt"></i> Secure Access Required
      </div>
    </div>
  </div>

  <!-- ==================== -->
  <!-- YOUR EXISTING CODE -->
  <!-- ==================== -->

  <!-- Landing Page -->
  <div id="landing">
    <div class="landing-container">
      <!-- NEW: Logo header with logout button in top-right -->
      <div class="logo-header">
        <div class="logo-left">
          <div class="logo">
            <i class="fas fa-chart-line"></i> Tech Pulse
          </div>
          <p class="subtitle">Marketing Department Analytics Dashboard</p>
        </div>
        
        <!-- NEW: Logout button moved to top-right -->
        <div id="landingLogoutSection" style="display: none;">
          <button id="logoutBtnLanding" class="logout-top">
            <i class="fas fa-sign-out-alt"></i> Logout
          </button>
        </div>
      </div>
      
      <!-- Page Search Section -->
      <div class="search-section">
        <div class="section-title">
          <i class="fas fa-search"></i> Search for a Page
        </div>
        <div class="search-container">
          <input 
            type="text" 
            id="pageSelectSearch" 
            class="search-input" 
            placeholder="Search for a page..."
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
          >
          <i class="fas fa-search search-icon"></i>
          <div id="pageSuggestions"></div>
        </div>
      </div>
      
      <!-- Player Search Section -->
      <div class="search-section">
        <div class="section-title">
          <i class="fas fa-user"></i> Search for a Player (All Pages)
        </div>
        <div class="search-container">
          <input 
            type="text" 
            id="playerSearchInput" 
            class="search-input" 
            placeholder="Search for a player across all pages..."
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
          >
          <i class="fas fa-search search-icon"></i>
          <div id="playerSuggestions"></div>
        </div>
      </div>
      
      <button id="findBtn" class="btn btn-primary" onclick="findData()">
        <i class="fas fa-arrow-right"></i> Access Dashboard
      </button>
    </div>
  </div>

  <!-- Dashboard -->
  <div id="dashboard">
    <header class="dashboard-header">
      <div class="header-content">
        <h1 class="page-title" id="pageTitle"></h1>
        <div class="control-buttons">
          <button id="changePageBtn" class="btn btn-secondary" onclick="backToLanding()">
            <i class="fas fa-exchange-alt"></i> Change Page
          </button>
          <button id="refreshDataBtn" class="btn btn-success" onclick="showRefreshModal()">
            <i class="fas fa-sync-alt"></i> Refresh Data
          </button>
          <button id="forceCleanupBtn" class="btn btn-warning" onclick="showCleanupModal()">
            <i class="fas fa-broom"></i> Force Cleanup
          </button>
          <button id="logoutBtnDashboard" class="btn btn-secondary" style="display: none;" disabled>
            <i class="fas fa-sign-out-alt"></i> Logout
          </button>
        </div>
      </div>
    </header>

    <div class="dashboard-content">
      <div id="loader">
        <div class="loading-screen">
          <div class="spinner"></div>
          <p>Loading dashboard data...</p>
          <div id="loadingProgress" class="loading-progress"></div>
        </div>
      </div>

      <!-- Dashboard Stats Boxes -->
      <div id="dashboardBoxes">
        <!-- First Row: Total, Active, Inactive -->
        <div class="stats-grid" id="statsRow1"></div>
        <!-- Second Row: Recent Active, Recent Inactive, High Risk -->
        <div class="stats-grid-row-2" id="statsRow2"></div>
        <!-- Third Row: Player History, Page Deposits, and Coming Soon buttons -->
        <div class="stats-grid-row-3" id="statsRow3"></div>
      </div>

      <!-- Page Deposits View (Inline, not modal) -->
      <div id="pageDepositsView" style="display: none;"></div>

      <!-- Player History Section for Dashboard (Specific Page) -->
      <div id="playerHistorySection" style="display: none;">
        <div class="player-history">
          <h3>Player History Search - Current Page Only</h3>
          <div style="display: flex; gap: 1rem; margin: 1.5rem 0;">
            <input 
              type="text" 
              id="playerSearch" 
              class="search-input" 
              placeholder="Enter player name for current page..."
              autocomplete="off"
              autocorrect="off"
              autocapitalize="off"
              spellcheck="false"
            >
            <button class="btn btn-primary" onclick="findPlayerForCurrentPage()">
              <i class="fas fa-search"></i> Search
            </button>
          </div>
          <div id="playerHistoryContainer"></div>
        </div>
      </div>

      <!-- Global Player History Section (for landing page searches) -->
      <div id="globalPlayerHistorySection" style="display: none;">
        <div class="player-history">
          <h3>Player History - All Pages</h3>
          <div id="globalPlayerHistoryContainer"></div>
        </div>
      </div>

      <div id="tableContainer"></div>
      <div id="backContainer"></div>
    </div>
  </div>

  <!-- Refresh Modal -->
  <div id="refreshModal" class="modal">
    <div class="modal-content">
      <h3 class="modal-title">Authorization Required</h3>
      <p style="text-align: center; color: var(--text-secondary); margin-bottom: 1.5rem;">
        Enter PIN to refresh data
      </p>
      <input type="password" id="refreshPinInput" class="modal-input" placeholder="****" maxlength="4">
      <div class="modal-buttons">
        <button class="btn btn-secondary" onclick="hideRefreshModal()">
          <i class="fas fa-times"></i> Cancel
        </button>
        <button class="btn btn-success" onclick="confirmRefresh()">
          <i class="fas fa-check"></i> Confirm
        </button>
      </div>
    </div>
  </div>

  <!-- Cleanup Modal -->
  <div id="cleanupModal" class="modal">
    <div class="modal-content">
      <h3 class="modal-title">Authorization Required</h3>
      <p style="text-align: center; color: var(--text-secondary); margin-bottom: 1.5rem;">
        Enter PIN to perform force cleanup
      </p>
      <input type="password" id="cleanupPinInput" class="modal-input" placeholder="****" maxlength="4">
      <div class="modal-buttons">
        <button class="btn btn-secondary" onclick="hideCleanupModal()">
          <i class="fas fa-times"></i> Cancel
        </button>
        <button class="btn btn-warning" onclick="confirmForceCleanup()">
          <i class="fas fa-check"></i> Confirm
        </button>
      </div>
    </div>
  </div>

  <!-- Notes Modal -->
  <div id="notesModal" class="modal">
    <div class="modal-content">
      <h3 class="modal-title" id="notesModalTitle">Add Note for Player</h3>
      
      <div>
        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-primary); font-weight: 500;">
          New Note:
        </label>
        <textarea id="noteTextInput" class="modal-textarea" placeholder="Enter your note here..."></textarea>
      </div>
      
      <div class="notes-history" id="notesHistoryContainer">
        <div class="notes-history-title">Previous Notes</div>
        <div id="notesList" class="no-notes">No notes yet for this player.</div>
      </div>
      
      <div class="modal-buttons">
        <button class="btn btn-secondary" onclick="hideNotesModal()">
          <i class="fas fa-times"></i> Cancel
        </button>
        <button id="saveNoteBtn" class="btn btn-success" onclick="savePlayerNote()">
          <i class="fas fa-save"></i> Save Note
        </button>
      </div>
    </div>
  </div>

  <script>
    
    // =============================================
    // NEW: PIN AUTHENTICATION SYSTEM
    // =============================================
    
    // PIN Configuration - Using hashes for security
    const PIN_CONFIG = {
      ADMIN_HASH: "8f9c8b7a6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b9c8d7e6f5a4b3c2d1e0f9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b9c8d7e6f5a4b3c2d1e0f9a8b7c6d5e4f3a2b1",
      VIEWER_HASH: "1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7",
      
      // Security settings
      MAX_ATTEMPTS: 3,
      LOCKOUT_MINUTES: 10,
      
      // User roles
      ROLES: {
        ADMIN: 'admin',
        VIEWER: 'viewer',
        NONE: 'none'
      }
    };
    
    // Session state
    let userRole = PIN_CONFIG.ROLES.NONE;
    let failedAttempts = 0;
    let lockoutUntil = null;
    let lockoutInterval = null;
    
    // DOM Elements for PIN system
    const pinScreen = document.getElementById('pinScreen');
    const pinInput = document.getElementById('pinInput');
    const pinSubmit = document.getElementById('pinSubmit');
    const pinStatus = document.getElementById('pinStatus');
    const pinAttempts = document.getElementById('pinAttempts');
    const pinLockout = document.getElementById('pinLockout');
    const lockoutTimer = document.getElementById('lockoutTimer');
    
    // Store original button states for UI reset
    let originalButtonStates = {};
    
    // Simple hash function (for demo - in production use proper hashing)
    function simpleHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return hash.toString(16);
    }
    
    // Initialize PIN system
    function initPinSystem() {
      // Load saved state from localStorage
      loadSecurityState();
      
      // Check if user is already authenticated
      const isAuthenticated = sessionStorage.getItem('pinAuthenticated') === 'true';
      const savedRole = sessionStorage.getItem('userRole');
      
      if (isAuthenticated && savedRole) {
        // User is already logged in
        userRole = savedRole;
        showApplication();
        return;
      }
      
      // Check if user is locked out
      checkLockoutStatus();
      
      // Set up event listeners
      pinInput.addEventListener('keypress', handlePinKeyPress);
      pinSubmit.addEventListener('click', verifyPin);
      pinInput.addEventListener('input', clearPinError);
      
      // Store original button states for UI reset
      storeOriginalButtonStates();
      
      // Auto-focus on PIN input
      setTimeout(() => {
        if (pinInput && !pinInput.disabled) {
          pinInput.focus();
        }
      }, 100);
    }
    
    // Store original button states for UI reset
    function storeOriginalButtonStates() {
      const adminButtons = document.querySelectorAll('#refreshDataBtn, #forceCleanupBtn, #changePageBtn');
      adminButtons.forEach(btn => {
        const id = btn.id;
        originalButtonStates[id] = {
          className: btn.className,
          innerHTML: btn.innerHTML,
          disabled: btn.disabled
        };
      });
    }
    
    // Reset UI to default state before applying role-based styling
    function resetUI() {
      // Reset control buttons to original state
      Object.keys(originalButtonStates).forEach(id => {
        const btn = document.getElementById(id);
        if (btn && originalButtonStates[id]) {
          const original = originalButtonStates[id];
          btn.className = original.className;
          btn.innerHTML = original.innerHTML;
          btn.disabled = original.disabled;
        }
      });
      
      // Reset page title
      const pageTitle = document.getElementById('pageTitle');
      if (pageTitle && pageTitle.textContent.includes('View Only')) {
        pageTitle.textContent = pageTitle.textContent.replace(' <span style="font-size: 0.8rem; background: var(--info); color: white; padding: 0.2rem 0.5rem; border-radius: 12px;">View Only</span>', '');
      }
    }
    
    // Load security state from localStorage
    function loadSecurityState() {
      try {
        const savedAttempts = localStorage.getItem('failedAttempts');
        const savedLockout = localStorage.getItem('lockoutUntil');
        
        if (savedAttempts) {
          failedAttempts = parseInt(savedAttempts, 10);
        }
        
        if (savedLockout) {
          lockoutUntil = new Date(savedLockout);
          if (lockoutUntil < new Date()) {
            // Lockout has expired
            resetSecurityState();
          } else {
            // User is still locked out - set a small delay to prevent recursion
            setTimeout(() => {
              if (lockoutUntil && lockoutUntil > new Date()) {
                disablePinInput();
                pinLockout.style.display = 'block';
                updateLockoutTimer();
                startLockoutTimer();
              }
            }, 100);
          }
        }
        
        updateAttemptsDisplay();
      } catch (error) {
        console.error('Error loading security state:', error);
        resetSecurityState();
      }
    }
    
    // Save security state to localStorage
    function saveSecurityState() {
      try {
        localStorage.setItem('failedAttempts', failedAttempts.toString());
        if (lockoutUntil) {
          localStorage.setItem('lockoutUntil', lockoutUntil.toISOString());
        } else {
          localStorage.removeItem('lockoutUntil');
        }
      } catch (error) {
        console.error('Error saving security state:', error);
      }
    }
    
    // Reset security state
    function resetSecurityState() {
      failedAttempts = 0;
      lockoutUntil = null;
      if (lockoutInterval) {
        clearInterval(lockoutInterval);
        lockoutInterval = null;
      }
      saveSecurityState();
      updateAttemptsDisplay();
    }
    
    // Check lockout status - FIXED to prevent recursion
    function checkLockoutStatus() {
      if (!lockoutUntil) return false;
      
      const now = new Date();
      if (lockoutUntil > now) {
        // User is locked out
        startLockoutTimer();
        disablePinInput();
        return true;
      } else {
        // Lockout has expired
        resetSecurityState();
        enablePinInput();
        return false;
      }
    }
    
    // Start lockout timer - FIXED to prevent recursion
    function startLockoutTimer() {
      if (!lockoutUntil || lockoutUntil <= new Date()) {
        // Lockout expired or invalid
        if (lockoutInterval) {
          clearInterval(lockoutInterval);
          lockoutInterval = null;
        }
        resetSecurityState();
        enablePinInput();
        pinLockout.style.display = 'none';
        return;
      }
      
      pinLockout.style.display = 'block';
      updateLockoutTimer();
      
      // Clear any existing interval
      if (lockoutInterval) {
        clearInterval(lockoutInterval);
      }
      
      lockoutInterval = setInterval(() => {
        if (!updateLockoutTimer()) {
          clearInterval(lockoutInterval);
          lockoutInterval = null;
          resetSecurityState();
          enablePinInput();
          pinLockout.style.display = 'none';
          showPinStatus('Lockout expired. You may try again.', 'info');
        }
      }, 1000);
    }
    
    // Update lockout timer display
    function updateLockoutTimer() {
      if (!lockoutUntil) return false;
      
      const now = new Date();
      const diff = lockoutUntil - now;
      
      if (diff <= 0) {
        lockoutTimer.textContent = '00:00';
        return false;
      }
      
      const minutes = Math.floor(diff / 60000);
      const seconds = Math.floor((diff % 60000) / 1000);
      lockoutTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      return true;
    }
    
    // Disable PIN input
    function disablePinInput() {
      pinInput.disabled = true;
      pinInput.classList.add('locked');
      pinInput.placeholder = 'Account Locked';
      pinSubmit.disabled = true;
    }
    
    // Enable PIN input
    function enablePinInput() {
      pinInput.disabled = false;
      pinInput.classList.remove('locked');
      pinInput.placeholder = 'Enter PIN';
      pinSubmit.disabled = false;
      pinInput.focus();
    }
    
    // Handle PIN key press
    function handlePinKeyPress(event) {
      if (event.key === 'Enter') {
        verifyPin();
      }
      
      // Only allow numbers
      if (!/^\d$/.test(event.key) && event.key !== 'Backspace' && event.key !== 'Delete' && event.key !== 'Tab') {
        event.preventDefault();
      }
    }
    
    // Clear PIN error
    function clearPinError() {
      pinInput.classList.remove('error');
      pinStatus.textContent = '';
      pinStatus.className = 'pin-status';
    }
    
    // Show PIN status
    function showPinStatus(message, type = 'error') {
      pinStatus.textContent = message;
      pinStatus.className = `pin-status ${type}`;
    }
    
    // Update attempts display
    function updateAttemptsDisplay() {
      const attemptsLeft = PIN_CONFIG.MAX_ATTEMPTS - failedAttempts;
      
      if (failedAttempts > 0 && attemptsLeft > 0) {
        pinAttempts.textContent = `${attemptsLeft} attempt${attemptsLeft > 1 ? 's' : ''} remaining`;
        pinAttempts.style.display = 'block';
      } else {
        pinAttempts.style.display = 'none';
      }
    }
    
    // Verify PIN
    function verifyPin() {
      const enteredPin = pinInput.value.trim();
      
      // Validate PIN length
      if (enteredPin.length !== 5) {
        showPinStatus('PIN must be 5 digits', 'error');
        pinInput.classList.add('error');
        return;
      }
      
      // Check if user is locked out
      if (checkLockoutStatus()) {
        showPinStatus('Account is locked. Please wait.', 'error');
        return;
      }
      
      // Show loading state
      pinSubmit.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Verifying...';
      pinSubmit.disabled = true;
      
      // Simulate API call delay
      setTimeout(() => {
        // Check PIN against hashes
        const pinHash = simpleHash(enteredPin);
        
        // In a real app, you would compare with properly hashed PINs
        // For now, we'll compare with the actual PINs (remove this in production)
        let role = PIN_CONFIG.ROLES.NONE;
        
        if (enteredPin === '37071') {
          role = PIN_CONFIG.ROLES.ADMIN;
        } else if (enteredPin === '81522') {
          role = PIN_CONFIG.ROLES.VIEWER;
        }
        
        if (role !== PIN_CONFIG.ROLES.NONE) {
          // Successful login
          userRole = role;
          resetSecurityState();
          sessionStorage.setItem('pinAuthenticated', 'true');
          sessionStorage.setItem('userRole', userRole);
          sessionStorage.setItem('loginTime', new Date().toISOString());
          
          showPinStatus('Access granted!', 'success');
          pinInput.classList.remove('error');
          
          // Clear PIN input
          pinInput.value = '';
          
          // Show application after short delay
          setTimeout(() => {
            showApplication();
          }, 500);
          
        } else {
          // Failed login
          failedAttempts++;
          saveSecurityState();
          
          if (failedAttempts >= PIN_CONFIG.MAX_ATTEMPTS) {
            // Lock user out
            lockoutUntil = new Date(Date.now() + (PIN_CONFIG.LOCKOUT_MINUTES * 60 * 1000));
            saveSecurityState();
            disablePinInput(); // Disable first
            pinLockout.style.display = 'block'; // Show lockout UI
            updateLockoutTimer(); // Update timer display
            showPinStatus(`Too many failed attempts. Account locked for ${PIN_CONFIG.LOCKOUT_MINUTES} minutes.`, 'error');
            
            // Start timer after UI is updated
            setTimeout(() => {
              startLockoutTimer();
            }, 100);
          } else {
            // Show remaining attempts
            const attemptsLeft = PIN_CONFIG.MAX_ATTEMPTS - failedAttempts;
            showPinStatus(`Incorrect PIN. ${attemptsLeft} attempt${attemptsLeft > 1 ? 's' : ''} remaining.`, 'error');
            pinInput.classList.add('error');
            pinInput.value = '';
            pinInput.focus();
            updateAttemptsDisplay();
          }
        }
        
        // Reset button state
        pinSubmit.innerHTML = '<i class="fas fa-lock"></i> Access Dashboard';
        pinSubmit.disabled = false;
        
      }, 800); // Simulated delay
    }
    
    // Setup logout button
    function setupLogoutButton() {
      const logoutBtnLanding = document.getElementById('logoutBtnLanding');
      const logoutBtnDashboard = document.getElementById('logoutBtnDashboard');
      
      if (logoutBtnLanding) {
        logoutBtnLanding.onclick = logout;
      }
      
      if (logoutBtnDashboard) {
        logoutBtnDashboard.onclick = logout;
      }
    }
    
    // Show application (your existing code)
    function showApplication() {
      pinScreen.style.display = 'none';
      
      // Check if we should show landing page or dashboard
      const savedPage = sessionStorage.getItem('currentPage');
      if (savedPage) {
        // User was previously on dashboard
        const pageObj = PAGES.find(p => p.name === savedPage);
        if (pageObj) {
          currentPageObj = pageObj;
          navigationContext = 'dashboard';
          loadDashboard(pageObj);
        } else {
          showLandingPage();
        }
      } else {
        showLandingPage();
      }
      
      // Apply role-based permissions
      applyRolePermissions();
      
      // Setup logout button
      setupLogoutButton();
    }
    
    // Apply role-based permissions
    function applyRolePermissions() {
      // Reset UI first to remove any previous role styling
      resetUI();
      
      if (userRole === PIN_CONFIG.ROLES.VIEWER) {
        // Viewer role - disable write operations
        const adminButtons = document.querySelectorAll('#refreshDataBtn, #forceCleanupBtn, #changePageBtn');
        adminButtons.forEach(btn => {
          btn.disabled = true;
          btn.innerHTML = `<i class="fas fa-eye"></i> ${btn.textContent.replace(/^[^a-zA-Z]*/, '')}`;
          btn.classList.remove('btn-success', 'btn-warning', 'btn-secondary');
          btn.classList.add('btn-secondary');
        });
        
        // Update notes buttons to be view-only
        document.addEventListener('click', function(event) {
          if (event.target.closest('.notes-btn')) {
            const btn = event.target.closest('.notes-btn');
            const playerName = btn.getAttribute('data-player') || btn.parentElement.getAttribute('data-player');
            if (playerName) {
              showNotesModal(playerName, btn);
              event.preventDefault();
              event.stopPropagation();
            }
          }
        });
        
        // Disable note saving
        const originalSaveNote = window.savePlayerNote;
        window.savePlayerNote = function() {
          showNotification('Viewer role cannot add notes', 'warning');
        };
        
        // Show viewer badge
        const pageTitle = document.getElementById('pageTitle');
        if (pageTitle) {
          pageTitle.innerHTML += ' <span style="font-size: 0.8rem; background: var(--info); color: white; padding: 0.2rem 0.5rem; border-radius: 12px;">View Only</span>';
        }
      }
    }
    
    // Logout function (FIXED FOR BOTH LOCATIONS)
    function logout() {
      // Clear all session data
      sessionStorage.removeItem('pinAuthenticated');
      sessionStorage.removeItem('userRole');
      sessionStorage.removeItem('loginTime');
      sessionStorage.removeItem('currentPage');
      sessionStorage.removeItem('currentView');
      sessionStorage.removeItem('searchPlayerName');
      sessionStorage.removeItem('searchPlayerPage');
      sessionStorage.removeItem('searchPlayerPages');
      sessionStorage.removeItem('currentSearchedPlayer');
      
      // Reset user role
      userRole = PIN_CONFIG.ROLES.NONE;
      
      // Show PIN screen, hide everything else
      pinScreen.style.display = 'flex';
      document.getElementById('landing').style.display = 'none';
      document.getElementById('dashboard').style.display = 'none';
      
      // Reset PIN input
      pinInput.value = '';
      pinInput.focus();
      clearPinError();
      
      // Reset UI to default state
      resetUI();
      
      // Check lockout status
      checkLockoutStatus();
      
      // Show logout notification
      showNotification('Successfully logged out', 'success');
    }
    
    // =============================================
    // SUPABASE CONFIGURATION
    // =============================================
    const SUPABASE_URL = "https://cqjeoslchevewbufpyzv.supabase.co";
    const SUPABASE_KEY = "sb_publishable_PhMKOO9MpDZQIf5c624tiQ_AJPguAHp";
    
    // Initialize Supabase client
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

    // =============================================
    // CONSTANTS AND CONFIGURATION
    // =============================================
    const DAYS_ACTIVE = 2.99; // 0-2 days 23h 59m
    const INACTIVE_THRESHOLD = 15; // 15+ days
    const HIGH_RISK_MAX_DAYS = 15; // 5-14 days 23h 59m
    const RECENT_INACTIVE_MIN_DAYS = 3; // 3 days 0m
    const RECENT_INACTIVE_MAX_DAYS = 5; // 4 days 23h 59m
    const PLAYERS_PER_PAGE = 50;
    const AUTH_PIN = "8152";

    // Page data with emojis - UPDATED WITH PROPER CASE NAMES
    const PAGES = [
      { name: "Juwa Slots", emoji: "" },
      { name: "Jackpot Casino", emoji: "" },
      { name: "Milk+T", emoji: "" },
      { name: "Spin Royale", emoji: "" },
      { name: "Milky Treasure", emoji: "" },
      { name: "Legit Spin Casino", emoji: "" },
      { name: "Wealth Casino", emoji: "" },
      { name: "Cash Vault", emoji: "" },
      { name: "Game Vault Slots", emoji: "" },
      { name: "Lucky Firekirin", emoji: "" },
      { name: "Payout Day", emoji: "" },
      { name: "Ultra Panda", emoji: "" },
      { name: "Dragons Destiny", emoji: "" },
      { name: "Orion Star", emoji: "" },
      { name: "Daily Freebies", emoji: "" },
      { name: "Fortune Valley", emoji: "" },
      { name: "Grill Girl", emoji: "" },
      { name: "Earners Pick", emoji: "" },
      { name: "Juwa 2.0", emoji: "" },
      { name: "Panda Master", emoji: "" },
      { name: "Casino Royal", emoji: "" },
      { name: "Diamond Riches", emoji: "" },
      { name: "Cash Machine", emoji: "" },
      { name: "Win Star", emoji: "" },
      { name: "Fire Kirin", emoji: "" },
      { name: "Ruby Riches", emoji: "" },
      { name: "Vegas Sweeps", emoji: "" },
      { name: "Secret Spins", emoji: "" },
      { name: "Mega Money Machine", emoji: "" },
      { name: "Mystery Millions", emoji: "" },
      { name: "Mafia City", emoji: "" },
      { name: "VBlink", emoji: "" },
      { name: "Lucky Lady", emoji: "" },
      { name: "King of Pop", emoji: "" },
      { name: "Golden Treasure", emoji: "" },
      { name: "River Sweeps", emoji: "" },
      { name: "Game Room", emoji: "" },
      { name: "Oyshee", emoji: "" },
      { name: "Moolah", emoji: "" },
      { name: "Mega Spin", emoji: "" },
      { name: "Lucky Vegas Slots", emoji: "" },
      { name: "Yolo Slots", emoji: "" },
      { name: "Juwa", emoji: "" },
      { name: "River Monster", emoji: "" },
      { name: "E-Games", emoji: "" },
      { name: "Big Winner", emoji: "" }
    ];

    // Page name normalization mapping
    const PAGE_NAME_MAP = {
      "juwa slots": "Juwa Slots",
      "jackpot casino": "Jackpot Casino", 
      "milk+t": "Milk+T",
      "milk + t": "Milk+T",
      "spin royale": "Spin Royale",
      "milky treasure": "Milky Treasure",
      "legit spin casino": "Legit Spin Casino",
      "wealth casino": "Wealth Casino",
      "cash vault": "Cash Vault",
      "game vault slots": "Game Vault Slots",
      "lucky firekirin": "Lucky Firekirin",
      "payout day": "Payout Day",
      "ultra panda": "Ultra Panda",
      "dragons destiny": "Dragons Destiny",
      "orion star": "Orion Star",
      "daily freebies": "Daily Freebies",
      "fortune valley": "Fortune Valley",
      "grill girl": "Grill Girl",
      "earners pick": "Earners Pick",
      "juwa 2.0": "Juwa 2.0",
      "panda master": "Panda Master",
      "casino royal": "Casino Royal",
      "diamond riches": "Diamond Riches",
      "cash machine": "Cash Machine",
      "win star": "Win Star",
      "fire kirin": "Fire Kirin",
      "ruby riches": "Ruby Riches",
      "vegas sweeps": "Vegas Sweeps",
      "secret spins": "Secret Spins",
      "mega money machine": "Mega Money Machine",
      "mystery millions": "Mystery Millions",
      "mafia city": "Mafia City",
      "vblink": "VBlink",
      "lucky lady": "Lucky Lady",
      "king of pop": "King of Pop",
      "golden treasure": "Golden Treasure",
      "river sweeps": "River Sweeps",
      "game room": "Game Room",
      "oyshee": "Oyshee",
      "moolah": "Moolah",
      "mega spin": "Mega Spin",
      "lucky vegas slots": "Lucky Vegas Slots",
      "yolo slots": "Yolo Slots",
      "juwa": "Juwa",
      "river monster": "River Monster",
      "e-games": "E-Games",
      "e games": "E-Games",
      "egames": "E-Games",
      "big winner": "Big Winner"
    };

    // =============================================
    // FIXED: CORRECT STATUS CALCULATION LOGIC
    // =============================================
    function calculatePlayerStatus(daysSince) {
      if (daysSince <= DAYS_ACTIVE) {
        return "Active"; // 0-2 days 23h 59m
      } else if (daysSince >= INACTIVE_THRESHOLD) {
        return "Inactive"; // 15+ days
      } else if (daysSince >= RECENT_INACTIVE_MIN_DAYS && daysSince < RECENT_INACTIVE_MAX_DAYS) {
        return "Inactive"; // 3-4 days 23h 59m (but will appear in Recent Inactive section)
      } else if (daysSince >= 5 && daysSince < HIGH_RISK_MAX_DAYS) {
        return "Inactive"; // 5-14 days 23h 59m (but will appear in High Risk section)
      }
      return "Inactive"; // Default fallback
    }

    // =============================================
    // TIME CONVERSION UTILITIES - FIXED FOR PAKISTAN TIME
    // =============================================

    // Convert UTC to Pakistan Time (UTC+5) for display only
    function convertUTCToPKT(utcDateString) {
        if (!utcDateString) return 'N/A';
        
        try {
            const date = new Date(utcDateString);
            if (isNaN(date.getTime())) {
                console.error('Invalid date:', utcDateString);
                return 'Invalid Date';
            }
            
            // Convert to Pakistan Time (UTC+5)
            const pktOffset = 5 * 60 * 60 * 1000;
            const pktDate = new Date(date.getTime() + pktOffset);
            
            const day = String(pktDate.getUTCDate()).padStart(2, '0');
            const month = String(pktDate.getUTCMonth() + 1).padStart(2, '0');
            const year = pktDate.getUTCFullYear();
            
            let hours = pktDate.getUTCHours();
            const minutes = String(pktDate.getUTCMinutes()).padStart(2, '0');
            const seconds = String(pktDate.getUTCSeconds()).padStart(2, '0');
            
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12;
            const hours12 = String(hours).padStart(2, '0');
            
            return `${day}/${month}/${year}, ${hours12}:${minutes}:${seconds} ${ampm}`;
        } catch (error) {
            console.error('Error converting date to PKT:', error, utcDateString);
            return 'Date Error';
        }
    }

    // Convert UTC to Pakistan Time date only (DD/MM/YYYY)
    function convertUTCToPKTDateOnly(utcDateString) {
        if (!utcDateString) return 'N/A';
        
        try {
            const date = new Date(utcDateString);
            if (isNaN(date.getTime())) {
                return 'Invalid Date';
            }
            
            const pktOffset = 5 * 60 * 60 * 1000;
            const pktDate = new Date(date.getTime() + pktOffset);
            
            const day = String(pktDate.getUTCDate()).padStart(2, '0');
            const month = String(pktDate.getUTCMonth() + 1).padStart(2, '0');
            const year = pktDate.getUTCFullYear();
            
            return `${day}/${month}/${year}`;
        } catch (error) {
            console.error('Error converting date to PKT:', error);
            return 'Date Error';
        }
    }

    // Get current time in Pakistan Time
    function getCurrentPKT() {
        const now = new Date();
        const pktOffset = 5 * 60 * 60 * 1000;
        return new Date(now.getTime() + pktOffset);
    }

    // Format date as YYYY-MM-DD for grouping (using PKT timezone)
    function formatDateForGrouping(pktDate) {
        if (!pktDate) return '';
        const year = pktDate.getUTCFullYear();
        const month = String(pktDate.getUTCMonth() + 1).padStart(2, '0');
        const day = String(pktDate.getUTCDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    // Get start of day in PKT (00:00:00)
    function getStartOfDayPKT(date) {
        const pktDate = new Date(date);
        pktDate.setUTCHours(0, 0, 0, 0);
        return pktDate;
    }

    // Calculate time since last deposit in PKT - EXACT HOURS/DAYS
    function formatTimeSince(utcDateString) {
        if (!utcDateString) return 'N/A';
        
        try {
            const nowPKT = getCurrentPKT();
            const lastDepositUTC = new Date(utcDateString);
            const lastDepositPKT = new Date(lastDepositUTC.getTime() + (5 * 60 * 60 * 1000));
            
            if (isNaN(nowPKT.getTime()) || isNaN(lastDepositPKT.getTime())) {
                return 'N/A';
            }
            
            const diffMs = nowPKT - lastDepositPKT;
            
            if (diffMs < 0) {
                return 'Just now';
            }
            
            const hoursSince = Math.floor(diffMs / (1000 * 60 * 60));
            const minutesSince = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const daysSince = Math.floor(hoursSince / 24);
            const remainingHours = hoursSince % 24;
            const remainingMinutes = minutesSince % 60;
            
            if (daysSince === 0) {
                if (hoursSince === 0) {
                    return `${minutesSince} minutes ago`;
                } else {
                    return `${hoursSince} hours ${minutesSince} minutes ago`;
                }
            } else {
                if (remainingHours === 0) {
                    return `${daysSince} day${daysSince > 1 ? 's' : ''} ago`;
                } else {
                    return `${daysSince} day${daysSince > 1 ? 's' : ''} ${remainingHours} hour${remainingHours > 1 ? 's' : ''} ago`;
                }
            }
        } catch (error) {
            console.error('Error calculating time since:', error, utcDateString);
            return 'N/A';
        }
    }

    // FIXED VERSION: Calculate exact gap duration between two dates IN PKT TIME
function calculateExactGapDuration(startDate, endDate) {
    if (!startDate || !endDate) return '';
    
    try {
        // Both dates should already be in PKT
        const start = new Date(startDate);
        const end = new Date(endDate);
        
        if (isNaN(start.getTime()) || isNaN(end.getTime())) {
            return '';
        }
        
        // Calculate EXACT difference in milliseconds IN PKT
        const diffMs = end.getTime() - start.getTime();
        
        if (diffMs <= 0) return '';
        
        // Convert to hours, minutes
        const totalHours = Math.floor(diffMs / (1000 * 60 * 60));
        const totalMinutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
        const days = Math.floor(totalHours / 24);
        const hours = totalHours % 24;
        
        // For active deposit days (same day), return dash
        if (days === 0 && hours === 0 && totalMinutes === 0) {
            return '';
        }
        
        // Build the gap string
        let gapString = '';
        
        if (days > 0) {
            gapString += `${days} day${days > 1 ? 's' : ''}`;
        }
        
        if (hours > 0) {
            if (gapString) gapString += ' ';
            gapString += `${hours} hour${hours > 1 ? 's' : ''}`;
        }
        
        // Only show minutes if there are no days and hours < 2
        if (totalMinutes > 0 && days === 0 && hours < 2) {
            if (gapString) gapString += ' ';
            gapString += `${totalMinutes} minute${totalMinutes > 1 ? 's' : ''}`;
        }
        
        return gapString || '';
    } catch (error) {
        console.error('Error calculating gap duration:', error);
        return '';
    }
}
    // =============================================
    // STATE MANAGEMENT
    // =============================================
    let selectedPage = null;
    let currentPageData = null;
    let progressInterval = null;
    let currentView = 'dashboard';
    
    const tableState = {
        current: {
            type: null,
            page: 1,
            data: null,
            title: null
        },
        playerTables: {
            'Total': { page: 1, data: null },
            'Active': { page: 1, data: null },
            'Inactive': { page: 1, data: null },
            'RecentActive': { page: 1, data: null },
            'RecentInactive': { page: 1, data: null }
        },
        highRisk: { page: 1, data: null },
        history: { page: 1, data: null },
        deposits: { month: 0, data: null }
    };
    
    // Notes state
    let currentNotesPlayer = null;
    let currentNotesPlayerName = null;
    let currentNotesButton = null;

    // Navigation context tracking
    let navigationContext = 'landing';
    let currentPageObj = null;

    // =============================================
    // DOM ELEMENTS
    // =============================================
    const searchInput = document.getElementById('pageSelectSearch');
    const playerSearchInput = document.getElementById('playerSearchInput');
    const pageSuggestions = document.getElementById('pageSuggestions');
    const playerSuggestions = document.getElementById('playerSuggestions');
    const findBtn = document.getElementById('findBtn');
    const loader = document.getElementById('loader');
    const pageTitle = document.getElementById('pageTitle');
    const refreshBtn = document.getElementById('refreshDataBtn');
    const forceCleanupBtn = document.getElementById('forceCleanupBtn');
    const changePageBtn = document.getElementById('changePageBtn');
    const logoutBtnDashboard = document.getElementById('logoutBtnDashboard');
    const loadingProgress = document.getElementById('loadingProgress');
    const refreshModal = document.getElementById('refreshModal');
    const cleanupModal = document.getElementById('cleanupModal');
    const notesModal = document.getElementById('notesModal');
    const refreshPinInput = document.getElementById('refreshPinInput');
    const cleanupPinInput = document.getElementById('cleanupPinInput');
    const noteTextInput = document.getElementById('noteTextInput');
    const saveNoteBtn = document.getElementById('saveNoteBtn');
    const notesModalTitle = document.getElementById('notesModalTitle');
    const notesList = document.getElementById('notesList');
    const statsRow1 = document.getElementById('statsRow1');
    const statsRow2 = document.getElementById('statsRow2');
    const statsRow3 = document.getElementById('statsRow3');
    const pageDepositsView = document.getElementById('pageDepositsView');
    const landingLogoutSection = document.getElementById('landingLogoutSection');
    const logoutBtnLanding = document.getElementById('logoutBtnLanding');

    // =============================================
    // UTILITY FUNCTIONS
    // =============================================

    function normalizePageName(pageName) {
      if (!pageName || typeof pageName !== 'string') return pageName;
      
      const trimmedName = pageName.trim();
      const lowerName = trimmedName.toLowerCase();
      
      if (PAGE_NAME_MAP[lowerName]) {
        return PAGE_NAME_MAP[lowerName];
      }
      
      return lowerName
        .split(' ')
        .map(word => {
          if (word === '2.0') return '2.0';
          if (word === 't') return 'T';
          if (word === 'vblink') return 'VBlink';
          return word.charAt(0).toUpperCase() + word.slice(1);
        })
        .join(' ')
        .replace(/\s+\+\s+/g, '+')
        .replace(/Egames/g, 'E-Games');
    }

    function showNotification(message, type = 'success') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        if (document.body.contains(notification)) {
          document.body.removeChild(notification);
        }
      }, 5000);
    }

    function getPaginatedPlayers(players, page, pageSize) {
      const startIndex = (page - 1) * pageSize;
      const endIndex = startIndex + pageSize;
      return players.slice(startIndex, endIndex);
    }

    function renderPagination(totalPlayers, currentPage, pageSize, container, onPageChange) {
      const totalPages = Math.ceil(totalPlayers / pageSize);
      
      if (totalPages <= 1) return '';
      
      let html = `
        <div class="pagination-buttons">
      `;
      
      html += `<button class="pagination-btn" ${currentPage === 1 ? 'disabled' : ''} onclick="${onPageChange}(${currentPage - 1})">
                <i class="fas fa-chevron-left"></i>
              </button>`;
      
      const maxVisiblePages = 5;
      let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
      let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
      
      if (endPage - startPage + 1 < maxVisiblePages) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
      }
      
      for (let i = startPage; i <= endPage; i++) {
        html += `<button class="pagination-btn ${i === currentPage ? 'active' : ''}" onclick="${onPageChange}(${i})">${i}</button>`;
      }
      
      html += `<button class="pagination-btn" ${currentPage === totalPages ? 'disabled' : ''} onclick="${onPageChange}(${currentPage + 1})">
                <i class="fas fa-chevron-right"></i>
              </button>`;
      
      html += `</div>`;
      
      container.innerHTML = html;
    }

    // =============================================
    // PAGINATION HELPER FUNCTIONS (FIXED FOR ALL QUERIES)
    // =============================================

    // Helper function to fetch ALL rows from a table with pagination
    async function fetchAllRows(tableName, filters = {}, orderBy = null) {
      let allData = [];
      let currentPage = 0;
      const pageSize = 1000; // Supabase max per request
      let hasMore = true;
      
      console.log(`Fetching ALL rows from ${tableName} with filters:`, filters);
      
      while (hasMore) {
        let query = supabase
          .from(tableName)
          .select('*')
          .range(currentPage * pageSize, (currentPage + 1) * pageSize - 1);
        
        // Apply filters
        Object.keys(filters).forEach(key => {
          if (filters[key] !== undefined && filters[key] !== null) {
            query = query.eq(key, filters[key]);
          }
        });
        
        // Apply ordering if specified
        if (orderBy) {
          query = query.order(orderBy.field, { ascending: orderBy.ascending });
        }
        
        const { data, error } = await query;
        
        if (error) {
          console.error(`Error fetching page ${currentPage} from ${tableName}:`, error);
          throw error;
        }
        
        if (data && data.length > 0) {
          allData = [...allData, ...data];
          console.log(`Fetched page ${currentPage + 1}: ${data.length} rows (Total: ${allData.length})`);
          
          // Check if we got fewer than pageSize (means last page)
          if (data.length < pageSize) {
            hasMore = false;
            console.log(`Reached last page for ${tableName}. Total rows: ${allData.length}`);
          } else {
            currentPage++;
          }
        } else {
          hasMore = false;
          console.log(`No more data for ${tableName}. Total rows: ${allData.length}`);
        }
      }
      
      return allData;
    }

    // =============================================
    // SUPABASE DATA FUNCTIONS - ALL FIXED WITH PAGINATION
    // =============================================

    async function searchPlayers(searchTerm) {
      if (!searchTerm || searchTerm.length < 2) return [];
      
      try {
        // Fetch ALL players with pagination
        let allPlayers = [];
        let currentPage = 0;
        const pageSize = 1000;
        let hasMore = true;
        
        console.log(`Searching players for: "${searchTerm}"`);
        
        while (hasMore) {
          const { data, error } = await supabase
            .from('latest_status')
            .select('player_name, page_name')
            .ilike('player_name', `%${searchTerm}%`)
            .range(currentPage * pageSize, (currentPage + 1) * pageSize - 1);
          
          if (error) throw error;
          
          if (data && data.length > 0) {
            allPlayers = [...allPlayers, ...data];
            
            if (data.length < pageSize) {
              hasMore = false;
            } else {
              currentPage++;
            }
          } else {
            hasMore = false;
          }
        }
        
        console.log(`Total players found for search "${searchTerm}": ${allPlayers.length}`);
        
        const uniqueResults = [];
        const seen = new Set();
        
        allPlayers.forEach(result => {
          const key = `${result.player_name}||${result.page_name}`;
          if (!seen.has(key)) {
            seen.add(key);
            uniqueResults.push({
              name: result.player_name,
              page: result.page_name,
              displayName: `${result.player_name} - ${result.page_name}`
            });
          }
        });
        
        uniqueResults.sort((a, b) => {
          const nameCompare = a.name.localeCompare(b.name);
          if (nameCompare !== 0) return nameCompare;
          return a.page.localeCompare(b.page);
        });
        
        console.log(`Unique players after deduping: ${uniqueResults.length}`);
        return uniqueResults;
      } catch (error) {
        console.error('Error searching players:', error);
        showNotification('Error searching players', 'error');
        return [];
      }
    }

    async function getPageActivity(pageName) {
      try {
        // Get latest status for the page - this table might be pre-aggregated
        const { data: statusData, error: statusError } = await supabase
          .from('latest_status')
          .select('*')
          .eq('page_name', pageName);
        
        if (statusError) throw statusError;
        
        if (!statusData || statusData.length === 0) {
          return getEmptyPageData(pageName);
        }

        // Get deposit data for calculations - USING PAGINATION FIX
        const depositData = await computePlayerDeposits(pageName);

        const playersWithNotes = await getAllPlayersWithNotes(pageName);
        
        // Get status changes for this page to show in activity notes
        const { data: changesData } = await supabase
          .from('status_changes')
          .select('*')
          .eq('page_name', pageName)
          .order('change_date', { ascending: false })
          .limit(100);

        // Create a map of recent status changes per player
        const recentChanges = {};
        if (changesData) {
          changesData.forEach(change => {
            const key = change.player_name;
            if (!recentChanges[key]) {
              recentChanges[key] = change;
            }
          });
        }

        const resultPlayers = [];
        const recentActivePlayers = [];
        const recentInactivePlayers = [];
        
        statusData.forEach(player => {
          const playerName = player.player_name;
          const originalTimestamp = player.last_deposit_date;
          const lastDepositDisplay = convertUTCToPKT(originalTimestamp);
          
          // Calculate days since using UTC dates for consistency
          const nowUTC = new Date();
          const lastDepositUTC = new Date(originalTimestamp);
          const daysSince = Math.floor((nowUTC - lastDepositUTC) / (1000 * 60 * 60 * 24));
          
          // FIXED: Calculate status correctly based on business logic
          const status = calculatePlayerStatus(daysSince);
          
          const playerDeposits = depositData[playerName] || { total: 0, last7Days: 0 };
          
          // Enhanced activity notes with status change info
          let activityNotes = player.activity_notes || "";
          const recentChange = recentChanges[playerName];
          if (recentChange) {
            activityNotes += ` | Last status change: ${recentChange.old_status}  ${recentChange.new_status} on ${convertUTCToPKT(recentChange.change_date)}`;
          }
          
          const playerData = {
            player: playerName,
            lastDeposit: lastDepositDisplay,
            originalTimestamp: originalTimestamp,
            daysSince: daysSince,
            status: status,
            totalDeposit: playerDeposits.total,
            last7DaysDeposit: playerDeposits.last7Days,
            activityNotes: activityNotes,
            hasNotes: playersWithNotes[playerName] || false
          };
          
          resultPlayers.push(playerData);
          
          const recentActiveCheck = isRecentActiveOptimized(playerName, depositData);
          if (status === "Active" && recentActiveCheck.isRecentActive) {
            playerData.gapDays = recentActiveCheck.gapDays;
            recentActivePlayers.push(playerData);
          }
          
          // FIXED: Check for Recent Inactive players (3-4.99 days)
          if (status === "Inactive" && daysSince >= RECENT_INACTIVE_MIN_DAYS && daysSince < RECENT_INACTIVE_MAX_DAYS) {
            recentInactivePlayers.push(playerData);
          }
        });

        const highRiskData = await getHighRiskPlayers(pageName);
        const highRiskPlayers = highRiskData.highRiskPlayers || [];

        highRiskPlayers.forEach(player => {
          player.hasNotes = playersWithNotes[player.player] || false;
        });

        // Sort by original timestamp
        resultPlayers.sort((a, b) => new Date(b.originalTimestamp) - new Date(a.originalTimestamp));
        recentActivePlayers.sort((a, b) => new Date(b.originalTimestamp) - new Date(a.originalTimestamp));
        recentInactivePlayers.sort((a, b) => new Date(b.originalTimestamp) - new Date(a.originalTimestamp));
        highRiskPlayers.sort((a, b) => new Date(b.lastDeposit) - new Date(a.lastDeposit));

        // FIXED: Count calculations based on correct business logic
        const counts = {
          Total: resultPlayers.length,
          Active: resultPlayers.filter(p => p.status === "Active").length,
          Inactive: resultPlayers.filter(p => p.status === "Inactive" && p.daysSince >= INACTIVE_THRESHOLD).length,
          RecentActive: recentActivePlayers.length,
          RecentInactive: recentInactivePlayers.length,
          HighRisk: highRiskPlayers.length
        };

        return { 
          page: pageName, 
          counts, 
          players: resultPlayers, 
          recentActivePlayers, 
          recentInactivePlayers,
          highRiskPlayers: highRiskPlayers
        };
      } catch (error) {
        console.error('Error getting page activity:', error);
        showNotification('Error loading page data', 'error');
        return getEmptyPageData(pageName);
      }
    }

    function getEmptyPageData(pageName) {
      return {
        page: pageName, 
        counts: { Total: 0, Active: 0, Inactive: 0, RecentActive: 0, RecentInactive: 0, HighRisk: 0 }, 
        players: [], 
        recentActivePlayers: [], 
        recentInactivePlayers: [],
        highRiskPlayers: []
      };
    }

    async function computePlayerDeposits(pageName) {
      try {
        console.log(`Computing deposits for page: ${pageName}`);
        
        // FIXED: Use pagination helper to get ALL deposits
        const allDeposits = await fetchAllRows('deposits', { page_name: pageName }, { field: 'deposit_date', ascending: true });
        
        console.log(`Total deposits fetched for ${pageName}: ${allDeposits.length}`);
        
        if (allDeposits.length === 0) {
          return {};
        }
        
        const depositData = {};
        const todayUTC = new Date();
        const sevenDaysAgo = new Date(todayUTC.getTime() - (7 * 24 * 60 * 60 * 1000));
        
        allDeposits.forEach(deposit => {
          const playerName = deposit.player_name;
          const amount = parseFloat(deposit.amount) || 0;
          const depositDateUTC = new Date(deposit.deposit_date);
          
          if (!depositData[playerName]) {
            depositData[playerName] = { total: 0, last7Days: 0, deposits: [] };
          }
          
          depositData[playerName].total += amount;
          depositData[playerName].deposits.push(depositDateUTC);
          
          if (depositDateUTC >= sevenDaysAgo) {
            depositData[playerName].last7Days += amount;
          }
        });
        
        console.log(`Processed deposits for ${Object.keys(depositData).length} players`);
        return depositData;
        
      } catch (error) {
        console.error('Error in computePlayerDeposits:', error);
        return {};
      }
    }

    function isRecentActiveOptimized(playerName, depositData) {
      const playerData = depositData[playerName];
      
      if (!playerData || !playerData.deposits || playerData.deposits.length < 2) {
        return { isRecentActive: false, gapDays: null };
      }
      
      const deposits = playerData.deposits.sort((a, b) => b - a);
      
      const latest = deposits[0];
      const secondLatest = deposits[1];
      const gapHours = Math.floor((latest - secondLatest) / (1000 * 60 * 60));
      const gapDays = gapHours / 24;
      
      const todayUTC = new Date();
      const hoursSinceLatest = Math.floor((todayUTC - latest) / (1000 * 60 * 60));
      const daysSinceLatest = hoursSinceLatest / 24;
      
      const isRecentActive = gapDays >= 3 && daysSinceLatest <= DAYS_ACTIVE;
      
      return { 
        isRecentActive: isRecentActive, 
        gapDays: isRecentActive ? Math.floor(gapDays) : null 
      };
    }

    async function getAllPlayersWithNotes(pageName) {
      try {
        // FIXED: Use pagination helper
        const allNotes = await fetchAllRows('player_notes', { page_name: pageName });
        
        const playersWithNotes = {};
        allNotes.forEach(note => {
          playersWithNotes[note.player_name] = true;
        });
        
        console.log(`Players with notes on ${pageName}: ${Object.keys(playersWithNotes).length}`);
        return playersWithNotes;
      } catch (error) {
        console.error('Error getting players with notes:', error);
        return {};
      }
    }

    async function getPlayerNotes(pageName, playerName) {
      try {
        // FIXED: Use pagination helper
        const allNotes = await fetchAllRows('player_notes', { 
          page_name: pageName, 
          player_name: playerName 
        }, { field: 'created_at', ascending: false });
        
        return { 
          notes: allNotes.map(note => ({
            timestamp: note.created_at,
            note: note.note_text
          })), 
          success: true 
        };
      } catch (error) {
        console.error('Error getting player notes:', error);
        return { notes: [], success: false };
      }
    }

    async function addPlayerNote(pageName, playerName, noteText) {
      try {
        // Check if user has permission to add notes
        if (userRole === PIN_CONFIG.ROLES.VIEWER) {
          return { 
            success: false, 
            message: "Viewer role cannot add notes" 
          };
        }
        
        const { data, error } = await supabase
          .from('player_notes')
          .insert([
            {
              page_name: pageName,
              player_name: playerName,
              note_text: noteText,
              created_at: new Date().toISOString()
            }
          ])
          .select();
        
        if (error) throw error;
        
        return { 
          success: true, 
          message: "Note added successfully",
          timestamp: new Date().toISOString()
        };
      } catch (error) {
        console.error('Error adding player note:', error);
        return { success: false, message: "Error adding note: " + error.toString() };
      }
    }

    function groupDepositsByDay(deposits) {
      const depositsByDay = {};
      
      deposits.forEach(deposit => {
        const pktDate = new Date(deposit.getTime() + (5 * 60 * 60 * 1000));
        const dateKey = formatDateForGrouping(pktDate);
        
        if (!depositsByDay[dateKey]) {
          depositsByDay[dateKey] = {
            date: dateKey,
            deposits: [deposit],
            count: 1
          };
        } else {
          depositsByDay[dateKey].deposits.push(deposit);
          depositsByDay[dateKey].count++;
        }
      });
      
      return depositsByDay;
    }

    function calculateRiskLevel(totalGaps, maxGapDays) {
      if (totalGaps === 1 && maxGapDays < 15) {
        if (maxGapDays >= 12) return "Very High";
        if (maxGapDays >= 10) return "High";
        if (maxGapDays >= 8) return "Medium";
        if (maxGapDays >= 5) return "Low";
      }
      
      if (totalGaps >= 3 || maxGapDays >= 12) {
        return "Very High";
      } else if (totalGaps >= 2 || maxGapDays >= 10) {
        return "High";
      } else if (totalGaps >= 1 && maxGapDays >= 8) {
        return "Medium";
      } else {
        return "Low";
      }
    }

    async function getHighRiskPlayers(pageName) {
      try {
        console.log(`Getting high risk players for page: ${pageName}`);
        
        // FIXED: Use pagination helper to get ALL deposits
        const allDeposits = await fetchAllRows('deposits', { page_name: pageName }, { field: 'deposit_date', ascending: true });
        
        console.log(`Total deposits for high risk analysis: ${allDeposits.length}`);
        
        if (allDeposits.length === 0) {
          return { highRiskPlayers: [], message: "No deposit data available" };
        }
        
        const playerDeposits = {};
        const todayUTC = new Date();
        const fifteenDaysAgo = new Date(todayUTC.getTime() - (HIGH_RISK_MAX_DAYS * 24 * 60 * 60 * 1000));
        
        allDeposits.forEach(deposit => {
          const playerName = deposit.player_name;
          const depositDateUTC = new Date(deposit.deposit_date);
          
          if (!isNaN(depositDateUTC?.getTime()) && depositDateUTC >= fifteenDaysAgo) {
            if (!playerDeposits[playerName]) {
              playerDeposits[playerName] = [];
            }
            playerDeposits[playerName].push(depositDateUTC);
          }
        });

        console.log(`Players with deposits in last 15 days: ${Object.keys(playerDeposits).length}`);

        Object.keys(playerDeposits).forEach(player => {
          playerDeposits[player] = groupDepositsByDay(playerDeposits[player]);
        });

        const highRiskPlayers = [];
        const MIN_GAP_DAYS = 5;

        Object.keys(playerDeposits).forEach(player => {
          const depositsByDay = playerDeposits[player];
          const depositDates = Object.keys(depositsByDay).sort();
          
          if (depositDates.length === 0) return;

          const deposits = depositDates.map(date => {
            const dayData = depositsByDay[date];
            const latestDeposit = dayData.deposits.sort((a, b) => b - a)[0];
            return latestDeposit;
          }).sort((a, b) => a - b);
          
          if (deposits.length === 1) {
            const singleDepositDate = deposits[0];
            const hoursSinceSingleDeposit = Math.floor((todayUTC - singleDepositDate) / (1000 * 60 * 60));
            const daysSinceSingleDeposit = hoursSinceSingleDeposit / 24;
            
            if (daysSinceSingleDeposit >= MIN_GAP_DAYS && daysSinceSingleDeposit < HIGH_RISK_MAX_DAYS) {
              const currentStatus = daysSinceSingleDeposit <= DAYS_ACTIVE ? "Active" : "Inactive";
              
              highRiskPlayers.push({
                player: player,
                gaps: [{
                  gapDays: Math.floor(daysSinceSingleDeposit),
                  gapBetween: `Single activity day on ${convertUTCToPKTDateOnly(singleDepositDate.toISOString())}`
                }],
                totalQualifyingGaps: 1,
                maxGapDays: Math.floor(daysSinceSingleDeposit),
                lastDeposit: singleDepositDate.toISOString(),
                daysSinceLastDeposit: Math.floor(daysSinceSingleDeposit),
                currentStatus: currentStatus,
                totalDeposits: depositsByDay[depositDates[0]].count,
                riskLevel: calculateRiskLevel(1, Math.floor(daysSinceSingleDeposit)),
                depositType: "single"
              });
            }
            return;
          }
          
          const allGaps = [];
          const qualifyingGaps = [];
          
          for (let i = 0; i < deposits.length - 1; i++) {
            const currentDeposit = deposits[i];
            const nextDeposit = deposits[i + 1];
            const gapHours = Math.floor((nextDeposit - currentDeposit) / (1000 * 60 * 60));
            const gapDays = gapHours / 24;
            allGaps.push(gapDays);
            
            if (gapDays >= MIN_GAP_DAYS && gapDays < HIGH_RISK_MAX_DAYS) {
              qualifyingGaps.push({
                gapDays: Math.floor(gapDays),
                gapBetween: `${convertUTCToPKTDateOnly(currentDeposit.toISOString())} to ${convertUTCToPKTDateOnly(nextDeposit.toISOString())}`
              });
            }
          }
          
          const lastDepositDate = deposits[deposits.length - 1];
          const hoursSinceLastDeposit = Math.floor((todayUTC - lastDepositDate) / (1000 * 60 * 60));
          const daysSinceLastDeposit = hoursSinceLastDeposit / 24;
          
          if (daysSinceLastDeposit >= MIN_GAP_DAYS && daysSinceLastDeposit < HIGH_RISK_MAX_DAYS) {
            qualifyingGaps.push({
              gapDays: Math.floor(daysSinceLastDeposit),
              gapBetween: `${convertUTCToPKTDateOnly(lastDepositDate.toISOString())} to today`
            });
            allGaps.push(daysSinceLastDeposit);
          }
          
          const hasExcessiveGap = allGaps.some(gap => gap >= HIGH_RISK_MAX_DAYS);
          if (hasExcessiveGap) {
            return;
          }
          
          if (qualifyingGaps.length > 0) {
            const currentStatus = daysSinceLastDeposit <= DAYS_ACTIVE ? "Active" : "Inactive";
            const totalDepositCount = depositDates.reduce((sum, date) => sum + depositsByDay[date].count, 0);
            
            highRiskPlayers.push({
              player: player,
              gaps: qualifyingGaps,
              totalQualifyingGaps: qualifyingGaps.length,
              maxGapDays: Math.max(...qualifyingGaps.map(gap => gap.gapDays)),
              lastDeposit: lastDepositDate.toISOString(),
              daysSinceLastDeposit: Math.floor(daysSinceLastDeposit),
              currentStatus: currentStatus,
              totalDeposits: totalDepositCount,
              riskLevel: calculateRiskLevel(qualifyingGaps.length, Math.max(...qualifyingGaps.map(gap => gap.gapDays))),
              depositType: "multiple"
            });
          }
        });

        highRiskPlayers.sort((a, b) => new Date(b.lastDeposit) - new Date(a.lastDeposit));
        
        console.log(`High risk players found: ${highRiskPlayers.length}`);
        return {
          highRiskPlayers: highRiskPlayers,
          message: `Found ${highRiskPlayers.length} high risk players`
        };
        
      } catch (error) {
        console.error('Error getting high risk players:', error);
        return { highRiskPlayers: [], message: "Error loading high risk players: " + error.message };
      }
    }

    async function getEnhancedPlayerHistory(playerName, pageName) {
  try {
    console.log(`Getting enhanced history for player: ${playerName} on page: ${pageName}`);
    
    const allDeposits = await fetchAllRows('deposits', { 
      player_name: playerName, 
      page_name: pageName 
    }, { field: 'deposit_date', ascending: true });
    
    console.log(`Total deposits found for ${playerName}: ${allDeposits.length}`);
    
    if (!allDeposits || allDeposits.length === 0) {
      return { 
        enhancedHistory: [], 
        currentStatus: "Inactive",
        message: "No data found for this player",
        rawDeposits: 0,
        timeSinceDisplay: "N/A"
      };
    }

    // Convert ALL deposits to PKT with exact timestamps
    const playerDeposits = allDeposits.map(deposit => {
      const utcDate = new Date(deposit.deposit_date);
      const pktDate = new Date(utcDate.getTime() + (5 * 60 * 60 * 1000));
      
      return {
        utcDate: utcDate,
        pktDate: pktDate,
        displayDate: convertUTCToPKT(deposit.deposit_date),
        displayDateOnly: convertUTCToPKTDateOnly(deposit.deposit_date),
        amount: parseFloat(deposit.amount) || 0,
        originalDate: deposit.deposit_date,
        exactTimePKT: pktDate.getTime() // Exact timestamp in PKT
      };
    }).filter(deposit => !isNaN(deposit.utcDate.getTime()));

    playerDeposits.sort((a, b) => a.pktDate - b.pktDate);
    
    const nowPKT = getCurrentPKT();
    const mostRecentDeposit = playerDeposits[playerDeposits.length - 1];
    
    // Calculate time since last deposit (for display)
    const timeSinceMs = nowPKT - mostRecentDeposit.pktDate;
    const hoursSince = Math.floor(timeSinceMs / (1000 * 60 * 60));
    const minutesSince = Math.floor((timeSinceMs % (1000 * 60 * 60)) / (1000 * 60));
    const daysSince = hoursSince / 24;
    const remainingHours = hoursSince % 24;
    
    const currentStatus = calculatePlayerStatus(daysSince);

    let timeSinceDisplay = '';
    if (daysSince < 1) {
      if (hoursSince === 0) {
        timeSinceDisplay = `${minutesSince} minutes ago`;
      } else {
        timeSinceDisplay = `${hoursSince} hours ${minutesSince} minutes ago`;
      }
    } else {
      const fullDays = Math.floor(daysSince);
      if (remainingHours === 0) {
        timeSinceDisplay = `${fullDays} day${fullDays > 1 ? 's' : ''} ago`;
      } else {
        timeSinceDisplay = `${fullDays} day${fullDays > 1 ? 's' : ''} ${remainingHours} hour${remainingHours > 1 ? 's' : ''} ago`;
      }
    }

    // Group deposits by day, but keep track of LATEST deposit time each day
    const depositsByDay = {};
    playerDeposits.forEach(deposit => {
      const dateKey = deposit.displayDateOnly;
      
      if (!depositsByDay[dateKey]) {
        depositsByDay[dateKey] = {
          count: 0,
          totalAmount: 0,
          displayDate: dateKey,
          deposits: [],
          pktDate: deposit.pktDate,
          latestDepositTime: deposit.pktDate, // Track latest deposit time of the day
          exactTimePKT: deposit.exactTimePKT
        };
      }
      depositsByDay[dateKey].count++;
      depositsByDay[dateKey].totalAmount += deposit.amount;
      depositsByDay[dateKey].deposits.push(deposit);
      
      // Update latest deposit time if this deposit is later
      if (deposit.pktDate > depositsByDay[dateKey].latestDepositTime) {
        depositsByDay[dateKey].latestDepositTime = deposit.pktDate;
        depositsByDay[dateKey].exactTimePKT = deposit.exactTimePKT;
      }
    });

    const enhancedHistory = [];
    const depositDates = Object.keys(depositsByDay).sort((a, b) => {
      return depositsByDay[a].pktDate - depositsByDay[b].pktDate;
    });
    
    if (depositDates.length === 0) {
      return {
        enhancedHistory: [],
        currentStatus: "Inactive",
        message: "No deposit data available",
        rawDeposits: 0,
        timeSinceDisplay: "N/A"
      };
    }

    // Build timeline with EXACT deposit times
    const timeline = [];
    const firstDepositDate = new Date(depositsByDay[depositDates[0]].pktDate);
    const lastDepositDate = new Date(depositsByDay[depositDates[depositDates.length - 1]].pktDate);
    
    let currentDate = new Date(firstDepositDate);
    currentDate.setUTCHours(0, 0, 0, 0);
    
    const todayPKT = getStartOfDayPKT(nowPKT);
    
    // Build day-by-day timeline
    while (currentDate <= todayPKT) {
      const dateKey = convertUTCToPKTDateOnly(currentDate.toISOString());
      const dayData = depositsByDay[dateKey];
      
      if (dayData) {
        // This is a deposit day
        timeline.push({
          date: new Date(currentDate),
          dateKey: dateKey,
          isDepositDay: true,
          depositCount: dayData.count,
          totalAmount: dayData.totalAmount,
          displayDate: dateKey,
          deposits: dayData.deposits,
          pktDate: currentDate.getTime(),
          latestDepositTime: dayData.latestDepositTime, // EXACT time of last deposit that day
          exactTimePKT: dayData.exactTimePKT
        });
      } else {
        // This is a non-deposit day
        timeline.push({
          date: new Date(currentDate),
          dateKey: dateKey,
          isDepositDay: false,
          depositCount: 0,
          totalAmount: 0,
          displayDate: dateKey,
          deposits: [],
          pktDate: currentDate.getTime(),
          latestDepositTime: null,
          exactTimePKT: null
        });
      }
      
      currentDate.setDate(currentDate.getDate() + 1);
      currentDate.setUTCHours(0, 0, 0, 0);
    }

    // Build enhanced history with EXACT gap calculations
    let i = 0;
    while (i < timeline.length) {
      const currentDay = timeline[i];
      
      if (currentDay.isDepositDay) {
        // Determine activity level
        let activityLevel = "Normal";
        if (currentDay.depositCount > 4 || currentDay.totalAmount > 50) {
          activityLevel = "High";
        }
        
        const depositText = currentDay.depositCount === 1 
          ? "1 deposit" 
          : `${currentDay.depositCount} deposits`;
        
        const amountText = currentDay.totalAmount > 0 
          ? ` ($${currentDay.totalAmount.toFixed(2)})` 
          : "";
        
        enhancedHistory.push({
          dateRange: currentDay.displayDate,
          activity: `${depositText}${amountText}`,
          status: "Active",
          inactiveGap: 0,
          activityLevel: activityLevel,
          depositCount: currentDay.depositCount,
          totalAmount: currentDay.totalAmount,
          isDepositDay: true,
          timestamp: currentDay.pktDate,
          exactDepositTime: currentDay.latestDepositTime, // Store exact time
          gapDuration: ""
        });
        i++;
      } else {
        let inactiveStart = i;
        let inactiveCount = 0;
        let startDay = timeline[inactiveStart];
        
        // Find previous deposit day for exact time reference
        let previousDepositTime = null;
        for (let j = inactiveStart - 1; j >= 0; j--) {
          if (timeline[j].isDepositDay) {
            previousDepositTime = timeline[j].latestDepositTime;
            break;
          }
        }
        
        // If no previous deposit found (shouldn't happen), use start of day
        if (!previousDepositTime) {
          previousDepositTime = new Date(startDay.date);
          previousDepositTime.setUTCHours(0, 0, 0, 0);
          previousDepositTime = new Date(previousDepositTime.getTime() + (5 * 60 * 60 * 1000));
        }
        
        while (i < timeline.length && !timeline[i].isDepositDay) {
          inactiveCount++;
          i++;
        }
        
        // Calculate gap using EXACT TIMES
        let endTimePKT;
        if (i < timeline.length) {
          // Next deposit day - use its exact deposit time
          endTimePKT = timeline[i].latestDepositTime;
        } else {
          // Current PKT time
          endTimePKT = nowPKT;
        }
        
        // Calculate exact gap from last deposit to next deposit/now
        const gapDuration = calculateExactGapDuration(previousDepositTime, endTimePKT);
        
        if (inactiveCount === 1) {
          enhancedHistory.push({
            dateRange: timeline[inactiveStart].displayDate,
            activity: "No deposits",
            status: "Inactive",
            inactiveGap: inactiveCount,
            activityLevel: "None",
            depositCount: 0,
            totalAmount: 0,
            isDepositDay: false,
            timestamp: timeline[inactiveStart].pktDate,
            gapDuration: gapDuration
          });
        } else {
          const startDateStr = timeline[inactiveStart].displayDate;
          const endDateStr = timeline[i - 1].displayDate;
          enhancedHistory.push({
            dateRange: `${startDateStr} - ${endDateStr}`,
            activity: "No deposits",
            status: "Inactive",
            inactiveGap: inactiveCount,
            activityLevel: "None",
            depositCount: 0,
            totalAmount: 0,
            isDepositDay: false,
            timestamp: timeline[inactiveStart].pktDate,
            gapDuration: gapDuration
          });
        }
      }
    }

    const totalDepositDays = Object.keys(depositsByDay).length;
    const totalDepositCount = playerDeposits.length;
    const totalAmount = playerDeposits.reduce((sum, deposit) => sum + deposit.amount, 0);

    return {
      enhancedHistory: enhancedHistory,
      currentStatus: currentStatus,
      rawDeposits: totalDepositCount,
      totalDepositDays: totalDepositDays,
      totalAmount: totalAmount,
      timeSinceDisplay: timeSinceDisplay,
      message: `Found ${totalDepositCount} deposit(s) across ${totalDepositDays} day(s) from ${depositDates[0]} to ${depositDates[depositDates.length - 1]}`
    };
  } catch (error) {
    console.error('Error getting enhanced player history:', error);
    return { 
      enhancedHistory: [], 
      currentStatus: "Inactive",
      message: "Error loading player history",
      rawDeposits: 0,
      timeSinceDisplay: "N/A"
    };
  }
}

    async function getPageDailyDeposits(pageName, monthOffset = 0) {
      try {
        console.log(`Getting daily deposits for page: ${pageName}, month offset: ${monthOffset}`);
        
        // FIXED: Use pagination helper to get ALL deposits
        const allDeposits = await fetchAllRows('deposits', { page_name: pageName }, { field: 'deposit_date', ascending: true });
        
        console.log(`Total deposits fetched for ${pageName}: ${allDeposits.length}`);
        
        if (allDeposits.length === 0) {
          return {
            success: false,
            message: "No deposit data found",
            dailyDeposits: [],
            totalAmount: 0,
            totalTransactions: 0,
            monthlyComparison: null,
            availableMonths: []
          };
        }
        
        const processedDeposits = allDeposits.map(deposit => {
          const utcDate = new Date(deposit.deposit_date);
          const pktDate = new Date(utcDate.getTime() + (5 * 60 * 60 * 1000));
          const dateKey = formatDateForGrouping(pktDate);
          const displayDate = convertUTCToPKTDateOnly(deposit.deposit_date);
          const monthKey = pktDate.toISOString().substring(0, 7);
          
          return {
            utcDate: utcDate,
            pktDate: pktDate,
            dateKey: dateKey,
            displayDate: displayDate,
            monthKey: monthKey,
            amount: parseFloat(deposit.amount) || 0,
            player_name: deposit.player_name
          };
        }).filter(deposit => deposit.amount > 0);

        if (processedDeposits.length === 0) {
          return {
            success: false,
            message: "No deposit data with positive amounts",
            dailyDeposits: [],
            totalAmount: 0,
            totalTransactions: 0,
            monthlyComparison: null,
            availableMonths: []
          };
        }

        console.log(`Processed deposits with positive amounts: ${processedDeposits.length}`);

        const depositsByDay = {};
        processedDeposits.forEach(deposit => {
          if (!depositsByDay[deposit.dateKey]) {
            depositsByDay[deposit.dateKey] = {
              date: deposit.dateKey,
              displayDate: deposit.displayDate,
              monthKey: deposit.monthKey,
              totalAmount: 0,
              transactionCount: 0,
              timestamp: deposit.pktDate.getTime()
            };
          }
          depositsByDay[deposit.dateKey].totalAmount += deposit.amount;
          depositsByDay[deposit.dateKey].transactionCount++;
        });

        const allMonths = new Set();
        Object.values(depositsByDay).forEach(day => {
          allMonths.add(day.monthKey);
        });
        
        const sortedMonths = Array.from(allMonths).sort().reverse();
        const availableMonths = sortedMonths.map((month, index) => ({
          month: month,
          display: new Date(month + '-01').toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
          page: index + 1
        }));
        
        console.log(`Available months: ${sortedMonths.length}`, sortedMonths);
        
        if (sortedMonths.length === 0) {
          return {
            success: false,
            message: "No deposit data available",
            dailyDeposits: [],
            totalAmount: 0,
            totalTransactions: 0,
            monthlyComparison: null,
            availableMonths: []
          };
        }
        
        const currentMonthIndex = Math.min(monthOffset, sortedMonths.length - 1);
        const currentMonth = sortedMonths[currentMonthIndex];
        const previousMonth = currentMonthIndex + 1 < sortedMonths.length ? sortedMonths[currentMonthIndex + 1] : null;
        
        const currentMonthDeposits = Object.values(depositsByDay).filter(day => day.monthKey === currentMonth);
        
        const getDaysInMonth = (year, month) => {
          const monthDays = {
            1: 31,
            2: 28,
            3: 31,
            4: 30,
            5: 31,
            6: 30,
            7: 31,
            8: 31,
            9: 30,
            10: 31,
            11: 30,
            12: 31
          };
          
          if (month === 2) {
            const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
            return isLeapYear ? 29 : 28;
          }
          
          return monthDays[month] || 30;
        };
        
        const [year, month] = currentMonth.split('-').map(Number);
        const daysInMonth = getDaysInMonth(year, month);
        
        const currentMonthStart = new Date(Date.UTC(year, month - 1, 1, 0, 0, 0));
        const currentMonthEnd = new Date(Date.UTC(year, month - 1, daysInMonth, 23, 59, 59));
        
        const nowPKT = getCurrentPKT();
        const today = getStartOfDayPKT(nowPKT);
        
        const isCurrentMonth = currentMonth === formatDateForGrouping(nowPKT).substring(0, 7);
        
        let actualEndDate;
        if (isCurrentMonth) {
          actualEndDate = today;
        } else {
          actualEndDate = new Date(Date.UTC(year, month - 1, daysInMonth, 0, 0, 0));
        }
        
        const dailyDataMap = {};
        currentMonthDeposits.forEach(day => {
          dailyDataMap[day.date] = day;
        });
        
        const dailyDepositsArray = [];
        
        let currentDate = new Date(currentMonthStart);
        
        for (let day = 1; day <= daysInMonth; day++) {
          const utcDate = new Date(Date.UTC(year, month - 1, day, 12, 0, 0));
          const pktDate = new Date(utcDate.getTime() + (5 * 60 * 60 * 1000));
          const dateKey = formatDateForGrouping(pktDate);
          const displayDate = convertUTCToPKTDateOnly(utcDate.toISOString());
          
          const shouldInclude = isCurrentMonth ? 
            pktDate.getUTCFullYear() <= nowPKT.getUTCFullYear() && 
            pktDate.getUTCMonth() <= nowPKT.getUTCMonth() && 
            pktDate.getUTCDate() <= nowPKT.getUTCDate() : 
            true;
          
          if (shouldInclude) {
            if (dailyDataMap[dateKey]) {
              dailyDepositsArray.push(dailyDataMap[dateKey]);
            } else {
              dailyDepositsArray.push({
                date: dateKey,
                displayDate: displayDate,
                monthKey: currentMonth,
                totalAmount: 0,
                transactionCount: 0,
                timestamp: pktDate.getTime()
              });
            }
          }
        }
        
        dailyDepositsArray.sort((a, b) => b.timestamp - a.timestamp);
        
        console.log(`Daily deposits for ${currentMonth}: ${dailyDepositsArray.length} days`);
        
        const dailyDepositsWithTrends = dailyDepositsArray.map((day, index) => {
          let trend = null;
          
          if (index < dailyDepositsArray.length - 1) {
            const previousDay = dailyDepositsArray[index + 1];
            
            if (previousDay.totalAmount > 0 || day.totalAmount > 0) {
              const difference = day.totalAmount - previousDay.totalAmount;
              let percentage = 0;
              
              if (previousDay.totalAmount === 0 && day.totalAmount > 0) {
                percentage = 100;
              } else if (previousDay.totalAmount > 0) {
                percentage = (difference / previousDay.totalAmount) * 100;
              }
              
              trend = {
                difference: difference,
                percentage: percentage.toFixed(1),
                direction: difference > 0 ? 'up' : difference < 0 ? 'down' : 'same'
              };
            }
          }
          
          return {
            ...day,
            trend: trend
          };
        });
        
        const currentMonthTotal = dailyDepositsWithTrends.reduce((sum, day) => sum + day.totalAmount, 0);
        const currentMonthTransactions = dailyDepositsWithTrends.reduce((sum, day) => sum + day.transactionCount, 0);
        const totalDaysInPeriod = dailyDepositsWithTrends.length;
        const dailyAverage = totalDaysInPeriod > 0 ? currentMonthTotal / totalDaysInPeriod : 0;
        
        console.log(`Month ${currentMonth} summary: Total=$${currentMonthTotal.toFixed(2)}, Transactions=${currentMonthTransactions}, Days=${totalDaysInPeriod}`);
        
        let previousMonthTotal = 0;
        let previousMonthTransactions = 0;
        let monthlyComparison = null;
        
        if (previousMonth) {
          Object.values(depositsByDay).forEach(day => {
            if (day.monthKey === previousMonth) {
              previousMonthTotal += day.totalAmount;
              previousMonthTransactions += day.transactionCount;
            }
          });
          
          const monthlyDifference = currentMonthTotal - previousMonthTotal;
          let monthlyPercentage = 0;
          
          if (previousMonthTotal > 0) {
            monthlyPercentage = (monthlyDifference / previousMonthTotal) * 100;
          } else if (currentMonthTotal > 0) {
            monthlyPercentage = 100;
          }
          
          monthlyComparison = {
            previousMonth: new Date(previousMonth + '-01').toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
            previousMonthTotal: previousMonthTotal,
            previousMonthTransactions: previousMonthTransactions,
            difference: monthlyDifference,
            percentage: monthlyPercentage.toFixed(1),
            direction: monthlyDifference > 0 ? 'up' : monthlyDifference < 0 ? 'down' : 'same'
          };
          
          console.log(`Monthly comparison: ${currentMonth} vs ${previousMonth}: ${monthlyDifference > 0 ? '+' : ''}$${monthlyDifference.toFixed(2)} (${monthlyPercentage.toFixed(1)}%)`);
        }
        
        return {
          success: true,
          dailyDeposits: dailyDepositsWithTrends,
          totalAmount: currentMonthTotal,
          totalTransactions: currentMonthTransactions,
          dailyAverage: dailyAverage,
          totalDaysInPeriod: totalDaysInPeriod,
          monthlyComparison: monthlyComparison,
          currentMonth: new Date(currentMonth + '-01').toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
          availableMonths: availableMonths,
          currentPage: currentMonthIndex + 1,
          totalPages: sortedMonths.length,
          message: `Showing ${totalDaysInPeriod} days for ${new Date(currentMonth + '-01').toLocaleDateString('en-US', { month: 'short', year: 'numeric' })} - Total transactions: ${currentMonthTransactions}`
        };
      } catch (error) {
        console.error('Error getting page daily deposits:', error);
        return {
          success: false,
          message: "Error loading daily deposits: " + error.message,
          dailyDeposits: [],
          totalAmount: 0,
          totalTransactions: 0,
          monthlyComparison: null,
          availableMonths: []
        };
      }
    }

    // =============================================
    // UI FUNCTIONS
    // =============================================

    // Initialize on load
    document.addEventListener('DOMContentLoaded', function() {
      initializeApp();
    });

    function initializeApp() {
      // Start with PIN system
      initPinSystem();
      setupLogoutButton();
    }

    function showLandingPage() {
      clearAllSearchInputs();
      clearPlayerHistory();
      
      sessionStorage.removeItem('currentPage');
      sessionStorage.removeItem('currentView');
      
      navigationContext = 'landing';
      
      document.getElementById('dashboard').style.display = 'none';
      document.getElementById('landing').style.display = 'flex';
      
      // Show/hide logout button based on authentication
      const isAuthenticated = sessionStorage.getItem('pinAuthenticated') === 'true';
      
      if (landingLogoutSection) {
        landingLogoutSection.style.display = isAuthenticated ? 'block' : 'none';
      }
      
      if (logoutBtnLanding) {
        logoutBtnLanding.disabled = false; // Enable logout button on landing page
      }
      
      currentView = 'landing';
    }

    function loadDashboard(pageObj) {
      selectedPage = pageObj.name;
      currentPageObj = pageObj;
      sessionStorage.setItem('currentPage', selectedPage);
      sessionStorage.setItem('currentView', 'dashboard');
      
      navigationContext = 'dashboard';
      
      clearPlayerHistory();
      
      document.getElementById('landing').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      
      // Show logout button in dashboard
      if (logoutBtnDashboard) {
        logoutBtnDashboard.style.display = 'inline-flex';
      }
      
      updatePageTitle();
      
      showLoader();
      disableControlButtons();
      loadDashboardData();
    }

    function updatePageTitle() {
      if (currentPageObj) {
        pageTitle.textContent = `${currentPageObj.name} ${currentPageObj.emoji} - Analytics Dashboard`;
      } else if (selectedPage) {
        const pageObj = PAGES.find(p => p.name === selectedPage);
        if (pageObj) {
          currentPageObj = pageObj;
          pageTitle.textContent = `${pageObj.name} ${pageObj.emoji} - Analytics Dashboard`;
        } else {
          pageTitle.textContent = `${selectedPage} - Analytics Dashboard`;
        }
      }
    }

    async function loadDashboardData() {
      if (!selectedPage) return;
      
      showLoader();
      clearBackContainer();
      disableControlButtons();
      
      try {
        const data = await getPageActivity(selectedPage);
        handleDashboardData(data);
      } catch (error) {
        handleDataError(error);
      }
    }

    function handleDashboardData(data) {
      hideLoader();
      currentPageData = data;
      renderDashboard(data);
      currentView = 'dashboard';
      sessionStorage.setItem('currentView', 'dashboard');
      enableControlButtons();
    }

    function handleDataError(error) {
      hideLoader();
      showNotification('Error loading data: ' + error, 'error');
      document.getElementById('dashboard').style.display = 'block';
      enableControlButtons();
    }

    function showLoader() {
      loader.style.display = 'block';
      document.getElementById('dashboardBoxes').style.display = 'none';
      document.getElementById('tableContainer').innerHTML = '';
      document.getElementById('playerHistorySection').style.display = 'none';
      document.getElementById('globalPlayerHistorySection').style.display = 'none';
      document.getElementById('backContainer').innerHTML = '';
      pageDepositsView.style.display = 'none';
    }

    function hideLoader() {
      loader.style.display = 'none';
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
    }

    function disableControlButtons() {
      changePageBtn.disabled = true;
      refreshBtn.disabled = true;
      forceCleanupBtn.disabled = true;
      if (logoutBtnDashboard) logoutBtnDashboard.disabled = true;
      if (logoutBtnLanding) logoutBtnLanding.disabled = true;
    }

    function enableControlButtons() {
      changePageBtn.disabled = false;
      refreshBtn.disabled = false;
      forceCleanupBtn.disabled = false;
      if (logoutBtnDashboard) logoutBtnDashboard.disabled = false;
      if (logoutBtnLanding) logoutBtnLanding.disabled = false;
    }

    function clearBackContainer() {
      document.getElementById('backContainer').innerHTML = '';
    }

    function clearPlayerHistory() {
      const playerSearchInput = document.getElementById('playerSearch');
      const playerHistoryContainer = document.getElementById('playerHistoryContainer');
      const globalPlayerHistoryContainer = document.getElementById('globalPlayerHistoryContainer');
      
      if (playerSearchInput) playerSearchInput.value = '';
      if (playerHistoryContainer) playerHistoryContainer.innerHTML = '';
      if (globalPlayerHistoryContainer) globalPlayerHistoryContainer.innerHTML = '';
    }

    function clearAllSearchInputs() {
      const playerSearchInput = document.getElementById('playerSearch');
      const playerSearchLanding = document.getElementById('playerSearchInput');
      const pageSearchInput = document.getElementById('pageSelectSearch');
      
      if (playerSearchInput) playerSearchInput.value = '';
      if (playerSearchLanding) playerSearchLanding.value = '';
      if (pageSearchInput) pageSearchInput.value = '';
      
      const pageSuggestions = document.getElementById('pageSuggestions');
      const playerSuggestions = document.getElementById('playerSuggestions');
      
      if (pageSuggestions) pageSuggestions.innerHTML = '';
      if (playerSuggestions) playerSuggestions.innerHTML = '';
      
      const findBtn = document.getElementById('findBtn');
      if (findBtn) findBtn.style.display = 'none';
    }

    // Page search functionality
    searchInput.addEventListener('input', function() {
      const val = this.value.toLowerCase().trim();
      pageSuggestions.innerHTML = '';
      findBtn.style.display = 'none';
      
      if (!val) return;
      
      const matches = PAGES.filter(p => p.name.toLowerCase().includes(val));
      if (matches.length === 0) {
        const div = document.createElement('div');
        div.className = 'suggestion-item';
        div.innerHTML = '<span class="page-emoji"></span> No results found';
        pageSuggestions.appendChild(div);
      } else {
        matches.forEach(p => {
          const div = document.createElement('div');
          div.className = 'suggestion-item';
          div.innerHTML = `
            <span class="page-emoji">${p.emoji}</span>
            <span>${p.name}</span>
          `;
          div.onclick = () => {
            searchInput.value = p.name;
            pageSuggestions.innerHTML = '';
            findBtn.style.display = 'inline-flex';
          };
          pageSuggestions.appendChild(div);
        });
        if (matches.length === 1) {
          findBtn.style.display = 'inline-flex';
        }
      }
    });

    // Player search functionality for LANDING PAGE (All Pages)
    playerSearchInput.addEventListener('input', async function() {
      const val = this.value.toLowerCase().trim();
      playerSuggestions.innerHTML = '';
      
      if (!val || val.length < 2) return;
      
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'suggestion-item';
      loadingDiv.innerHTML = '<span class="page-emoji"></span> Searching players across all pages...';
      playerSuggestions.appendChild(loadingDiv);
      
      try {
        const players = await searchPlayers(val);
        playerSuggestions.innerHTML = '';
        
        if (!players || players.length === 0) {
          const div = document.createElement('div');
          div.className = 'suggestion-item';
          div.innerHTML = '<span class="page-emoji"></span> No players found';
          playerSuggestions.appendChild(div);
          return;
        }
        
        players.forEach(player => {
          const div = document.createElement('div');
          div.className = 'suggestion-item';
          
          const pageObj = PAGES.find(p => p.name === player.page);
          const pageEmoji = pageObj ? pageObj.emoji : '';
          
          div.innerHTML = `
            <span class="page-emoji">${pageEmoji}</span>
            <div style="flex: 1; min-width: 0;">
              <div style="font-weight: 500; margin-bottom: 0.25rem;">${player.name}</div>
              <div style="font-size: 0.875rem; color: var(--text-secondary);">
                <span class="page-indicator">${player.page}</span>
              </div>
            </div>
          `;
          
          div.onclick = () => {
            sessionStorage.setItem('searchPlayerName', player.name);
            sessionStorage.setItem('searchPlayerPage', player.page);
            tableState.history.page = 1;
            showEnhancedGlobalPlayerHistory(player.name, player.page);
          };
          
          playerSuggestions.appendChild(div);
        });
      } catch (error) {
        playerSuggestions.innerHTML = '';
        const div = document.createElement('div');
        div.className = 'suggestion-item';
        div.innerHTML = '<span class="page-emoji"></span> Error searching players';
        playerSuggestions.appendChild(div);
      }
    });

    async function showEnhancedGlobalPlayerHistory(playerName, pageName) {
      document.getElementById('landing').style.display = 'none';
      document.getElementById('dashboard').style.display = 'block';
      
      showLoader();
      disableControlButtons();
      
      document.getElementById('dashboardBoxes').style.display = 'none';
      document.getElementById('tableContainer').style.display = 'none';
      document.getElementById('playerHistorySection').style.display = 'none';
      document.getElementById('globalPlayerHistorySection').style.display = 'block';
      document.getElementById('backContainer').innerHTML = '';
      pageDepositsView.style.display = 'none';
      
      pageTitle.textContent = `Enhanced Player History: ${playerName}`;
      
      showLoadingProgress();
      
      try {
        const data = await getEnhancedPlayerHistory(playerName, pageName);
        hideLoader();
        const backDiv = document.getElementById('backContainer');
        backDiv.innerHTML = '<button class="btn btn-secondary" onclick="backToLanding()"><i class="fas fa-arrow-left"></i> Back to Search</button>';
        renderEnhancedPlayerHistory(data, playerName, pageName, true);
      } catch (error) {
        hideLoader();
        showNotification('Error loading enhanced player history: ' + error, 'error');
        document.getElementById('globalPlayerHistoryContainer').innerHTML = 
          `<div style="text-align: center; padding: 2rem; color: var(--danger);">
            <p>Error loading enhanced history for ${playerName}</p>
            <p style="margin-top: 1rem; color: var(--text-secondary);">${error}</p>
          </div>`;
      }
    }

    async function findPlayerForCurrentPage() {
      const playerName = document.getElementById('playerSearch').value.trim();
      if (!playerName) {
        showNotification('Please enter a player name', 'error');
        return;
      }
      
      sessionStorage.setItem('currentSearchedPlayer', playerName);
      tableState.history.page = 1;
      
      document.getElementById('playerHistoryContainer').innerHTML = `
        <div style="text-align: center; padding: 2rem;">
          <div class="spinner"></div>
          <p style="margin-top: 1rem; color: var(--text-secondary);">Loading enhanced player history for <strong>${playerName}</strong>...</p>
        </div>
      `;
      
      navigationContext = 'dashboard';
      
      try {
        const players = await searchPlayers(playerName);
        if (players && players.length > 0) {
          const currentPagePlayers = players.filter(player => 
            player.page === selectedPage && player.name === playerName
          );
          
          if (currentPagePlayers.length > 0) {
            const player = currentPagePlayers[0];
            showEnhancedPlayerHistoryForCurrentPage(player.name, selectedPage);
          } else {
            document.getElementById('playerHistoryContainer').innerHTML = `
              <div style="text-align: center; padding: 2rem; color: var(--danger);">
                <p><strong>Player "${playerName}" not found on ${selectedPage}</strong></p>
                <p style="margin-top: 1rem; color: var(--text-secondary);">Please try searching for a different player or check the spelling/capitalization.</p>
                <p style="margin-top: 0.5rem; color: var(--text-secondary); font-size: 0.875rem;">
                  Note: Player names are case-sensitive. "Gone Reed" and "GOne Reed" are different players.
                </p>
              </div>
            `;
          }
        } else {
          document.getElementById('playerHistoryContainer').innerHTML = `
            <div style="text-align: center; padding: 2rem; color: var(--danger);">
              <p><strong>Player "${playerName}" not found</strong></p>
              <p style="margin-top: 1rem; color: var(--text-secondary);">Please try searching for a different player.</p>
            </div>
          `;
        }
      } catch (error) {
        document.getElementById('playerHistoryContainer').innerHTML = `
          <div style="text-align: center; padding: 2rem; color: var(--danger);">
            <p><strong>Error searching player: ${error}</strong></p>
            <p style="margin-top: 1rem; color: var(--text-secondary);">Please try again.</p>
          </div>
        `;
      }
    }

    async function showEnhancedPlayerHistoryForCurrentPage(playerName, pageName) {
      const searchedPlayerName = sessionStorage.getItem('currentSearchedPlayer') || playerName;
      
      document.getElementById('playerHistoryContainer').innerHTML = `
        <div style="text-align: center; padding: 2rem;">
          <div class="spinner"></div>
          <p style="margin-top: 1rem; color: var(--text-secondary);">Loading enhanced player history for <strong>${searchedPlayerName}</strong>...</p>
        </div>
      `;
      
      try {
        const data = await getEnhancedPlayerHistory(playerName, pageName);
        renderEnhancedPlayerHistory(data, searchedPlayerName, pageName, false);
      } catch (error) {
        document.getElementById('playerHistoryContainer').innerHTML = 
          `<div style="text-align: center; padding: 2rem; color: var(--danger);">
            <p><strong>Error loading enhanced history for ${searchedPlayerName}</strong></p>
            <p style="margin-top: 1rem; color: var(--text-secondary);">${error}</p>
          </div>`;
      }
    }

    function findData() {
      const val = searchInput.value.trim();
      const pageObj = PAGES.find(p => p.name.toLowerCase() === val.toLowerCase());
      
      if (!val || !pageObj) {
        showNotification('Please select a valid page from the suggestions', 'error');
        return;
      }
      
      loadDashboard(pageObj);
    }

    function backToLanding() {
      clearAllSearchInputs();
      clearPlayerHistory();
      
      sessionStorage.removeItem('searchPlayerName');
      sessionStorage.removeItem('searchPlayerPage');
      sessionStorage.removeItem('searchPlayerPages');
      sessionStorage.removeItem('currentSearchedPlayer');
      
      navigationContext = 'landing';
      
      showLandingPage();
    }

    function backToDashboard() {
      resetAllTableStates();
      clearPlayerHistory();
      
      sessionStorage.removeItem('searchPlayerName');
      sessionStorage.removeItem('searchPlayerPage');
      sessionStorage.removeItem('currentSearchedPlayer');
      
      navigationContext = 'dashboard';
      
      updatePageTitle();
      disableControlButtons();
      showLoader();
      loadDashboardData();
    }

    function resetAllTableStates() {
      tableState.current = { type: null, page: 1, data: null, title: null };
      tableState.playerTables = {
        'Total': { page: 1, data: null },
        'Active': { page: 1, data: null },
        'Inactive': { page: 1, data: null },
        'RecentActive': { page: 1, data: null },
        'RecentInactive': { page: 1, data: null }
      };
      tableState.highRisk = { page: 1, data: null };
      tableState.history = { page: 1, data: null };
      tableState.deposits = { month: 0, data: null };
    }

    function showLoadingProgress() {
      const progressMessages = [
        "Loading player data...",
        "Calculating deposits...", 
        "Analyzing activity...",
        "Finalizing dashboard..."
      ];
      
      let current = 0;
      loadingProgress.textContent = progressMessages[0];
      
      progressInterval = setInterval(() => {
        current++;
        if (current < progressMessages.length) {
          loadingProgress.textContent = progressMessages[current];
        } else {
          clearInterval(progressInterval);
        }
      }, 800);
    }

    function renderDashboard(data) {
      currentPageData = data;

      const dash = document.getElementById('dashboardBoxes');
      dash.style.display = 'block';
      document.getElementById('tableContainer').style.display = 'block';

      statsRow1.innerHTML = "";
      statsRow2.innerHTML = "";
      statsRow3.innerHTML = "";

      document.getElementById('playerHistorySection').style.display = 'none';
      document.getElementById('globalPlayerHistorySection').style.display = 'none';
      clearPlayerHistory();
      pageDepositsView.style.display = 'none';

      const firstRowBoxes = [
        { label: "Total Players", value: data.counts.Total || 0, type: "Total", icon: "fas fa-users", colorClass: "total" },
        { label: "Active Players", value: data.counts.Active || 0, type: "Active", icon: "fas fa-user-check", colorClass: "active" },
        { label: "Inactive Players", value: data.counts.Inactive || 0, type: "Inactive", icon: "fas fa-user-times", colorClass: "inactive" }
      ];

      const secondRowBoxes = [
        { label: "Recent Active", value: data.counts.RecentActive || 0, type: "RecentActive", icon: "fas fa-bolt", colorClass: "recent-active" },
        { label: "Recent Inactive", value: data.counts.RecentInactive || 0, type: "RecentInactive", icon: "fas fa-clock", colorClass: "recent-inactive" },
        { label: "High Risk Players", value: data.counts.HighRisk || 0, type: "HighRisk", icon: "fas fa-exclamation-triangle", colorClass: "high-risk" }
      ];

      const thirdRowBoxes = [
        { label: "Player History", value: "", type: "PlayerHistory", icon: "fas fa-history", colorClass: "history" },
        { label: "Page Deposits", value: "", type: "PageDeposits", icon: "fas fa-money-bill-wave", colorClass: "deposits" },
        { label: "Coming Soon", value: "", type: "ComingSoon2", icon: "fas fa-cogs", colorClass: "coming-soon" }
      ];

      firstRowBoxes.forEach(b => {
        const div = document.createElement('div');
        div.className = `stat-card ${b.colorClass}`;

        let displayValue = (b.value === "" || b.value === undefined || b.value === null) ? 0 : b.value;

        div.innerHTML = `
          <div class="stat-icon">
            <i class="${b.icon}"></i>
          </div>
          <div class="stat-value">${displayValue}</div>
          <div class="stat-label">${b.label}</div>
        `;

        div.onclick = () => showBoxData(b.type);
        statsRow1.appendChild(div);
      });

      secondRowBoxes.forEach(b => {
        const div = document.createElement('div');
        div.className = `stat-card ${b.colorClass}`;

        let displayValue = (b.value === "" || b.value === undefined || b.value === null) ? 0 : b.value;

        div.innerHTML = `
          <div class="stat-icon">
            <i class="${b.icon}"></i>
          </div>
          <div class="stat-value">${displayValue}</div>
          <div class="stat-label">${b.label}</div>
        `;

        div.onclick = () => showBoxData(b.type);
        statsRow2.appendChild(div);
      });

      thirdRowBoxes.forEach(b => {
        const div = document.createElement('div');
        div.className = `stat-card ${b.colorClass}`;

        let displayValue = (b.type === "PlayerHistory" || b.type === "PageDeposits" || b.type.startsWith("ComingSoon")) ? "" : (b.value === "" || b.value === undefined || b.value === null) ? 0 : b.value;

        let comingSoonBadge = '';
        if (b.type.startsWith("ComingSoon")) {
          comingSoonBadge = '<div class="coming-soon-badge">Coming Soon</div>';
        }

        div.innerHTML = `
          ${comingSoonBadge}
          <div class="stat-icon">
            <i class="${b.icon}"></i>
          </div>
          <div class="stat-value">${displayValue}</div>
          <div class="stat-label">
            ${b.label}
          </div>
        `;

        if (b.type.startsWith("ComingSoon")) {
          div.onclick = () => showNotification('This feature is coming soon!', 'warning');
        } else {
          div.onclick = () => showBoxData(b.type);
        }
        statsRow3.appendChild(div);
      });

      document.getElementById('tableContainer').innerHTML = "";
      clearBackContainer();
      document.getElementById('playerHistorySection').style.display = 'none';
      document.getElementById('globalPlayerHistorySection').style.display = 'none';
      
      document.getElementById('dashboard').style.display = 'block';
      
      sessionStorage.removeItem('searchPlayerName');
      sessionStorage.removeItem('searchPlayerPage');
      sessionStorage.removeItem('currentSearchedPlayer');
    }

    function showBoxData(type) {
      document.getElementById('dashboardBoxes').style.display = 'none';
      const tbl = document.getElementById('tableContainer');
      const backDiv = document.getElementById('backContainer');
      tbl.innerHTML = "";
      document.getElementById('playerHistorySection').style.display = 'none';
      document.getElementById('globalPlayerHistorySection').style.display = 'none';
      pageDepositsView.style.display = 'none';

      tableState.current.type = type;
      tableState.current.title = getTableTitle(type);

      backDiv.innerHTML = '<button class="btn btn-secondary" onclick="backToDashboard()"><i class="fas fa-arrow-left"></i> Back to Dashboard</button>';
      
      if (type === "PlayerHistory") {
        document.getElementById('playerHistorySection').style.display = 'block';
        currentView = 'playerHistory';
        sessionStorage.setItem('currentView', 'playerHistory');
        return;
      }

      if (type === "PageDeposits") {
        showPageDeposits();
        return;
      }

      let filtered = [];
      let tableTitle = getTableTitle(type);
      
      switch(type) {
        case "Total": 
          filtered = currentPageData.players; 
          break;
        case "Active": 
          filtered = currentPageData.players.filter(p => p.status === "Active"); 
          break;
        case "Inactive": 
          filtered = currentPageData.players.filter(p => p.status === "Inactive" && p.daysSince >= INACTIVE_THRESHOLD); 
          break;
        case "RecentActive": 
          filtered = currentPageData.recentActivePlayers || []; 
          break;
        case "RecentInactive": 
          filtered = currentPageData.recentInactivePlayers || []; 
          break;
        case "HighRisk": 
          if (currentPageData.highRiskPlayers && currentPageData.highRiskPlayers.length > 0) {
            renderHighRiskTable();
            return;
          } else {
            tbl.innerHTML = "<div class='table-container' style='text-align: center; padding: 2rem;'><p>No high risk players found.</p></div>";
          }
          break;
      }

      if (!filtered.length) {
        tbl.innerHTML = `<div class='table-container' style='text-align: center; padding: 2rem;'><p>No ${type.toLowerCase()} players found.</p></div>`;
      } else {
        renderPlayerTable(filtered, tableTitle, type);
      }

      currentView = 'table';
      sessionStorage.setItem('currentView', 'table');
    }

    function getTableTitle(type) {
      switch(type) {
        case "Total": return "All Players";
        case "Active": return "Active Players (0-2 days)";
        case "Inactive": return "Inactive Players (15+ days)";
        case "RecentActive": return "Recent Active Players";
        case "RecentInactive": return "Recent Inactive Players (3-4 days)";
        case "HighRisk": return "High Risk Players Analysis";
        default: return "Players";
      }
    }

    function renderPlayerTable(players, title, type) {
      const totalPlayers = players.length;
      const currentPage = tableState.playerTables[type].page;
      const paginatedPlayers = getPaginatedPlayers(players, currentPage, PLAYERS_PER_PAGE);
      
      let html = `
        <div class="table-container">
          <div class="table-header">
            <h3 class="table-title">${title} (${totalPlayers} total)</h3>
            <div id="paginationContainer"></div>
          </div>
          <div class="table-scroll-container">
            <table style="font-size: 0.875rem;">
              <thead>
                <tr>
                  <th style="min-width: 50px; text-align: center;">S.No</th>
                  <th style="min-width: 120px;">Player</th>
                  <th style="min-width: 140px;">Last Deposit</th>
                  <th style="min-width: 100px;">Time Since</th>
                  <th style="min-width: 80px;">Status</th>
                  <th style="min-width: 90px; text-align: center;">Total $</th>
                  <th style="min-width: 90px; text-align: center;">Last 7d $</th>
                  ${type === "RecentActive" ? '<th style="min-width: 80px;">Gap Days</th>' : ''}
                  <th style="min-width: 90px; text-align: center;">Notes</th>
                </tr>
              </thead>
              <tbody>
      `;
      
      paginatedPlayers.forEach((p, index) => {
        const cls = p.status === "Active" ? "status-active" : "status-inactive";
        
        const gapDisplay = formatTimeSince(p.originalTimestamp);
        const gapDays = p.gapDays ? p.gapDays : 'N/A';
        
        const notesBtnClass = p.hasNotes ? 'notes-btn has-notes' : 'notes-btn';
        const notesBtnIcon = p.hasNotes ? 'fa-sticky-note' : 'fa-plus';
        const notesBtnText = p.hasNotes ? 'Notes' : 'Add';
        
        const serialNumber = (currentPage - 1) * PLAYERS_PER_PAGE + index + 1;
        
        html += `
          <tr>
            <td style="text-align: center;">${serialNumber}</td>
            <td>${p.player}</td>
            <td>${p.lastDeposit}</td>
            <td>${gapDisplay}</td>
            <td><span class="status-badge ${cls}">${p.status}</span></td>
            <td style="text-align: center;">${p.totalDeposit || 0}</td>
            <td style="text-align: center;">${p.last7DaysDeposit || 0}</td>
            ${type === "RecentActive" ? `<td style="text-align: center;">${gapDays}</td>` : ''}
            <td style="text-align: center;">
              <button class="${notesBtnClass}" onclick="showNotesModal('${p.player.replace(/'/g, "\\'")}', this)" title="${p.hasNotes ? 'View notes' : 'Add note'}">
                <i class="fas ${notesBtnIcon}"></i> ${notesBtnText}
              </button>
            </td>
          </tr>
        `;
      });
      
      html += `
              </tbody>
            </table>
          </div>
        </div>
      `;
      
      document.getElementById('tableContainer').innerHTML = html;
      
      const paginationContainer = document.getElementById('paginationContainer');
      renderPagination(totalPlayers, currentPage, PLAYERS_PER_PAGE, paginationContainer, `changePlayerPage_${type}`);
    }

    function renderHighRiskTable() {
      const highRiskPlayers = currentPageData.highRiskPlayers;
      const totalPlayers = highRiskPlayers.length;
      const currentPage = tableState.highRisk.page;
      const paginatedPlayers = getPaginatedPlayers(highRiskPlayers, currentPage, PLAYERS_PER_PAGE);
      
      let html = `
        <div class="table-container">
          <div class="table-header">
            <h3 class="table-title">High Risk Players Analysis (${totalPlayers} total)</h3>
            <div id="paginationContainer"></div>
          </div>
          <div class="table-scroll-container">
            <table class="high-risk-table">
              <thead>
                <tr>
                  <th style="text-align: center;">S.No</th>
                  <th>Player</th>
                  <th>Risk</th>
                  <th>Gaps</th>
                  <th>Gap Details</th>
                  <th>Last Deposit</th>
                  <th>Time Since</th>
                  <th>Status</th>
                  <th>Deposits</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
      `;
      
      paginatedPlayers.forEach((p, index) => {
        const statusClass = p.currentStatus === "Active" ? "status-active" : "status-inactive";
        
        const lastDepositPKT = convertUTCToPKT(p.lastDeposit);
        const gapDisplay = formatTimeSince(p.lastDeposit);
        
        let gapDetails = '';
        p.gaps.forEach((gap, gapIndex) => {
          gapDetails += `
            <div class="gap-item">
              <strong>${gap.gapDays}d</strong>: ${gap.gapBetween}
            </div>
          `;
        });
        
        let riskClass = '';
        if (p.riskLevel === "Very High") riskClass = 'risk-very-high';
        else if (p.riskLevel === "High") riskClass = 'risk-high';
        else if (p.riskLevel === "Medium") riskClass = 'risk-medium';
        else if (p.riskLevel === "Low") riskClass = 'risk-low';
        
        const notesBtnClass = p.hasNotes ? 'notes-btn has-notes' : 'notes-btn';
        const notesBtnIcon = p.hasNotes ? 'fa-sticky-note' : 'fa-plus';
        const notesBtnText = p.hasNotes ? 'Notes' : 'Add';
        
        const serialNumber = (currentPage - 1) * PLAYERS_PER_PAGE + index + 1;
        
        html += `
          <tr>
            <td style="text-align: center;">${serialNumber}</td>
            <td><strong>${p.player}</strong></td>
            <td class="${riskClass}"><strong>${p.riskLevel}</strong></td>
            <td style="text-align: center;">${p.totalQualifyingGaps}</td>
            <td>
              <div class="gap-details-compact">
                ${gapDetails}
              </div>
            </td>
            <td>${lastDepositPKT}</td>
            <td>${gapDisplay}</td>
            <td><span class="status-badge ${statusClass}">${p.currentStatus}</span></td>
            <td style="text-align: center;">${p.totalDeposits}</td>
            <td>
              <button class="${notesBtnClass}" onclick="showNotesModal('${p.player.replace(/'/g, "\\'")}', this)" title="${p.hasNotes ? 'View notes' : 'Add note'}">
                <i class="fas ${notesBtnIcon}"></i> ${notesBtnText}
              </button>
            </td>
          </tr>
        `;
      });
      
      html += `
              </tbody>
            </table>
          </div>
        </div>
        <div style="margin-top: 1.5rem; background: var(--bg-card); padding: 1.5rem; border-radius: 12px; box-shadow: var(--shadow); border: 1px solid var(--border-color);">
          <h4 style="color: var(--text-primary); margin-bottom: 1rem;">Risk Level Explanation</h4>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-top: 1rem;">
            <div><span class="risk-very-high"> Very High</span>: 3+ gaps OR 12+ day gap</div>
            <div><span class="risk-high"> High</span>: 2+ gaps OR 10+ day gap</div>
            <div><span class="risk-medium"> Medium</span>: 1 gap with 8+ days</div>
            <div><span class="risk-low"> Low</span>: Single smaller gaps</div>
          </div>
          <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color);">
            <p style="color: var(--text-primary); font-weight: 500; font-size: 0.9rem;">Note: High Risk players include those with gaps from 5 to 14 days 23 hours 59 minutes. Players with 15+ day gaps are moved to Inactive.</p>
          </div>
        </div>
      `;
      
      document.getElementById('tableContainer').innerHTML = html;
      
      const paginationContainer = document.getElementById('paginationContainer');
      renderPagination(totalPlayers, currentPage, PLAYERS_PER_PAGE, paginationContainer, 'changeHighRiskPage');
    }

    function createPlayerPageChangeFunction(type) {
      return function(page) {
        tableState.playerTables[type].page = page;
        let filtered = [];
        
        switch(type) {
          case "Total": filtered = currentPageData.players; break;
          case "Active": filtered = currentPageData.players.filter(p => p.status === "Active"); break;
          case "Inactive": filtered = currentPageData.players.filter(p => p.status === "Inactive" && p.daysSince >= 15); break;
          case "RecentActive": filtered = currentPageData.recentActivePlayers || []; break;
          case "RecentInactive": filtered = currentPageData.recentInactivePlayers || []; break;
        }
        
        renderPlayerTable(filtered, getTableTitle(type), type);
      };
    }

    const changePlayerPage_Total = createPlayerPageChangeFunction('Total');
    const changePlayerPage_Active = createPlayerPageChangeFunction('Active');
    const changePlayerPage_Inactive = createPlayerPageChangeFunction('Inactive');
    const changePlayerPage_RecentActive = createPlayerPageChangeFunction('RecentActive');
    const changePlayerPage_RecentInactive = createPlayerPageChangeFunction('RecentInactive');

    function changeHighRiskPage(page) {
      tableState.highRisk.page = page;
      renderHighRiskTable();
    }

    async function showPageDeposits() {
      tableState.deposits.month = 0;
      
      document.getElementById('tableContainer').innerHTML = '';
      document.getElementById('playerHistorySection').style.display = 'none';
      document.getElementById('globalPlayerHistorySection').style.display = 'none';
      document.getElementById('backContainer').innerHTML = '';
      
      pageDepositsView.innerHTML = `
        <div style="text-align: center; padding: 2rem;">
          <div class="spinner"></div>
          <p style="margin-top: 1rem; color: var(--text-secondary);">Loading daily deposits data...</p>
        </div>
      `;
      pageDepositsView.style.display = 'block';
      
      await loadPageDepositsData();
    }

    async function loadPageDepositsData() {
      try {
        const data = await getPageDailyDeposits(selectedPage, tableState.deposits.month);
        renderPageDeposits(data);
      } catch (error) {
        pageDepositsView.innerHTML = `
          <div style="text-align: center; padding: 2rem; color: var(--danger);">
            <p><strong>Error loading daily deposits:</strong></p>
            <p style="margin-top: 1rem; color: var(--text-secondary);">${error}</p>
          </div>
        `;
      }
    }

    async function changePageDepositsMonth(page) {
      tableState.deposits.month = page - 1;
      pageDepositsView.innerHTML = `
        <div style="text-align: center; padding: 2rem;">
          <div class="spinner"></div>
          <p style="margin-top: 1rem; color: var(--text-secondary);">Loading monthly data...</p>
        </div>
      `;
      await loadPageDepositsData();
    }

    function closePageDeposits() {
      pageDepositsView.style.display = 'none';
      tableState.deposits.month = 0;
      backToDashboard();
    }

    function renderPageDeposits(data) {
      if (!data.success || !data.dailyDeposits || data.dailyDeposits.length === 0) {
        pageDepositsView.innerHTML = `
          <div class="page-deposits-view">
            <div class="deposits-header">
              <h2 class="deposits-title">Daily Deposits - ${selectedPage}</h2>
              <button class="close-deposits-btn" onclick="closePageDeposits()" title="Close">
                <i class="fas fa-times"></i>
              </button>
            </div>
            <div style="text-align: center; padding: 2rem; color: var(--text-secondary);">
              <p>${data.message || "No daily deposit data available."}</p>
            </div>
          </div>
        `;
        return;
      }

      const totalDaysInPeriod = data.dailyDeposits.length;
      const dailyAverage = totalDaysInPeriod > 0 ? data.totalAmount / totalDaysInPeriod : 0;

      let html = `
        <div class="page-deposits-view">
          <div class="deposits-header">
            <h2 class="deposits-title">Daily Deposits - ${selectedPage}</h2>
            <button class="close-deposits-btn" onclick="closePageDeposits()" title="Close">
              <i class="fas fa-times"></i>
            </button>
          </div>
          
          <div style="margin-bottom: 1.5rem;">
            <h4 style="color: var(--text-primary); margin-bottom: 1rem; text-align: center;">${data.currentMonth}</h4>
      `;

      if (data.monthlyComparison) {
        const comparison = data.monthlyComparison;
        const comparisonClass = comparison.direction === 'up' ? 'up' : comparison.direction === 'down' ? 'down' : 'same';
        const arrow = comparison.direction === 'up' ? '' : comparison.direction === 'down' ? '' : '';
        
        html += `
          <div class="monthly-comparison ${comparisonClass}">
            ${arrow} $${Math.abs(comparison.difference).toFixed(2)} vs ${comparison.previousMonth} (${comparison.direction === 'up' ? '+' : ''}${comparison.percentage}%)
          </div>
        `;
      }

      html += `
          <div class="monthly-summary">
            <div class="summary-card">
              <div class="summary-value">$${data.totalAmount.toFixed(2)}</div>
              <div class="summary-label">Total Amount</div>
            </div>
            <div class="summary-card">
              <div class="summary-value">${data.totalTransactions}</div>
              <div class="summary-label">Total Transactions</div>
            </div>
            <div class="summary-card">
              <div class="summary-value">${totalDaysInPeriod}</div>
              <div class="summary-label">Total Days</div>
            </div>
            <div class="summary-card">
              <div class="summary-value">$${dailyAverage.toFixed(2)}</div>
              <div class="summary-label">Daily Average</div>
            </div>
          </div>
        </div>
        
        <div class="table-container">
          <div class="table-header">
            <h3 class="table-title">Daily Deposit Breakdown - ${data.currentMonth} (${data.totalTransactions} total transactions)</h3>
            <div class="pagination-controls">
              <div class="pagination-info">
                Page ${data.currentPage} of ${data.totalPages}
              </div>
              <div class="pagination-buttons" id="pageDepositsPaginationContainer"></div>
            </div>
          </div>
          <div class="table-scroll-container">
            <table class="daily-deposits-table">
              <thead>
                <tr>
                  <th style="text-align: left; min-width: 120px;">Date</th>
                  <th style="text-align: right; min-width: 100px;">Amount</th>
                  <th style="text-align: center; min-width: 100px;">Transactions</th>
                  <th style="text-align: center; min-width: 140px;">Daily Trend</th>
                </tr>
              </thead>
              <tbody>
      `;

      data.dailyDeposits.forEach(day => {
        let trendHtml = '-';
        if (day.trend) {
          const trendClass = day.trend.direction === 'up' ? 'trend-up' : day.trend.direction === 'down' ? 'trend-down' : 'trend-same';
          const arrow = day.trend.direction === 'up' ? '' : day.trend.direction === 'down' ? '' : '';
          const sign = day.trend.direction === 'up' ? '+' : '';
          
          trendHtml = `
            <span class="${trendClass}">
              ${arrow} $${Math.abs(day.trend.difference).toFixed(2)} (${sign}${day.trend.percentage}%)
            </span>
          `;
        }

        const amountClass = day.totalAmount > 0 ? 'amount-cell positive' : 'amount-cell zero';
        const amountDisplay = day.totalAmount > 0 ? '$' + day.totalAmount.toFixed(2) : '$0.00';
        
        html += `
          <tr>
            <td style="text-align: left;">${day.displayDate}</td>
            <td class="${amountClass}">${amountDisplay}</td>
            <td class="count-cell">${day.transactionCount}</td>
            <td class="trend-cell">${trendHtml}</td>
          </tr>
        `;
      });

      html += `
            <tr class="total-row">
              <td style="text-align: left;"><strong>TOTAL</strong></td>
              <td class="amount-cell positive"><strong>$${data.totalAmount.toFixed(2)}</strong></td>
              <td class="count-cell"><strong>${data.totalTransactions}</strong></td>
              <td class="trend-cell">-</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    
    <div style="margin-top: 1.5rem; background: var(--bg-secondary); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color);">
      <p style="color: var(--text-primary); font-size: 0.9rem; text-align: center;">
        <i class="fas fa-info-circle"></i> Showing ${data.dailyDeposits.length} day(s) for ${data.currentMonth}
        ${data.monthlyComparison ? ` | Compared to ${data.monthlyComparison.previousMonth}` : ''}
      </p>
    </div>
  `;

      pageDepositsView.innerHTML = html;

      const paginationContainer = document.getElementById('pageDepositsPaginationContainer');
      if (data.totalPages > 1) {
        renderPagination(data.totalPages, data.currentPage, 1, paginationContainer, 'changePageDepositsMonth');
      }
    }

    function renderEnhancedPlayerHistory(data, playerName, pageName, isGlobal = false) {
      const container = isGlobal ? 
        document.getElementById('globalPlayerHistoryContainer') : 
        document.getElementById('playerHistoryContainer');
      
      if (!data.enhancedHistory || data.enhancedHistory.length === 0) {
        container.innerHTML = `
          <div style="text-align: center; padding: 2rem; color: var(--text-secondary);">
            <p>${data.message || "No enhanced history available for this player."}</p>
          </div>
        `;
        return;
      }

      const pageObj = PAGES.find(p => p.name === pageName);
      const pageEmoji = pageObj ? pageObj.emoji : '';
      const currentStatus = data.currentStatus || "Unknown";
      const isCurrentlyActive = currentStatus === "Active";

      const reversedHistory = [...data.enhancedHistory].reverse();
      const totalEntries = reversedHistory.length;
      const startIndex = (tableState.history.page - 1) * PLAYERS_PER_PAGE;
      const endIndex = Math.min(startIndex + PLAYERS_PER_PAGE, totalEntries);
      const paginatedHistory = reversedHistory.slice(startIndex, endIndex);

      let html = `
        <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; border: 1px solid var(--border-color);">
          <div style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 0.5rem; font-weight: 500;">
            <i class="fas fa-layer-group"></i> Player on ${isGlobal ? 'Page' : 'Current Page'}:
          </div>
          <div style="display: flex; align-items: center; gap: 0.5rem;">
            <span style="font-size: 1.2rem;">${pageEmoji}</span>
            <span style="font-weight: 600; color: var(--text-primary);">${pageName}</span>
          </div>
          <div style="margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-primary);">
            <i class="fas fa-user"></i> Player: <strong>${playerName}</strong>
          </div>
        </div>
        
        <div class="current-status ${isCurrentlyActive ? 'status-active-bg' : 'status-inactive-bg'}">
          <i class="fas ${isCurrentlyActive ? 'fa-check-circle' : 'fa-times-circle'}"></i>
          Player is currently ${currentStatus} on ${pageName}
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
          <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid var(--border-color);">
            <div style="font-size: 0.875rem; color: var(--text-secondary);">Total Deposits</div>
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--text-primary);">${data.rawDeposits || 0}</div>
          </div>
          <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid var(--border-color);">
            <div style="font-size: 0.875rem; color: var(--text-secondary);">Deposit Days</div>
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--text-primary);">${data.totalDepositDays || 0}</div>
          </div>
          <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid var(--border-color);">
            <div style="font-size: 0.875rem; color: var(--text-secondary);">Last Deposit</div>
            <div style="font-size: 1rem; font-weight: 600; color: var(--text-primary);">${data.timeSinceDisplay || 'N/A'}</div>
          </div>
          <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid var(--border-color);">
            <div style="font-size: 0.875rem; color: var(--text-secondary);">Total Amount</div>
            <div style="font-size: 1rem; font-weight: 600; color: var(--text-primary);">$${(data.totalAmount || 0).toFixed(2)}</div>
          </div>
        </div>
        
        <div class="table-container">
          <div class="table-header">
            <h3 class="table-title">Complete Activity Timeline (Latest First) - Showing ALL Deposits</h3>
            <div class="pagination-controls">
              <div class="pagination-info">
                Showing ${startIndex + 1}-${endIndex} of ${totalEntries} periods
              </div>
              <div class="pagination-buttons" id="historyPaginationContainer"></div>
            </div>
          </div>
          <div class="table-scroll-container">
            <table class="enhanced-history-table">
              <thead>
                <tr>
                  <th style="text-align: left;">Date / Period</th>
                  <th style="text-align: left;">Activity Details</th>
                  <th style="text-align: center;">Status</th>
                  <th style="text-align: center;">Gap Duration</th>
                  <th style="text-align: left;">Activity Level</th>
                </tr>
              </thead>
              <tbody>
      `;

      paginatedHistory.forEach(period => {
        const isActive = period.status === 'Active';
        const rowClass = isActive ? 'active-row' : 'inactive-row';
        const statusBadge = isActive ? 
          '<span class="status-badge status-active">Active</span>' : 
          '<span class="status-badge status-inactive">Inactive</span>';
        
        // FIXED: Active days show dash, inactive days show exact gap
        const gapDisplay = period.gapDuration;
        let gapClass = '';
        
        if (!isActive && period.inactiveGap > 0) {
          if (period.inactiveGap >= 7) gapClass = 'gap-high';
          else if (period.inactiveGap >= 4) gapClass = 'gap-medium';
          else gapClass = 'gap-low';
        }

        let activityDisplay = period.activity;
        if (isActive && period.depositCount > 0) {
          const amountText = period.totalAmount > 0 ? ` - $${period.totalAmount.toFixed(2)}` : '';
          activityDisplay = `${period.depositCount} deposit${period.depositCount > 1 ? 's' : ''}${amountText}`;
        }

        // Determine activity level display with new logic
        let activityLevelDisplay = '';
        if (isActive) {
          if (period.activityLevel === 'High') {
            activityLevelDisplay = '<span style="color: var(--success);"><i class="fas fa-bolt"></i> High Activity</span>';
          } else {
            activityLevelDisplay = '<span style="color: var(--info);"><i class="fas fa-check"></i> Normal</span>';
          }
        } else {
          activityLevelDisplay = '<span style="color: var(--text-secondary);"><i class="fas fa-moon"></i> No Activity</span>';
        }

        html += `
          <tr class="${rowClass}">
            <td class="date-range-cell" style="text-align: left;">${period.dateRange}</td>
            <td style="text-align: left;">
              <div style="font-weight: 500;">${activityDisplay}</div>
              ${isActive && period.depositCount > 1 ? 
                `<div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.25rem;">
                  <i class="fas fa-coins"></i> Multiple transactions this day
                </div>` : ''
              }
            </td>
            <td style="text-align: center;">${statusBadge}</td>
            <td class="gap-cell" style="text-align: center;">
              ${isActive ? 
                '<span></span>' : 
                `<span class="${gapClass}">${gapDisplay}</span>`
              }
            </td>
            <td style="text-align: left;">
              ${activityLevelDisplay}
            </td>
          </tr>
        `;
      });

      html += `
          </tbody>
        </table>
      </div>
    </div>
    
    <div style="margin-top: 1.5rem; background: var(--bg-secondary); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color);">
      <h5 style="color: var(--text-primary); margin-bottom: 0.5rem;">Activity Level Legend:</h5>
      <div style="display: flex; flex-wrap: wrap; gap: 1rem; font-size: 0.875rem;">
        <div><span style="color: var(--success);"><i class="fas fa-bolt"></i> High Activity</span>: >4 deposits OR >$50 in one day</div>
        <div><span style="color: var(--info);"><i class="fas fa-check"></i> Normal Activity</span>: 4 deposits AND $50 in one day</div>
        <div><span style="color: var(--text-secondary);"><i class="fas fa-moon"></i> No Activity</span>: No deposits</div>
      </div>
    </div>
  `;

  container.innerHTML = html;

  const paginationContainer = document.getElementById('historyPaginationContainer');
  renderPagination(totalEntries, tableState.history.page, PLAYERS_PER_PAGE, paginationContainer, 'changeHistoryPage');
}

    function changeHistoryPage(page) {
      tableState.history.page = page;
      const playerName = sessionStorage.getItem('searchPlayerName') || sessionStorage.getItem('currentSearchedPlayer');
      const pageName = sessionStorage.getItem('searchPlayerPage') || selectedPage;
      const isGlobal = !!sessionStorage.getItem('searchPlayerName');
      
      if (isGlobal) {
        showEnhancedGlobalPlayerHistory(playerName, pageName);
      } else {
        showEnhancedPlayerHistoryForCurrentPage(playerName, pageName);
      }
    }

    // Notes Modal Functions
    async function showNotesModal(playerName, buttonElement) {
      currentNotesPlayer = playerName;
      currentNotesPlayerName = playerName;
      currentNotesButton = buttonElement;
      
      notesModalTitle.textContent = `Notes for ${playerName}`;
      noteTextInput.value = '';
      
      await loadPlayerNotes(playerName);
      
      notesModal.style.display = 'block';
      noteTextInput.focus();
      
      // If viewer role, disable note input
      if (userRole === PIN_CONFIG.ROLES.VIEWER) {
        noteTextInput.disabled = true;
        noteTextInput.placeholder = "Viewer role cannot add notes";
        saveNoteBtn.disabled = true;
        saveNoteBtn.style.display = 'none';
      } else {
        noteTextInput.disabled = false;
        noteTextInput.placeholder = "Enter your note here...";
        saveNoteBtn.disabled = false;
        saveNoteBtn.style.display = 'inline-flex';
      }
    }

    function hideNotesModal() {
      notesModal.style.display = 'none';
      currentNotesPlayer = null;
      currentNotesPlayerName = null;
      currentNotesButton = null;
      noteTextInput.value = '';
      noteTextInput.disabled = false;
      saveNoteBtn.disabled = false;
      saveNoteBtn.style.display = 'inline-flex';
    }

    async function loadPlayerNotes(playerName) {
      notesList.innerHTML = '<div class="no-notes">Loading notes...</div>';
      
      try {
        const result = await getPlayerNotes(selectedPage, playerName);
        if (result.success && result.notes.length > 0) {
          let notesHtml = '';
          result.notes.forEach(note => {
            const formattedDate = convertUTCToPKT(note.timestamp);
            
            notesHtml += `
              <div class="note-item">
                <div class="note-timestamp">
                  <i class="fas fa-clock"></i> ${formattedDate}
                </div>
                <div class="note-text">${note.note}</div>
              </div>
            `;
          });
          notesList.innerHTML = notesHtml;
        } else {
          notesList.innerHTML = '<div class="no-notes">No notes yet for this player.</div>';
        }
      } catch (error) {
        notesList.innerHTML = '<div class="no-notes">Error loading notes.</div>';
        console.error('Error loading notes:', error);
      }
    }

    async function savePlayerNote() {
      // Check if user has permission
      if (userRole === PIN_CONFIG.ROLES.VIEWER) {
        showNotification('Viewer role cannot add notes', 'warning');
        return;
      }
      
      const noteText = noteTextInput.value.trim();
      
      if (!noteText) {
        showNotification('Please enter a note before saving', 'error');
        return;
      }
      
      saveNoteBtn.disabled = true;
      saveNoteBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
      
      try {
        const result = await addPlayerNote(selectedPage, currentNotesPlayer, noteText);
        if (result.success) {
          showNotification('Note saved successfully!', 'success');
          noteTextInput.value = '';
          await loadPlayerNotes(currentNotesPlayer);
          
          if (currentNotesButton) {
            currentNotesButton.innerHTML = '<i class="fas fa-sticky-note"></i> Notes';
            currentNotesButton.className = 'notes-btn has-notes';
          }
          
          updateCurrentPageDataWithNote(currentNotesPlayer);
        } else {
          showNotification('Error saving note: ' + result.message, 'error');
        }
      } catch (error) {
        showNotification('Error saving note: ' + error, 'error');
      } finally {
        saveNoteBtn.disabled = false;
        saveNoteBtn.innerHTML = '<i class="fas fa-save"></i> Save Note';
      }
    }

    function updateCurrentPageDataWithNote(playerName) {
      currentPageData.players.forEach(player => {
        if (player.player === playerName) {
          player.hasNotes = true;
        }
      });
      
      if (currentPageData.recentActivePlayers) {
        currentPageData.recentActivePlayers.forEach(player => {
          if (player.player === playerName) {
            player.hasNotes = true;
          }
        });
      }
      
      if (currentPageData.recentInactivePlayers) {
        currentPageData.recentInactivePlayers.forEach(player => {
          if (player.player === playerName) {
            player.hasNotes = true;
          }
        });
      }
      
      if (currentPageData.highRiskPlayers) {
        currentPageData.highRiskPlayers.forEach(player => {
          if (player.player === playerName) {
            player.hasNotes = true;
          }
        });
      }
    }

    // Modal functions
    function showRefreshModal() {
      // Check if user has permission
      if (userRole === PIN_CONFIG.ROLES.VIEWER) {
        showNotification('Viewer role cannot refresh data', 'warning');
        return;
      }
      
      if (refreshBtn.disabled) return;
      refreshPinInput.value = '';
      refreshModal.style.display = 'block';
      refreshPinInput.focus();
    }

    function hideRefreshModal() {
      refreshModal.style.display = 'none';
      refreshPinInput.value = '';
    }

    function showCleanupModal() {
      // Check if user has permission
      if (userRole === PIN_CONFIG.ROLES.VIEWER) {
        showNotification('Viewer role cannot perform cleanup', 'warning');
        return;
      }
      
      if (forceCleanupBtn.disabled) return;
      cleanupPinInput.value = '';
      cleanupModal.style.display = 'block';
      cleanupPinInput.focus();
    }

    function hideCleanupModal() {
      cleanupModal.style.display = 'none';
      cleanupPinInput.value = '';
    }

    async function confirmRefresh() {
      const pin = refreshPinInput.value.trim();
      if (!pin) {
        showNotification('Please enter PIN', 'error');
        return;
      }
      
      if (pin !== AUTH_PIN) {
        showNotification('Invalid PIN', 'error');
        return;
      }
      
      hideRefreshModal();
      disableAllButtons();
      refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
      showLoader();
      
      try {
        const { data, error } = await supabase.rpc('refresh_player_status', {});
        
        if (error) throw error;
        
        if (data && data.success) {
          showNotification(data.message, 'success');
          await loadDashboardData();
        } else {
          showNotification('Refresh failed: ' + (data?.message || 'Unknown error'), 'error');
        }
      } catch (error) {
        showNotification('Error refreshing data: ' + error.message, 'error');
      } finally {
        refreshBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Refresh Data';
        enableAllButtons();
      }
    }

    async function confirmForceCleanup() {
      const pin = cleanupPinInput.value.trim();
      if (!pin) {
        showNotification('Please enter PIN', 'error');
        return;
      }
      
      if (pin !== AUTH_PIN) {
        showNotification('Invalid PIN', 'error');
        return;
      }
      
      hideCleanupModal();
      disableAllButtons();
      forceCleanupBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Cleaning...';
      showLoader();
      
      try {
        const { data, error } = await supabase.rpc('force_cleanup', {});
        
        if (error) throw error;
        
        if (data && data.success) {
          showNotification(data.message, 'warning');
          await loadDashboardData();
        } else {
          showNotification('Cleanup failed: ' + (data?.message || 'Unknown error'), 'error');
        }
      } catch (error) {
        showNotification('Error during cleanup: ' + error.message, 'error');
      } finally {
        forceCleanupBtn.innerHTML = '<i class="fas fa-broom"></i> Force Cleanup';
        enableAllButtons();
      }
    }

    function disableAllButtons() {
      changePageBtn.disabled = true;
      refreshBtn.disabled = true;
      forceCleanupBtn.disabled = true;
      if (logoutBtnDashboard) logoutBtnDashboard.disabled = true;
      if (logoutBtnLanding) logoutBtnLanding.disabled = true;
    }

    function enableAllButtons() {
      changePageBtn.disabled = false;
      refreshBtn.disabled = false;
      forceCleanupBtn.disabled = false;
      if (logoutBtnDashboard) logoutBtnDashboard.disabled = false;
      if (logoutBtnLanding) logoutBtnLanding.disabled = false;
    }

    // Event listeners
    window.addEventListener('click', function(event) {
      if (event.target === refreshModal) {
        hideRefreshModal();
      }
      if (event.target === cleanupModal) {
        hideCleanupModal();
      }
      if (event.target === notesModal) {
        hideNotesModal();
      }
    });

    refreshPinInput.addEventListener('keypress', function(event) {
      if (event.key === 'Enter') {
        confirmRefresh();
      }
    });

    cleanupPinInput.addEventListener('keypress', function(event) {
      if (event.key === 'Enter') {
        confirmForceCleanup();
      }
    });

    noteTextInput.addEventListener('keypress', function(event) {
      if (event.key === 'Enter' && (event.ctrlKey || event.metaKey)) {
        savePlayerNote();
      }
    });

    document.addEventListener('click', function(event) {
      if (!event.target.closest('.search-container')) {
        pageSuggestions.innerHTML = '';
        playerSuggestions.innerHTML = '';
      }
    });

    // Theme detection
    function detectTheme() {
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
    }

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', detectTheme);
    detectTheme();
  </script>
</body>
</html>
